{"ast":null,"code":"import _asyncToGenerator from \"/Users/ryanliang/Downloads/main_movir_picker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getParamValue } from './utils';\n\nfunction nmsParams(node, tensorMap, context) {\n  const boxes = getParamValue('boxes', node, tensorMap, context);\n  const scores = getParamValue('scores', node, tensorMap, context);\n  const maxOutputSize = getParamValue('maxOutputSize', node, tensorMap, context);\n  const iouThreshold = getParamValue('iouThreshold', node, tensorMap, context);\n  const scoreThreshold = getParamValue('scoreThreshold', node, tensorMap, context);\n  const softNmsSigma = getParamValue('softNmsSigma', node, tensorMap, context);\n  return {\n    boxes,\n    scores,\n    maxOutputSize,\n    iouThreshold,\n    scoreThreshold,\n    softNmsSigma\n  };\n}\n\nexport const executeOp = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (node, tensorMap, context) {\n    switch (node.op) {\n      case 'NonMaxSuppressionV5':\n        {\n          const {\n            boxes,\n            scores,\n            maxOutputSize,\n            iouThreshold,\n            scoreThreshold,\n            softNmsSigma\n          } = nmsParams(node, tensorMap, context);\n          const result = yield tfOps.image.nonMaxSuppressionWithScoreAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);\n          return [result.selectedIndices, result.selectedScores];\n        }\n\n      case 'NonMaxSuppressionV4':\n        {\n          const {\n            boxes,\n            scores,\n            maxOutputSize,\n            iouThreshold,\n            scoreThreshold\n          } = nmsParams(node, tensorMap, context);\n          const padToMaxOutputSize = getParamValue('padToMaxOutputSize', node, tensorMap, context);\n          const result = yield tfOps.image.nonMaxSuppressionPaddedAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);\n          return [result.selectedIndices, result.validOutputs];\n        }\n\n      case 'NonMaxSuppressionV3':\n      case 'NonMaxSuppressionV2':\n        {\n          const {\n            boxes,\n            scores,\n            maxOutputSize,\n            iouThreshold,\n            scoreThreshold\n          } = nmsParams(node, tensorMap, context);\n          return [yield tfOps.image.nonMaxSuppressionAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold)];\n        }\n\n      case 'Where':\n        {\n          const condition = tfOps.cast(getParamValue('condition', node, tensorMap, context), 'bool');\n          const result = [yield tfOps.whereAsync(condition)];\n          condition.dispose();\n          return result;\n        }\n\n      case 'ListDiff':\n        {\n          return tfOps.setdiff1dAsync(getParamValue('x', node, tensorMap, context), getParamValue('y', node, tensorMap, context));\n        }\n\n      default:\n        throw TypeError(`Node type ${node.op} is not implemented`);\n    }\n  });\n\n  return function executeOp(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport const CATEGORY = 'dynamic';","map":{"version":3,"sources":["/Users/ryanliang/Downloads/main_movir_picker/node_modules/@tensorflow/tfjs-converter/dist/operations/executors/dynamic_executor.js"],"names":["tfOps","getParamValue","nmsParams","node","tensorMap","context","boxes","scores","maxOutputSize","iouThreshold","scoreThreshold","softNmsSigma","executeOp","op","result","image","nonMaxSuppressionWithScoreAsync","selectedIndices","selectedScores","padToMaxOutputSize","nonMaxSuppressionPaddedAsync","validOutputs","nonMaxSuppressionAsync","condition","cast","whereAsync","dispose","setdiff1dAsync","TypeError","CATEGORY"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getParamValue } from './utils';\nfunction nmsParams(node, tensorMap, context) {\n    const boxes = getParamValue('boxes', node, tensorMap, context);\n    const scores = getParamValue('scores', node, tensorMap, context);\n    const maxOutputSize = getParamValue('maxOutputSize', node, tensorMap, context);\n    const iouThreshold = getParamValue('iouThreshold', node, tensorMap, context);\n    const scoreThreshold = getParamValue('scoreThreshold', node, tensorMap, context);\n    const softNmsSigma = getParamValue('softNmsSigma', node, tensorMap, context);\n    return {\n        boxes,\n        scores,\n        maxOutputSize,\n        iouThreshold,\n        scoreThreshold,\n        softNmsSigma\n    };\n}\nexport const executeOp = async (node, tensorMap, context) => {\n    switch (node.op) {\n        case 'NonMaxSuppressionV5': {\n            const { boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = nmsParams(node, tensorMap, context);\n            const result = await tfOps.image.nonMaxSuppressionWithScoreAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);\n            return [result.selectedIndices, result.selectedScores];\n        }\n        case 'NonMaxSuppressionV4': {\n            const { boxes, scores, maxOutputSize, iouThreshold, scoreThreshold } = nmsParams(node, tensorMap, context);\n            const padToMaxOutputSize = getParamValue('padToMaxOutputSize', node, tensorMap, context);\n            const result = await tfOps.image.nonMaxSuppressionPaddedAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);\n            return [result.selectedIndices, result.validOutputs];\n        }\n        case 'NonMaxSuppressionV3':\n        case 'NonMaxSuppressionV2': {\n            const { boxes, scores, maxOutputSize, iouThreshold, scoreThreshold } = nmsParams(node, tensorMap, context);\n            return [await tfOps.image.nonMaxSuppressionAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold)];\n        }\n        case 'Where': {\n            const condition = tfOps.cast(getParamValue('condition', node, tensorMap, context), 'bool');\n            const result = [await tfOps.whereAsync(condition)];\n            condition.dispose();\n            return result;\n        }\n        case 'ListDiff': {\n            return tfOps.setdiff1dAsync(getParamValue('x', node, tensorMap, context), getParamValue('y', node, tensorMap, context));\n        }\n        default:\n            throw TypeError(`Node type ${node.op} is not implemented`);\n    }\n};\nexport const CATEGORY = 'dynamic';\n"]},"metadata":{},"sourceType":"module"}
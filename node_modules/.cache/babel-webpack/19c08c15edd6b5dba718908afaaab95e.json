{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { parseNodeName } from '../operations/executors/utils';\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\n\nexport function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {\n  const usedNodes = new Set();\n  const missingInputs = [];\n  let dynamicNode = null;\n  let syncInputs = null; // Start with the outputs, going backwards and find all the nodes that are\n  // needed to compute those outputs.\n\n  const seen = new Set();\n  const inputNodeNames = Object.keys(inputs).map(name => parseNodeName(name)[0]);\n  let initNodeNames = [];\n\n  if (initNodes != null) {\n    initNodeNames = initNodes.map(node => parseNodeName(node.name)[0]);\n  }\n\n  const frontier = [...outputs];\n\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n\n    if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n      if (dynamicNode == null) {\n        dynamicNode = node;\n        syncInputs = dynamicNode.children.map(child => child.name).filter(name => usedNodes.has(name));\n      }\n    }\n\n    usedNodes.add(node.name); // Weights are dead end since we already have their values.\n\n    if (weightMap[node.name] != null) {\n      continue;\n    } // This node is a dead end since it's one of the user-provided inputs.\n\n\n    if (inputNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    } // This node is a dead end since it doesn't have any inputs.\n\n\n    if (initNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    }\n\n    if (node.inputs.length === 0) {\n      missingInputs.push(node.name);\n      continue;\n    }\n\n    node.inputs.forEach(input => {\n      // Don't add to the frontier if it is already there.\n      if (seen.has(input.name)) {\n        return;\n      }\n\n      seen.add(input.name);\n      frontier.push(input);\n    });\n  }\n\n  return {\n    inputs,\n    outputs,\n    usedNodes,\n    missingInputs,\n    dynamicNode,\n    syncInputs\n  };\n}\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\n\nexport function getNodesInTopologicalOrder(graph, weightMap, executionInfo) {\n  const {\n    usedNodes,\n    inputs\n  } = executionInfo;\n  const frontier = [];\n  const inputNodes = Object.keys(inputs).map(name => parseNodeName(name)[0]).map(name => graph.nodes[name]);\n  const initNodes = graph.initNodes;\n  inputNodes.forEach(input => {\n    if (usedNodes.has(input.name)) {\n      frontier.push(input);\n    }\n  });\n  graph.weights.forEach(weight => {\n    if (usedNodes.has(weight.name)) {\n      frontier.push(weight);\n    }\n  });\n\n  if (initNodes != null) {\n    initNodes.forEach(node => {\n      if (usedNodes.has(node.name)) {\n        frontier.push(node);\n      }\n    });\n  }\n\n  const seen = new Set();\n  const orderedNodes = [];\n\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n    seen.add(node.name);\n\n    if (!weightMap[node.name]) {\n      orderedNodes.push(node);\n    }\n\n    node.children.forEach(child => {\n      if (!seen.has(child.name) && usedNodes.has(child.name) && child.inputs.every(input => seen.has(input.name))) {\n        frontier.push(child);\n      }\n    });\n  }\n\n  return orderedNodes;\n}\nconst CONTROL_FLOW_OPS = ['Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf', 'StatelessWhile', 'if', 'While'];\nconst DYNAMIC_SHAPE_OPS = ['NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'];\nconst HASH_TABLE_OPS = ['HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2', 'LookupTableFind', 'LookupTableFindV2', 'LookupTableSize', 'LookupTableSizeV2'];\nexport function isControlFlow(node) {\n  return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;\n}\nexport function isDynamicShape(node) {\n  return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;\n}\nexport function isHashTable(node) {\n  return HASH_TABLE_OPS.indexOf(node.op) >= 0;\n}","map":{"version":3,"sources":["/Users/ryanliang/Downloads/main_movir_picker/node_modules/@tensorflow/tfjs-converter/dist/executor/model_analysis.js"],"names":["parseNodeName","getExecutionSubgraph","inputs","outputs","weightMap","initNodes","usedNodes","Set","missingInputs","dynamicNode","syncInputs","seen","inputNodeNames","Object","keys","map","name","initNodeNames","node","frontier","length","pop","isControlFlow","isDynamicShape","isHashTable","children","child","filter","has","add","indexOf","push","forEach","input","getNodesInTopologicalOrder","graph","executionInfo","inputNodes","nodes","weights","weight","orderedNodes","every","CONTROL_FLOW_OPS","DYNAMIC_SHAPE_OPS","HASH_TABLE_OPS","op"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { parseNodeName } from '../operations/executors/utils';\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\nexport function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {\n    const usedNodes = new Set();\n    const missingInputs = [];\n    let dynamicNode = null;\n    let syncInputs = null;\n    // Start with the outputs, going backwards and find all the nodes that are\n    // needed to compute those outputs.\n    const seen = new Set();\n    const inputNodeNames = Object.keys(inputs).map(name => parseNodeName(name)[0]);\n    let initNodeNames = [];\n    if (initNodes != null) {\n        initNodeNames = initNodes.map(node => parseNodeName(node.name)[0]);\n    }\n    const frontier = [...outputs];\n    while (frontier.length > 0) {\n        const node = frontier.pop();\n        if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n            if (dynamicNode == null) {\n                dynamicNode = node;\n                syncInputs = dynamicNode.children.map(child => child.name)\n                    .filter(name => usedNodes.has(name));\n            }\n        }\n        usedNodes.add(node.name);\n        // Weights are dead end since we already have their values.\n        if (weightMap[node.name] != null) {\n            continue;\n        }\n        // This node is a dead end since it's one of the user-provided inputs.\n        if (inputNodeNames.indexOf(node.name) !== -1) {\n            continue;\n        }\n        // This node is a dead end since it doesn't have any inputs.\n        if (initNodeNames.indexOf(node.name) !== -1) {\n            continue;\n        }\n        if (node.inputs.length === 0) {\n            missingInputs.push(node.name);\n            continue;\n        }\n        node.inputs.forEach(input => {\n            // Don't add to the frontier if it is already there.\n            if (seen.has(input.name)) {\n                return;\n            }\n            seen.add(input.name);\n            frontier.push(input);\n        });\n    }\n    return { inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs };\n}\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\nexport function getNodesInTopologicalOrder(graph, weightMap, executionInfo) {\n    const { usedNodes, inputs } = executionInfo;\n    const frontier = [];\n    const inputNodes = Object.keys(inputs)\n        .map(name => parseNodeName(name)[0])\n        .map(name => graph.nodes[name]);\n    const initNodes = graph.initNodes;\n    inputNodes.forEach(input => {\n        if (usedNodes.has(input.name)) {\n            frontier.push(input);\n        }\n    });\n    graph.weights.forEach(weight => {\n        if (usedNodes.has(weight.name)) {\n            frontier.push(weight);\n        }\n    });\n    if (initNodes != null) {\n        initNodes.forEach(node => {\n            if (usedNodes.has(node.name)) {\n                frontier.push(node);\n            }\n        });\n    }\n    const seen = new Set();\n    const orderedNodes = [];\n    while (frontier.length > 0) {\n        const node = frontier.pop();\n        seen.add(node.name);\n        if (!weightMap[node.name]) {\n            orderedNodes.push(node);\n        }\n        node.children.forEach(child => {\n            if (!seen.has(child.name) && usedNodes.has(child.name) &&\n                child.inputs.every(input => seen.has(input.name))) {\n                frontier.push(child);\n            }\n        });\n    }\n    return orderedNodes;\n}\nconst CONTROL_FLOW_OPS = [\n    'Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf',\n    'StatelessWhile', 'if', 'While'\n];\nconst DYNAMIC_SHAPE_OPS = [\n    'NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'\n];\nconst HASH_TABLE_OPS = [\n    'HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2',\n    'LookupTableFind', 'LookupTableFindV2', 'LookupTableSize', 'LookupTableSizeV2'\n];\nexport function isControlFlow(node) {\n    return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;\n}\nexport function isDynamicShape(node) {\n    return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;\n}\nexport function isHashTable(node) {\n    return HASH_TABLE_OPS.indexOf(node.op) >= 0;\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _asyncToGenerator from \"/Users/ryanliang/Downloads/main_movir_picker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { env, tensor, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of tensors from microphone audio stream. The tensors are\n * representing audio data as frequency-domain spectrogram generated with\n * browser's native FFT. Tensors representing time-domain waveform is available\n * based on configuration. Only works in browser environment.\n */\n\nexport class MicrophoneIterator extends LazyIterator {\n  constructor(microphoneConfig) {\n    super();\n    this.microphoneConfig = microphoneConfig;\n    this.isClosed = false;\n    this.fftSize = microphoneConfig.fftSize || 1024;\n    const fftSizeLog2 = Math.log2(this.fftSize);\n\n    if (this.fftSize < 0 || fftSizeLog2 < 4 || fftSizeLog2 > 14 || !Number.isInteger(fftSizeLog2)) {\n      throw new Error(`Invalid fftSize: it must be a power of 2 between ` + `2 to 4 and 2 to 14, but got ${this.fftSize}`);\n    }\n\n    this.numFrames = microphoneConfig.numFramesPerSpectrogram || 43;\n    this.sampleRateHz = microphoneConfig.sampleRateHz;\n    this.columnTruncateLength = microphoneConfig.columnTruncateLength || this.fftSize;\n    this.audioTrackConstraints = microphoneConfig.audioTrackConstraints;\n    this.smoothingTimeConstant = microphoneConfig.smoothingTimeConstant || 0;\n    this.includeSpectrogram = microphoneConfig.includeSpectrogram === false ? false : true;\n    this.includeWaveform = microphoneConfig.includeWaveform === true ? true : false;\n\n    if (!this.includeSpectrogram && !this.includeWaveform) {\n      throw new Error('Both includeSpectrogram and includeWaveform are false. ' + 'At least one type of data should be returned.');\n    }\n  }\n\n  summary() {\n    return `microphone`;\n  } // Construct a MicrophoneIterator and start the audio stream.\n\n\n  static create(microphoneConfig = {}) {\n    return _asyncToGenerator(function* () {\n      if (env().get('IS_NODE')) {\n        throw new Error('microphone API is only supported in browser environment.');\n      }\n\n      const microphoneIterator = new MicrophoneIterator(microphoneConfig); // Call async function start() to initialize the audio stream.\n\n      yield microphoneIterator.start();\n      return microphoneIterator;\n    })();\n  } // Start the audio stream and FFT.\n\n\n  start() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        _this.stream = yield navigator.mediaDevices.getUserMedia({\n          audio: _this.audioTrackConstraints == null ? true : _this.audioTrackConstraints,\n          video: false\n        });\n      } catch (e) {\n        throw new Error(`Error thrown while initializing video stream: ${e.message}`);\n      }\n\n      if (!_this.stream) {\n        throw new Error('Could not obtain audio from microphone.');\n      }\n\n      const ctxConstructor = // tslint:disable-next-line:no-any\n      window.AudioContext || window.webkitAudioContext;\n      _this.audioContext = new ctxConstructor();\n\n      if (!_this.sampleRateHz) {\n        // If sample rate is not provided, use the available sample rate on\n        // device.\n        _this.sampleRateHz = _this.audioContext.sampleRate;\n      } else if (_this.audioContext.sampleRate !== _this.sampleRateHz) {\n        throw new Error(`Mismatch in sampling rate: ` + `Expected: ${_this.sampleRateHz}; ` + `Actual: ${_this.audioContext.sampleRate}`);\n      }\n\n      const streamSource = _this.audioContext.createMediaStreamSource(_this.stream);\n\n      _this.analyser = _this.audioContext.createAnalyser();\n      _this.analyser.fftSize = _this.fftSize * 2;\n      _this.analyser.smoothingTimeConstant = _this.smoothingTimeConstant;\n      streamSource.connect(_this.analyser);\n      _this.freqData = new Float32Array(_this.fftSize);\n      _this.timeData = new Float32Array(_this.fftSize);\n      return;\n    })();\n  }\n\n  next() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2.isClosed) {\n        return {\n          value: null,\n          done: true\n        };\n      }\n\n      let spectrogramTensor;\n      let waveformTensor;\n      const audioDataQueue = yield _this2.getAudioData();\n\n      if (_this2.includeSpectrogram) {\n        const freqData = _this2.flattenQueue(audioDataQueue.freqDataQueue);\n\n        spectrogramTensor = _this2.getTensorFromAudioDataArray(freqData, [_this2.numFrames, _this2.columnTruncateLength, 1]);\n      }\n\n      if (_this2.includeWaveform) {\n        const timeData = _this2.flattenQueue(audioDataQueue.timeDataQueue);\n\n        waveformTensor = _this2.getTensorFromAudioDataArray(timeData, [_this2.numFrames * _this2.fftSize, 1]);\n      }\n\n      return {\n        value: {\n          'spectrogram': spectrogramTensor,\n          'waveform': waveformTensor\n        },\n        done: false\n      };\n    })();\n  } // Capture one result from the audio stream, and extract the value from\n  // iterator.next() result.\n\n\n  capture() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this3.next()).value;\n    })();\n  }\n\n  getAudioData() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const freqDataQueue = [];\n      const timeDataQueue = [];\n      let currentFrames = 0;\n      return new Promise(resolve => {\n        const intervalID = setInterval(() => {\n          if (_this4.includeSpectrogram) {\n            _this4.analyser.getFloatFrequencyData(_this4.freqData); // If the audio stream is initializing, return empty queue.\n\n\n            if (_this4.freqData[0] === -Infinity) {\n              resolve({\n                freqDataQueue,\n                timeDataQueue\n              });\n            }\n\n            freqDataQueue.push(_this4.freqData.slice(0, _this4.columnTruncateLength));\n          }\n\n          if (_this4.includeWaveform) {\n            _this4.analyser.getFloatTimeDomainData(_this4.timeData);\n\n            timeDataQueue.push(_this4.timeData.slice());\n          } // Clean interval and return when all frames have been collected\n\n\n          if (++currentFrames === _this4.numFrames) {\n            clearInterval(intervalID);\n            resolve({\n              freqDataQueue,\n              timeDataQueue\n            });\n          }\n        }, _this4.fftSize / _this4.sampleRateHz * 1e3);\n      });\n    })();\n  } // Stop the audio stream and pause the iterator.\n\n\n  stop() {\n    if (!this.isClosed) {\n      this.isClosed = true;\n      this.analyser.disconnect();\n      this.audioContext.close();\n\n      if (this.stream != null && this.stream.getTracks().length > 0) {\n        this.stream.getTracks()[0].stop();\n      }\n    }\n  } // Override toArray() function to prevent collecting.\n\n\n  toArray() {\n    throw new Error('Can not convert infinite audio stream to array.');\n  } // Return audio sampling rate in Hz\n\n\n  getSampleRate() {\n    return this.sampleRateHz;\n  }\n\n  flattenQueue(queue) {\n    const frameSize = queue[0].length;\n    const freqData = new Float32Array(queue.length * frameSize);\n    queue.forEach((data, i) => freqData.set(data, i * frameSize));\n    return freqData;\n  }\n\n  getTensorFromAudioDataArray(freqData, shape) {\n    const vals = new Float32Array(util.sizeFromShape(shape)); // If the data is less than the output shape, the rest is padded with zeros.\n\n    vals.set(freqData, vals.length - freqData.length);\n    return tensor(vals, shape);\n  }\n\n}","map":{"version":3,"sources":["/Users/ryanliang/Downloads/main_movir_picker/node_modules/@tensorflow/tfjs-data/dist/iterators/microphone_iterator.js"],"names":["env","tensor","util","LazyIterator","MicrophoneIterator","constructor","microphoneConfig","isClosed","fftSize","fftSizeLog2","Math","log2","Number","isInteger","Error","numFrames","numFramesPerSpectrogram","sampleRateHz","columnTruncateLength","audioTrackConstraints","smoothingTimeConstant","includeSpectrogram","includeWaveform","summary","create","get","microphoneIterator","start","stream","navigator","mediaDevices","getUserMedia","audio","video","e","message","ctxConstructor","window","AudioContext","webkitAudioContext","audioContext","sampleRate","streamSource","createMediaStreamSource","analyser","createAnalyser","connect","freqData","Float32Array","timeData","next","value","done","spectrogramTensor","waveformTensor","audioDataQueue","getAudioData","flattenQueue","freqDataQueue","getTensorFromAudioDataArray","timeDataQueue","capture","currentFrames","Promise","resolve","intervalID","setInterval","getFloatFrequencyData","Infinity","push","slice","getFloatTimeDomainData","clearInterval","stop","disconnect","close","getTracks","length","toArray","getSampleRate","queue","frameSize","forEach","data","i","set","shape","vals","sizeFromShape"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,GAAT,EAAcC,MAAd,EAAsBC,IAAtB,QAAkC,uBAAlC;AACA,SAASC,YAAT,QAA6B,iBAA7B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,kBAAN,SAAiCD,YAAjC,CAA8C;AACjDE,EAAAA,WAAW,CAACC,gBAAD,EAAmB;AAC1B;AACA,SAAKA,gBAAL,GAAwBA,gBAAxB;AACA,SAAKC,QAAL,GAAgB,KAAhB;AACA,SAAKC,OAAL,GAAeF,gBAAgB,CAACE,OAAjB,IAA4B,IAA3C;AACA,UAAMC,WAAW,GAAGC,IAAI,CAACC,IAAL,CAAU,KAAKH,OAAf,CAApB;;AACA,QAAI,KAAKA,OAAL,GAAe,CAAf,IAAoBC,WAAW,GAAG,CAAlC,IAAuCA,WAAW,GAAG,EAArD,IACA,CAACG,MAAM,CAACC,SAAP,CAAiBJ,WAAjB,CADL,EACoC;AAChC,YAAM,IAAIK,KAAJ,CAAW,mDAAD,GACX,+BAA8B,KAAKN,OAAQ,EAD1C,CAAN;AAEH;;AACD,SAAKO,SAAL,GAAiBT,gBAAgB,CAACU,uBAAjB,IAA4C,EAA7D;AACA,SAAKC,YAAL,GAAoBX,gBAAgB,CAACW,YAArC;AACA,SAAKC,oBAAL,GACIZ,gBAAgB,CAACY,oBAAjB,IAAyC,KAAKV,OADlD;AAEA,SAAKW,qBAAL,GAA6Bb,gBAAgB,CAACa,qBAA9C;AACA,SAAKC,qBAAL,GAA6Bd,gBAAgB,CAACc,qBAAjB,IAA0C,CAAvE;AACA,SAAKC,kBAAL,GACIf,gBAAgB,CAACe,kBAAjB,KAAwC,KAAxC,GAAgD,KAAhD,GAAwD,IAD5D;AAEA,SAAKC,eAAL,GACIhB,gBAAgB,CAACgB,eAAjB,KAAqC,IAArC,GAA4C,IAA5C,GAAmD,KADvD;;AAEA,QAAI,CAAC,KAAKD,kBAAN,IAA4B,CAAC,KAAKC,eAAtC,EAAuD;AACnD,YAAM,IAAIR,KAAJ,CAAU,4DACZ,+CADE,CAAN;AAEH;AACJ;;AACDS,EAAAA,OAAO,GAAG;AACN,WAAQ,YAAR;AACH,GA7BgD,CA8BjD;;;AACmB,SAANC,MAAM,CAAClB,gBAAgB,GAAG,EAApB,EAAwB;AAAA;AACvC,UAAIN,GAAG,GAAGyB,GAAN,CAAU,SAAV,CAAJ,EAA0B;AACtB,cAAM,IAAIX,KAAJ,CAAU,0DAAV,CAAN;AACH;;AACD,YAAMY,kBAAkB,GAAG,IAAItB,kBAAJ,CAAuBE,gBAAvB,CAA3B,CAJuC,CAKvC;;AACA,YAAMoB,kBAAkB,CAACC,KAAnB,EAAN;AACA,aAAOD,kBAAP;AAPuC;AAQ1C,GAvCgD,CAwCjD;;;AACMC,EAAAA,KAAK,GAAG;AAAA;;AAAA;AACV,UAAI;AACA,QAAA,KAAI,CAACC,MAAL,SAAoBC,SAAS,CAACC,YAAV,CAAuBC,YAAvB,CAAoC;AACpDC,UAAAA,KAAK,EAAE,KAAI,CAACb,qBAAL,IAA8B,IAA9B,GAAqC,IAArC,GACH,KAAI,CAACA,qBAF2C;AAGpDc,UAAAA,KAAK,EAAE;AAH6C,SAApC,CAApB;AAKH,OAND,CAOA,OAAOC,CAAP,EAAU;AACN,cAAM,IAAIpB,KAAJ,CAAW,iDAAgDoB,CAAC,CAACC,OAAQ,EAArE,CAAN;AACH;;AACD,UAAI,CAAC,KAAI,CAACP,MAAV,EAAkB;AACd,cAAM,IAAId,KAAJ,CAAU,yCAAV,CAAN;AACH;;AACD,YAAMsB,cAAc,GACpB;AACAC,MAAAA,MAAM,CAACC,YAAP,IAAuBD,MAAM,CAACE,kBAF9B;AAGA,MAAA,KAAI,CAACC,YAAL,GAAoB,IAAIJ,cAAJ,EAApB;;AACA,UAAI,CAAC,KAAI,CAACnB,YAAV,EAAwB;AACpB;AACA;AACA,QAAA,KAAI,CAACA,YAAL,GAAoB,KAAI,CAACuB,YAAL,CAAkBC,UAAtC;AACH,OAJD,MAKK,IAAI,KAAI,CAACD,YAAL,CAAkBC,UAAlB,KAAiC,KAAI,CAACxB,YAA1C,EAAwD;AACzD,cAAM,IAAIH,KAAJ,CAAW,6BAAD,GACX,aAAY,KAAI,CAACG,YAAa,IADnB,GAEX,WAAU,KAAI,CAACuB,YAAL,CAAkBC,UAAW,EAFtC,CAAN;AAGH;;AACD,YAAMC,YAAY,GAAG,KAAI,CAACF,YAAL,CAAkBG,uBAAlB,CAA0C,KAAI,CAACf,MAA/C,CAArB;;AACA,MAAA,KAAI,CAACgB,QAAL,GAAgB,KAAI,CAACJ,YAAL,CAAkBK,cAAlB,EAAhB;AACA,MAAA,KAAI,CAACD,QAAL,CAAcpC,OAAd,GAAwB,KAAI,CAACA,OAAL,GAAe,CAAvC;AACA,MAAA,KAAI,CAACoC,QAAL,CAAcxB,qBAAd,GAAsC,KAAI,CAACA,qBAA3C;AACAsB,MAAAA,YAAY,CAACI,OAAb,CAAqB,KAAI,CAACF,QAA1B;AACA,MAAA,KAAI,CAACG,QAAL,GAAgB,IAAIC,YAAJ,CAAiB,KAAI,CAACxC,OAAtB,CAAhB;AACA,MAAA,KAAI,CAACyC,QAAL,GAAgB,IAAID,YAAJ,CAAiB,KAAI,CAACxC,OAAtB,CAAhB;AACA;AAnCU;AAoCb;;AACK0C,EAAAA,IAAI,GAAG;AAAA;;AAAA;AACT,UAAI,MAAI,CAAC3C,QAAT,EAAmB;AACf,eAAO;AAAE4C,UAAAA,KAAK,EAAE,IAAT;AAAeC,UAAAA,IAAI,EAAE;AAArB,SAAP;AACH;;AACD,UAAIC,iBAAJ;AACA,UAAIC,cAAJ;AACA,YAAMC,cAAc,SAAS,MAAI,CAACC,YAAL,EAA7B;;AACA,UAAI,MAAI,CAACnC,kBAAT,EAA6B;AACzB,cAAM0B,QAAQ,GAAG,MAAI,CAACU,YAAL,CAAkBF,cAAc,CAACG,aAAjC,CAAjB;;AACAL,QAAAA,iBAAiB,GAAG,MAAI,CAACM,2BAAL,CAAiCZ,QAAjC,EAA2C,CAAC,MAAI,CAAChC,SAAN,EAAiB,MAAI,CAACG,oBAAtB,EAA4C,CAA5C,CAA3C,CAApB;AACH;;AACD,UAAI,MAAI,CAACI,eAAT,EAA0B;AACtB,cAAM2B,QAAQ,GAAG,MAAI,CAACQ,YAAL,CAAkBF,cAAc,CAACK,aAAjC,CAAjB;;AACAN,QAAAA,cAAc,GAAG,MAAI,CAACK,2BAAL,CAAiCV,QAAjC,EAA2C,CAAC,MAAI,CAAClC,SAAL,GAAiB,MAAI,CAACP,OAAvB,EAAgC,CAAhC,CAA3C,CAAjB;AACH;;AACD,aAAO;AACH2C,QAAAA,KAAK,EAAE;AAAE,yBAAeE,iBAAjB;AAAoC,sBAAYC;AAAhD,SADJ;AAEHF,QAAAA,IAAI,EAAE;AAFH,OAAP;AAfS;AAmBZ,GAjGgD,CAkGjD;AACA;;;AACMS,EAAAA,OAAO,GAAG;AAAA;;AAAA;AACZ,aAAO,OAAO,MAAI,CAACX,IAAL,EAAP,EAAoBC,KAA3B;AADY;AAEf;;AACKK,EAAAA,YAAY,GAAG;AAAA;;AAAA;AACjB,YAAME,aAAa,GAAG,EAAtB;AACA,YAAME,aAAa,GAAG,EAAtB;AACA,UAAIE,aAAa,GAAG,CAApB;AACA,aAAO,IAAIC,OAAJ,CAAYC,OAAO,IAAI;AAC1B,cAAMC,UAAU,GAAGC,WAAW,CAAC,MAAM;AACjC,cAAI,MAAI,CAAC7C,kBAAT,EAA6B;AACzB,YAAA,MAAI,CAACuB,QAAL,CAAcuB,qBAAd,CAAoC,MAAI,CAACpB,QAAzC,EADyB,CAEzB;;;AACA,gBAAI,MAAI,CAACA,QAAL,CAAc,CAAd,MAAqB,CAACqB,QAA1B,EAAoC;AAChCJ,cAAAA,OAAO,CAAC;AAAEN,gBAAAA,aAAF;AAAiBE,gBAAAA;AAAjB,eAAD,CAAP;AACH;;AACDF,YAAAA,aAAa,CAACW,IAAd,CAAmB,MAAI,CAACtB,QAAL,CAAcuB,KAAd,CAAoB,CAApB,EAAuB,MAAI,CAACpD,oBAA5B,CAAnB;AACH;;AACD,cAAI,MAAI,CAACI,eAAT,EAA0B;AACtB,YAAA,MAAI,CAACsB,QAAL,CAAc2B,sBAAd,CAAqC,MAAI,CAACtB,QAA1C;;AACAW,YAAAA,aAAa,CAACS,IAAd,CAAmB,MAAI,CAACpB,QAAL,CAAcqB,KAAd,EAAnB;AACH,WAZgC,CAajC;;;AACA,cAAI,EAAER,aAAF,KAAoB,MAAI,CAAC/C,SAA7B,EAAwC;AACpCyD,YAAAA,aAAa,CAACP,UAAD,CAAb;AACAD,YAAAA,OAAO,CAAC;AAAEN,cAAAA,aAAF;AAAiBE,cAAAA;AAAjB,aAAD,CAAP;AACH;AACJ,SAlB6B,EAkB3B,MAAI,CAACpD,OAAL,GAAe,MAAI,CAACS,YAApB,GAAmC,GAlBR,CAA9B;AAmBH,OApBM,CAAP;AAJiB;AAyBpB,GAhIgD,CAiIjD;;;AACAwD,EAAAA,IAAI,GAAG;AACH,QAAI,CAAC,KAAKlE,QAAV,EAAoB;AAChB,WAAKA,QAAL,GAAgB,IAAhB;AACA,WAAKqC,QAAL,CAAc8B,UAAd;AACA,WAAKlC,YAAL,CAAkBmC,KAAlB;;AACA,UAAI,KAAK/C,MAAL,IAAe,IAAf,IAAuB,KAAKA,MAAL,CAAYgD,SAAZ,GAAwBC,MAAxB,GAAiC,CAA5D,EAA+D;AAC3D,aAAKjD,MAAL,CAAYgD,SAAZ,GAAwB,CAAxB,EAA2BH,IAA3B;AACH;AACJ;AACJ,GA3IgD,CA4IjD;;;AACAK,EAAAA,OAAO,GAAG;AACN,UAAM,IAAIhE,KAAJ,CAAU,iDAAV,CAAN;AACH,GA/IgD,CAgJjD;;;AACAiE,EAAAA,aAAa,GAAG;AACZ,WAAO,KAAK9D,YAAZ;AACH;;AACDwC,EAAAA,YAAY,CAACuB,KAAD,EAAQ;AAChB,UAAMC,SAAS,GAAGD,KAAK,CAAC,CAAD,CAAL,CAASH,MAA3B;AACA,UAAM9B,QAAQ,GAAG,IAAIC,YAAJ,CAAiBgC,KAAK,CAACH,MAAN,GAAeI,SAAhC,CAAjB;AACAD,IAAAA,KAAK,CAACE,OAAN,CAAc,CAACC,IAAD,EAAOC,CAAP,KAAarC,QAAQ,CAACsC,GAAT,CAAaF,IAAb,EAAmBC,CAAC,GAAGH,SAAvB,CAA3B;AACA,WAAOlC,QAAP;AACH;;AACDY,EAAAA,2BAA2B,CAACZ,QAAD,EAAWuC,KAAX,EAAkB;AACzC,UAAMC,IAAI,GAAG,IAAIvC,YAAJ,CAAiB9C,IAAI,CAACsF,aAAL,CAAmBF,KAAnB,CAAjB,CAAb,CADyC,CAEzC;;AACAC,IAAAA,IAAI,CAACF,GAAL,CAAStC,QAAT,EAAmBwC,IAAI,CAACV,MAAL,GAAc9B,QAAQ,CAAC8B,MAA1C;AACA,WAAO5E,MAAM,CAACsF,IAAD,EAAOD,KAAP,CAAb;AACH;;AA/JgD","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { env, tensor, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of tensors from microphone audio stream. The tensors are\n * representing audio data as frequency-domain spectrogram generated with\n * browser's native FFT. Tensors representing time-domain waveform is available\n * based on configuration. Only works in browser environment.\n */\nexport class MicrophoneIterator extends LazyIterator {\n    constructor(microphoneConfig) {\n        super();\n        this.microphoneConfig = microphoneConfig;\n        this.isClosed = false;\n        this.fftSize = microphoneConfig.fftSize || 1024;\n        const fftSizeLog2 = Math.log2(this.fftSize);\n        if (this.fftSize < 0 || fftSizeLog2 < 4 || fftSizeLog2 > 14 ||\n            !Number.isInteger(fftSizeLog2)) {\n            throw new Error(`Invalid fftSize: it must be a power of 2 between ` +\n                `2 to 4 and 2 to 14, but got ${this.fftSize}`);\n        }\n        this.numFrames = microphoneConfig.numFramesPerSpectrogram || 43;\n        this.sampleRateHz = microphoneConfig.sampleRateHz;\n        this.columnTruncateLength =\n            microphoneConfig.columnTruncateLength || this.fftSize;\n        this.audioTrackConstraints = microphoneConfig.audioTrackConstraints;\n        this.smoothingTimeConstant = microphoneConfig.smoothingTimeConstant || 0;\n        this.includeSpectrogram =\n            microphoneConfig.includeSpectrogram === false ? false : true;\n        this.includeWaveform =\n            microphoneConfig.includeWaveform === true ? true : false;\n        if (!this.includeSpectrogram && !this.includeWaveform) {\n            throw new Error('Both includeSpectrogram and includeWaveform are false. ' +\n                'At least one type of data should be returned.');\n        }\n    }\n    summary() {\n        return `microphone`;\n    }\n    // Construct a MicrophoneIterator and start the audio stream.\n    static async create(microphoneConfig = {}) {\n        if (env().get('IS_NODE')) {\n            throw new Error('microphone API is only supported in browser environment.');\n        }\n        const microphoneIterator = new MicrophoneIterator(microphoneConfig);\n        // Call async function start() to initialize the audio stream.\n        await microphoneIterator.start();\n        return microphoneIterator;\n    }\n    // Start the audio stream and FFT.\n    async start() {\n        try {\n            this.stream = await navigator.mediaDevices.getUserMedia({\n                audio: this.audioTrackConstraints == null ? true :\n                    this.audioTrackConstraints,\n                video: false\n            });\n        }\n        catch (e) {\n            throw new Error(`Error thrown while initializing video stream: ${e.message}`);\n        }\n        if (!this.stream) {\n            throw new Error('Could not obtain audio from microphone.');\n        }\n        const ctxConstructor = \n        // tslint:disable-next-line:no-any\n        window.AudioContext || window.webkitAudioContext;\n        this.audioContext = new ctxConstructor();\n        if (!this.sampleRateHz) {\n            // If sample rate is not provided, use the available sample rate on\n            // device.\n            this.sampleRateHz = this.audioContext.sampleRate;\n        }\n        else if (this.audioContext.sampleRate !== this.sampleRateHz) {\n            throw new Error(`Mismatch in sampling rate: ` +\n                `Expected: ${this.sampleRateHz}; ` +\n                `Actual: ${this.audioContext.sampleRate}`);\n        }\n        const streamSource = this.audioContext.createMediaStreamSource(this.stream);\n        this.analyser = this.audioContext.createAnalyser();\n        this.analyser.fftSize = this.fftSize * 2;\n        this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;\n        streamSource.connect(this.analyser);\n        this.freqData = new Float32Array(this.fftSize);\n        this.timeData = new Float32Array(this.fftSize);\n        return;\n    }\n    async next() {\n        if (this.isClosed) {\n            return { value: null, done: true };\n        }\n        let spectrogramTensor;\n        let waveformTensor;\n        const audioDataQueue = await this.getAudioData();\n        if (this.includeSpectrogram) {\n            const freqData = this.flattenQueue(audioDataQueue.freqDataQueue);\n            spectrogramTensor = this.getTensorFromAudioDataArray(freqData, [this.numFrames, this.columnTruncateLength, 1]);\n        }\n        if (this.includeWaveform) {\n            const timeData = this.flattenQueue(audioDataQueue.timeDataQueue);\n            waveformTensor = this.getTensorFromAudioDataArray(timeData, [this.numFrames * this.fftSize, 1]);\n        }\n        return {\n            value: { 'spectrogram': spectrogramTensor, 'waveform': waveformTensor },\n            done: false\n        };\n    }\n    // Capture one result from the audio stream, and extract the value from\n    // iterator.next() result.\n    async capture() {\n        return (await this.next()).value;\n    }\n    async getAudioData() {\n        const freqDataQueue = [];\n        const timeDataQueue = [];\n        let currentFrames = 0;\n        return new Promise(resolve => {\n            const intervalID = setInterval(() => {\n                if (this.includeSpectrogram) {\n                    this.analyser.getFloatFrequencyData(this.freqData);\n                    // If the audio stream is initializing, return empty queue.\n                    if (this.freqData[0] === -Infinity) {\n                        resolve({ freqDataQueue, timeDataQueue });\n                    }\n                    freqDataQueue.push(this.freqData.slice(0, this.columnTruncateLength));\n                }\n                if (this.includeWaveform) {\n                    this.analyser.getFloatTimeDomainData(this.timeData);\n                    timeDataQueue.push(this.timeData.slice());\n                }\n                // Clean interval and return when all frames have been collected\n                if (++currentFrames === this.numFrames) {\n                    clearInterval(intervalID);\n                    resolve({ freqDataQueue, timeDataQueue });\n                }\n            }, this.fftSize / this.sampleRateHz * 1e3);\n        });\n    }\n    // Stop the audio stream and pause the iterator.\n    stop() {\n        if (!this.isClosed) {\n            this.isClosed = true;\n            this.analyser.disconnect();\n            this.audioContext.close();\n            if (this.stream != null && this.stream.getTracks().length > 0) {\n                this.stream.getTracks()[0].stop();\n            }\n        }\n    }\n    // Override toArray() function to prevent collecting.\n    toArray() {\n        throw new Error('Can not convert infinite audio stream to array.');\n    }\n    // Return audio sampling rate in Hz\n    getSampleRate() {\n        return this.sampleRateHz;\n    }\n    flattenQueue(queue) {\n        const frameSize = queue[0].length;\n        const freqData = new Float32Array(queue.length * frameSize);\n        queue.forEach((data, i) => freqData.set(data, i * frameSize));\n        return freqData;\n    }\n    getTensorFromAudioDataArray(freqData, shape) {\n        const vals = new Float32Array(util.sizeFromShape(shape));\n        // If the data is less than the output shape, the rest is padded with zeros.\n        vals.set(freqData, vals.length - freqData.length);\n        return tensor(vals, shape);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _asyncToGenerator from \"/Users/ryanliang/Downloads/main_movir_picker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { dispose, tidy } from '../globals';\nimport { abs } from '../ops/abs';\nimport { add } from '../ops/add';\nimport { div } from '../ops/div';\nimport { maximum } from '../ops/maximum';\nimport { mul } from '../ops/mul';\nimport { scalar } from '../ops/scalar';\nimport { sub } from '../ops/sub';\nimport { zerosLike } from '../ops/zeros_like';\nimport { registerClass } from '../serialization';\nimport { Optimizer } from './optimizer';\nexport class AdamaxOptimizer extends Optimizer {\n  constructor(learningRate, beta1, beta2, epsilon = null, decay = 0.0) {\n    super();\n    this.learningRate = learningRate;\n    this.beta1 = beta1;\n    this.beta2 = beta2;\n    this.epsilon = epsilon;\n    this.decay = decay;\n    this.accumulatedFirstMoment = [];\n    this.accumulatedWeightedInfNorm = [];\n    tidy(() => {\n      this.iteration = scalar(0).variable();\n      this.accBeta1 = scalar(beta1).variable();\n    });\n\n    if (epsilon == null) {\n      this.epsilon = ENGINE.backend.epsilon();\n    }\n  }\n\n  applyGradients(variableGradients) {\n    const variableNames = Array.isArray(variableGradients) ? variableGradients.map(item => item.name) : Object.keys(variableGradients);\n    tidy(() => {\n      const oneMinusAccBeta1 = sub(1, this.accBeta1);\n      const lr = div(-this.learningRate, add(mul(this.iteration, this.decay), 1));\n      variableNames.forEach((name, i) => {\n        const value = ENGINE.registeredVariables[name];\n        const trainable = false;\n\n        if (this.accumulatedFirstMoment[i] == null) {\n          this.accumulatedFirstMoment[i] = {\n            originalName: `${name}/m`,\n            variable: zerosLike(value).variable(trainable)\n          };\n        }\n\n        if (this.accumulatedWeightedInfNorm[i] == null) {\n          this.accumulatedWeightedInfNorm[i] = {\n            originalName: `${name}/v`,\n            variable: zerosLike(value).variable(trainable)\n          };\n        }\n\n        const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];\n\n        if (gradient == null) {\n          return;\n        }\n\n        const firstMoment = this.accumulatedFirstMoment[i].variable;\n        const weightedInfNorm = this.accumulatedWeightedInfNorm[i].variable;\n        const newFirstMoment = add(mul(firstMoment, this.beta1), mul(gradient, 1 - this.beta1));\n        const ut0 = mul(weightedInfNorm, this.beta2);\n        const ut1 = abs(gradient);\n        const newWeightedInfNorm = maximum(ut0, ut1);\n        firstMoment.assign(newFirstMoment);\n        weightedInfNorm.assign(newWeightedInfNorm);\n        const newValue = add(mul(div(lr, oneMinusAccBeta1), div(newFirstMoment, add(newWeightedInfNorm, this.epsilon))), value);\n        value.assign(newValue);\n      });\n      this.iteration.assign(add(this.iteration, 1));\n      this.accBeta1.assign(mul(this.accBeta1, this.beta1));\n    });\n    this.incrementIterations();\n  }\n\n  dispose() {\n    this.accBeta1.dispose();\n    this.iteration.dispose();\n\n    if (this.accumulatedFirstMoment != null) {\n      dispose(this.accumulatedFirstMoment.map(v => v.variable));\n    }\n\n    if (this.accumulatedWeightedInfNorm != null) {\n      dispose(this.accumulatedWeightedInfNorm.map(v => v.variable));\n    }\n  }\n\n  getWeights() {\n    return _asyncToGenerator(function* () {\n      throw new Error('getWeights() is not implemented for Adamax yet.');\n    })();\n  }\n\n  setWeights(weightValues) {\n    return _asyncToGenerator(function* () {\n      throw new Error('setWeights() is not implemented for Adamax yet.');\n    })();\n  }\n\n  getConfig() {\n    return {\n      'learningRate': this.learningRate,\n      'beta1': this.beta1,\n      'beta2': this.beta2,\n      'epsilon': this.epsilon,\n      'decay': this.decay\n    };\n  }\n  /** @nocollapse */\n\n\n  static fromConfig(cls, config) {\n    return new cls(config['learningRate'], config['beta1'], config['beta2'], config['epsilon'], config['decay']);\n  }\n\n}\n/** @nocollapse */\n\nAdamaxOptimizer.className = 'Adamax'; // Note: Name matters for Python compatbility.\n\nregisterClass(AdamaxOptimizer);","map":{"version":3,"sources":["/Users/ryanliang/Downloads/main_movir_picker/node_modules/@tensorflow/tfjs-core/dist/optimizers/adamax_optimizer.js"],"names":["ENGINE","dispose","tidy","abs","add","div","maximum","mul","scalar","sub","zerosLike","registerClass","Optimizer","AdamaxOptimizer","constructor","learningRate","beta1","beta2","epsilon","decay","accumulatedFirstMoment","accumulatedWeightedInfNorm","iteration","variable","accBeta1","backend","applyGradients","variableGradients","variableNames","Array","isArray","map","item","name","Object","keys","oneMinusAccBeta1","lr","forEach","i","value","registeredVariables","trainable","originalName","gradient","tensor","firstMoment","weightedInfNorm","newFirstMoment","ut0","ut1","newWeightedInfNorm","assign","newValue","incrementIterations","v","getWeights","Error","setWeights","weightValues","getConfig","fromConfig","cls","config","className"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { dispose, tidy } from '../globals';\nimport { abs } from '../ops/abs';\nimport { add } from '../ops/add';\nimport { div } from '../ops/div';\nimport { maximum } from '../ops/maximum';\nimport { mul } from '../ops/mul';\nimport { scalar } from '../ops/scalar';\nimport { sub } from '../ops/sub';\nimport { zerosLike } from '../ops/zeros_like';\nimport { registerClass } from '../serialization';\nimport { Optimizer } from './optimizer';\nexport class AdamaxOptimizer extends Optimizer {\n    constructor(learningRate, beta1, beta2, epsilon = null, decay = 0.0) {\n        super();\n        this.learningRate = learningRate;\n        this.beta1 = beta1;\n        this.beta2 = beta2;\n        this.epsilon = epsilon;\n        this.decay = decay;\n        this.accumulatedFirstMoment = [];\n        this.accumulatedWeightedInfNorm = [];\n        tidy(() => {\n            this.iteration = scalar(0).variable();\n            this.accBeta1 = scalar(beta1).variable();\n        });\n        if (epsilon == null) {\n            this.epsilon = ENGINE.backend.epsilon();\n        }\n    }\n    applyGradients(variableGradients) {\n        const variableNames = Array.isArray(variableGradients) ?\n            variableGradients.map(item => item.name) :\n            Object.keys(variableGradients);\n        tidy(() => {\n            const oneMinusAccBeta1 = sub(1, this.accBeta1);\n            const lr = div(-this.learningRate, add(mul(this.iteration, this.decay), 1));\n            variableNames.forEach((name, i) => {\n                const value = ENGINE.registeredVariables[name];\n                const trainable = false;\n                if (this.accumulatedFirstMoment[i] == null) {\n                    this.accumulatedFirstMoment[i] = {\n                        originalName: `${name}/m`,\n                        variable: zerosLike(value).variable(trainable)\n                    };\n                }\n                if (this.accumulatedWeightedInfNorm[i] == null) {\n                    this.accumulatedWeightedInfNorm[i] = {\n                        originalName: `${name}/v`,\n                        variable: zerosLike(value).variable(trainable)\n                    };\n                }\n                const gradient = Array.isArray(variableGradients) ?\n                    variableGradients[i].tensor :\n                    variableGradients[name];\n                if (gradient == null) {\n                    return;\n                }\n                const firstMoment = this.accumulatedFirstMoment[i].variable;\n                const weightedInfNorm = this.accumulatedWeightedInfNorm[i].variable;\n                const newFirstMoment = add(mul(firstMoment, this.beta1), mul(gradient, 1 - this.beta1));\n                const ut0 = mul(weightedInfNorm, this.beta2);\n                const ut1 = abs(gradient);\n                const newWeightedInfNorm = maximum(ut0, ut1);\n                firstMoment.assign(newFirstMoment);\n                weightedInfNorm.assign(newWeightedInfNorm);\n                const newValue = add(mul(div(lr, oneMinusAccBeta1), div(newFirstMoment, add(newWeightedInfNorm, this.epsilon))), value);\n                value.assign(newValue);\n            });\n            this.iteration.assign(add(this.iteration, 1));\n            this.accBeta1.assign(mul(this.accBeta1, this.beta1));\n        });\n        this.incrementIterations();\n    }\n    dispose() {\n        this.accBeta1.dispose();\n        this.iteration.dispose();\n        if (this.accumulatedFirstMoment != null) {\n            dispose(this.accumulatedFirstMoment.map(v => v.variable));\n        }\n        if (this.accumulatedWeightedInfNorm != null) {\n            dispose(this.accumulatedWeightedInfNorm.map(v => v.variable));\n        }\n    }\n    async getWeights() {\n        throw new Error('getWeights() is not implemented for Adamax yet.');\n    }\n    async setWeights(weightValues) {\n        throw new Error('setWeights() is not implemented for Adamax yet.');\n    }\n    getConfig() {\n        return {\n            'learningRate': this.learningRate,\n            'beta1': this.beta1,\n            'beta2': this.beta2,\n            'epsilon': this.epsilon,\n            'decay': this.decay\n        };\n    }\n    /** @nocollapse */\n    static fromConfig(cls, config) {\n        return new cls(config['learningRate'], config['beta1'], config['beta2'], config['epsilon'], config['decay']);\n    }\n}\n/** @nocollapse */\nAdamaxOptimizer.className = 'Adamax'; // Note: Name matters for Python compatbility.\nregisterClass(AdamaxOptimizer);\n"]},"metadata":{},"sourceType":"module"}
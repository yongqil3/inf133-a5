{"ast":null,"code":"import _asyncToGenerator from \"/Users/ryanliang/Downloads/main_movir_picker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/* Original source: keras/callbacks.py */\nimport { add, div, keep, mul, nextFrame, tidy, util } from '@tensorflow/tfjs-core';\nimport { ValueError } from './errors';\nimport { resolveScalarsInLogs } from './logs';\nimport * as generic_utils from './utils/generic_utils';\n/** Verbosity logging level when fitting a model. */\n\nexport var ModelLoggingVerbosity;\n\n(function (ModelLoggingVerbosity) {\n  ModelLoggingVerbosity[ModelLoggingVerbosity[\"SILENT\"] = 0] = \"SILENT\";\n  ModelLoggingVerbosity[ModelLoggingVerbosity[\"VERBOSE\"] = 1] = \"VERBOSE\";\n})(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));\n/** How often to yield to the main thread when training (in ms). */\n\n\nexport const DEFAULT_YIELD_EVERY_MS = 125;\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\n\nexport class BaseCallback {\n  constructor() {\n    // TODO(michaelterry): This type is a best guess.\n    this.validationData = null;\n  }\n\n  setParams(params) {\n    this.params = params;\n  }\n\n  onEpochBegin(epoch, logs) {\n    return _asyncToGenerator(function* () {})();\n  }\n\n  onEpochEnd(epoch, logs) {\n    return _asyncToGenerator(function* () {})();\n  }\n\n  onBatchBegin(batch, logs) {\n    return _asyncToGenerator(function* () {})();\n  }\n\n  onBatchEnd(batch, logs) {\n    return _asyncToGenerator(function* () {})();\n  }\n\n  onTrainBegin(logs) {\n    return _asyncToGenerator(function* () {})();\n  }\n\n  onTrainEnd(logs) {\n    return _asyncToGenerator(function* () {})();\n  } // LayersModel needs to call Callback.setModel(), but cannot actually depend\n  // on Callback because that creates a cyclic dependency.  Providing this no-op\n  // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n  // BaseCallback but not on Callback.  The argument is typed as `Container`\n  // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n  // overrides this method and enforces that the argument is really a\n  // LayersModel.\n\n\n  setModel(model) {// Do nothing. Use Callback instead of BaseCallback to track the model.\n  }\n\n}\n/**\n * Container abstracting a list of callbacks.\n */\n\nexport class CallbackList {\n  // TODO(cais): When the need arises, uncomment the following lines and\n  // implement the queue for time values.\n  // private deltaTBatch: number;\n  // private deltaTsBatchBegin: Array<number>;\n  // private deltaTsBatchEnd: Array<number>;\n\n  /**\n   * Constructor of CallbackList.\n   * @param callbacks Array of `Callback` instances.\n   * @param queueLength Queue length for keeping running statistics over\n   *   callback execution time.\n   */\n  constructor(callbacks, queueLength = 10) {\n    // TODO(cais): Make use of queueLength when implementing the queue for time\n    // values.\n    if (callbacks == null) {\n      callbacks = [];\n    }\n\n    this.callbacks = callbacks;\n    this.queueLength = queueLength;\n  }\n\n  append(callback) {\n    this.callbacks.push(callback);\n  }\n\n  setParams(params) {\n    for (const callback of this.callbacks) {\n      callback.setParams(params);\n    }\n  }\n\n  setModel(model) {\n    for (const callback of this.callbacks) {\n      callback.setModel(model);\n    }\n  }\n  /**\n   * Called at the start of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n\n\n  onEpochBegin(epoch, logs) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (logs == null) {\n        logs = {};\n      }\n\n      for (const callback of _this.callbacks) {\n        yield callback.onEpochBegin(epoch, logs);\n      }\n    })();\n  }\n  /**\n   * Called at the end of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n\n\n  onEpochEnd(epoch, logs) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (logs == null) {\n        logs = {};\n      }\n\n      for (const callback of _this2.callbacks) {\n        yield callback.onEpochEnd(epoch, logs);\n      }\n    })();\n  }\n  /**\n   * Called  right before processing a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n\n\n  onBatchBegin(batch, logs) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (logs == null) {\n        logs = {};\n      }\n\n      for (const callback of _this3.callbacks) {\n        yield callback.onBatchBegin(batch, logs);\n      }\n    })();\n  }\n  /**\n   * Called at the end of a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n\n\n  onBatchEnd(batch, logs) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (logs == null) {\n        logs = {};\n      }\n\n      for (const callback of _this4.callbacks) {\n        yield callback.onBatchEnd(batch, logs);\n      }\n    })();\n  }\n  /**\n   * Called at the beginning of training.\n   * @param logs Dictionary of logs.\n   */\n\n\n  onTrainBegin(logs) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      if (logs == null) {\n        logs = {};\n      }\n\n      for (const callback of _this5.callbacks) {\n        yield callback.onTrainBegin(logs);\n      }\n    })();\n  }\n  /**\n   * Called at the end of training.\n   * @param logs Dictionary of logs.\n   */\n\n\n  onTrainEnd(logs) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      if (logs == null) {\n        logs = {};\n      }\n\n      for (const callback of _this6.callbacks) {\n        yield callback.onTrainEnd(logs);\n      }\n    })();\n  }\n\n}\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\n\nexport class BaseLogger extends BaseCallback {\n  constructor() {\n    super();\n  }\n\n  onEpochBegin(epoch) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      _this7.seen = 0;\n      _this7.totals = {};\n    })();\n  }\n\n  onBatchEnd(batch, logs) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      if (logs == null) {\n        logs = {};\n      }\n\n      const batchSize = logs['size'] == null ? 0 : logs['size'];\n      _this8.seen += batchSize;\n\n      for (const key in logs) {\n        const value = logs[key];\n\n        if (typeof value === 'number') {\n          if (!_this8.totals.hasOwnProperty(key)) {\n            _this8.totals[key] = 0;\n          }\n\n          _this8.totals[key] = _this8.totals[key] + value * batchSize;\n        } else {\n          let oldTotalsToDispose;\n\n          if (key in _this8.totals) {\n            oldTotalsToDispose = _this8.totals[key];\n          } else {\n            _this8.totals[key] = 0;\n          }\n\n          const total = tidy(() => add(_this8.totals[key], mul(value, batchSize)));\n          _this8.totals[key] = total;\n\n          if (oldTotalsToDispose != null) {\n            oldTotalsToDispose.dispose();\n          }\n        }\n      }\n    })();\n  }\n\n  onEpochEnd(epoch, logs) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      if (logs != null) {\n        for (const key of _this9.params['metrics']) {\n          if (_this9.totals[key] == null) {\n            continue;\n          }\n\n          if (typeof _this9.totals[key] === 'number') {\n            logs[key] = _this9.totals[key] / _this9.seen;\n          } else {\n            tidy(() => {\n              const log = mul(div(1, _this9.seen), _this9.totals[key]);\n              logs[key] = log;\n\n              _this9.totals[key].dispose();\n\n              keep(logs[key]);\n            });\n          }\n        }\n      }\n    })();\n  }\n\n}\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\n\nexport class History extends BaseCallback {\n  onTrainBegin(logs) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      _this10.epoch = [];\n      _this10.history = {};\n    })();\n  }\n\n  onEpochEnd(epoch, logs) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      if (logs == null) {\n        logs = {};\n      }\n\n      _this11.epoch.push(epoch);\n\n      for (const key in logs) {\n        if (_this11.history[key] == null) {\n          _this11.history[key] = [];\n        }\n\n        _this11.history[key].push(logs[key]);\n      }\n    })();\n  }\n  /**\n   * Await the values of all losses and metrics.\n   */\n\n\n  syncData() {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      const promises = [];\n      const keys = [];\n      const indices = [];\n\n      for (const key in _this12.history) {\n        const valueArray = _this12.history[key];\n\n        for (let i = 0; i < valueArray.length; ++i) {\n          if (typeof valueArray[i] !== 'number') {\n            const valueScalar = valueArray[i];\n            promises.push(valueScalar.data());\n            keys.push(key);\n            indices.push(i);\n          }\n        }\n      }\n\n      const values = yield Promise.all(promises);\n\n      for (let n = 0; n < values.length; ++n) {\n        const tensorToDispose = _this12.history[keys[n]][indices[n]];\n        tensorToDispose.dispose();\n        _this12.history[keys[n]][indices[n]] = values[n][0];\n      }\n    })();\n  }\n\n}\n/**\n * Custom callback for training.\n */\n\nexport class CustomCallback extends BaseCallback {\n  constructor(args, yieldEvery) {\n    super();\n    this.currentEpoch = 0;\n    this.yieldEvery = yieldEvery || 'auto';\n\n    if (this.yieldEvery === 'auto') {\n      this.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n    }\n\n    if (this.yieldEvery === 'never' && args.onYield != null) {\n      throw new Error('yieldEvery is `never` but you provided an `onYield` callback. ' + 'Either change `yieldEvery` or remove the callback');\n    }\n\n    if (util.isNumber(this.yieldEvery)) {\n      // Decorate `maybeWait` so it will be called at most once every\n      // `yieldEvery` ms.\n      this.maybeWait = generic_utils.debounce(this.maybeWait.bind(this), this.yieldEvery);\n    }\n\n    this.trainBegin = args.onTrainBegin;\n    this.trainEnd = args.onTrainEnd;\n    this.epochBegin = args.onEpochBegin;\n    this.epochEnd = args.onEpochEnd;\n    this.batchBegin = args.onBatchBegin;\n    this.batchEnd = args.onBatchEnd;\n    this.yield = args.onYield;\n  }\n\n  maybeWait(epoch, batch, logs) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      const ps = [];\n\n      if (_this13.yield != null) {\n        yield resolveScalarsInLogs(logs);\n        ps.push(_this13.yield(epoch, batch, logs));\n      }\n\n      ps.push(nextFrame());\n      yield Promise.all(ps);\n    })();\n  }\n\n  onEpochBegin(epoch, logs) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      _this14.currentEpoch = epoch;\n\n      if (_this14.epochBegin != null) {\n        yield resolveScalarsInLogs(logs);\n        yield _this14.epochBegin(epoch, logs);\n      }\n    })();\n  }\n\n  onEpochEnd(epoch, logs) {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      const ps = [];\n\n      if (_this15.epochEnd != null) {\n        yield resolveScalarsInLogs(logs);\n        ps.push(_this15.epochEnd(epoch, logs));\n      }\n\n      if (_this15.yieldEvery === 'epoch') {\n        ps.push(nextFrame());\n      }\n\n      yield Promise.all(ps);\n    })();\n  }\n\n  onBatchBegin(batch, logs) {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this16.batchBegin != null) {\n        yield resolveScalarsInLogs(logs);\n        yield _this16.batchBegin(batch, logs);\n      }\n    })();\n  }\n\n  onBatchEnd(batch, logs) {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      const ps = [];\n\n      if (_this17.batchEnd != null) {\n        yield resolveScalarsInLogs(logs);\n        ps.push(_this17.batchEnd(batch, logs));\n      }\n\n      if (_this17.yieldEvery === 'batch') {\n        ps.push(nextFrame());\n      } else if (util.isNumber(_this17.yieldEvery)) {\n        ps.push(_this17.maybeWait(_this17.currentEpoch, batch, logs));\n      }\n\n      yield Promise.all(ps);\n    })();\n  }\n\n  onTrainBegin(logs) {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this18.trainBegin != null) {\n        yield resolveScalarsInLogs(logs);\n        yield _this18.trainBegin(logs);\n      }\n    })();\n  }\n\n  onTrainEnd(logs) {\n    var _this19 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this19.trainEnd != null) {\n        yield resolveScalarsInLogs(logs);\n        yield _this19.trainEnd(logs);\n      }\n    })();\n  }\n\n}\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\n\nexport function standardizeCallbacks(callbacks, yieldEvery) {\n  if (callbacks == null) {\n    callbacks = {};\n  }\n\n  if (callbacks instanceof BaseCallback) {\n    return [callbacks];\n  }\n\n  if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n    return callbacks;\n  } // Convert custom callback configs to custom callback objects.\n\n\n  const callbackConfigs = generic_utils.toList(callbacks);\n  return callbackConfigs.map(callbackConfig => new CustomCallback(callbackConfig, yieldEvery));\n}\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\n\nexport class CallbackConstructorRegistry {\n  /**\n   * Blocks public access to constructor.\n   */\n  constructor() {}\n  /**\n   * Register a tf.LayersModel.fit() callback constructor.\n   *\n   * The registered callback constructor will be used to instantiate\n   * callbacks for every tf.LayersModel.fit() call afterwards.\n   *\n   * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n   *   is to be reigstered.\n   * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n   * @throws Error, if the same callbackConstructor has been registered before,\n   *   either at the same or a different `verbosityLevel`.\n   */\n\n\n  static registerCallbackConstructor(verbosityLevel, callbackConstructor) {\n    util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), () => `Verbosity level is expected to be an integer >= 0, ` + `but got ${verbosityLevel}`);\n    CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n\n    if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n      CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n    }\n\n    CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);\n  }\n\n  static checkForDuplicate(callbackConstructor) {\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const constructors = CallbackConstructorRegistry.constructors[+levelName];\n      constructors.forEach(ctor => {\n        if (ctor === callbackConstructor) {\n          throw new ValueError('Duplicate callback constructor.');\n        }\n      });\n    }\n  }\n  /**\n   * Clear all registered callback constructors.\n   */\n\n\n  static clear() {\n    CallbackConstructorRegistry.constructors = {};\n  }\n  /**\n   * Create callbacks using the registered callback constructors.\n   *\n   * Given `verbosityLevel`, all constructors registered at that level or above\n   * will be called and the instantiated callbacks will be used.\n   *\n   * @param verbosityLevel: Level of verbosity.\n   */\n\n\n  static createCallbacks(verbosityLevel) {\n    const constructors = [];\n\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const level = +levelName;\n\n      if (verbosityLevel >= level) {\n        constructors.push(...CallbackConstructorRegistry.constructors[level]);\n      }\n    }\n\n    return constructors.map(ctor => new ctor());\n  }\n\n}\nCallbackConstructorRegistry.constructors = {};\nexport function configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {\n  const history = new History();\n  const actualCallbacks = [new BaseLogger(), ...CallbackConstructorRegistry.createCallbacks(verbose)];\n\n  if (callbacks != null) {\n    actualCallbacks.push(...callbacks);\n  }\n\n  actualCallbacks.push(history);\n  const callbackList = new CallbackList(actualCallbacks); // TODO(cais): Figure out when this LayersModel instance can have a\n  // dynamically\n  //   set property called 'callback_model' as in PyKeras.\n\n  callbackList.setParams({\n    epochs,\n    initialEpoch,\n    samples: numTrainSamples,\n    steps: stepsPerEpoch,\n    batchSize,\n    verbose,\n    doValidation,\n    metrics: callbackMetrics\n  });\n  return {\n    callbackList,\n    history\n  };\n}","map":{"version":3,"sources":["/Users/ryanliang/Downloads/main_movir_picker/node_modules/@tensorflow/tfjs-layers/dist/base_callbacks.js"],"names":["add","div","keep","mul","nextFrame","tidy","util","ValueError","resolveScalarsInLogs","generic_utils","ModelLoggingVerbosity","DEFAULT_YIELD_EVERY_MS","BaseCallback","constructor","validationData","setParams","params","onEpochBegin","epoch","logs","onEpochEnd","onBatchBegin","batch","onBatchEnd","onTrainBegin","onTrainEnd","setModel","model","CallbackList","callbacks","queueLength","append","callback","push","BaseLogger","seen","totals","batchSize","key","value","hasOwnProperty","oldTotalsToDispose","total","dispose","log","History","history","syncData","promises","keys","indices","valueArray","i","length","valueScalar","data","values","Promise","all","n","tensorToDispose","CustomCallback","args","yieldEvery","currentEpoch","onYield","Error","isNumber","maybeWait","debounce","bind","trainBegin","trainEnd","epochBegin","epochEnd","batchBegin","batchEnd","yield","ps","standardizeCallbacks","Array","isArray","callbackConfigs","toList","map","callbackConfig","CallbackConstructorRegistry","registerCallbackConstructor","verbosityLevel","callbackConstructor","assert","Number","isInteger","checkForDuplicate","constructors","levelName","forEach","ctor","clear","createCallbacks","level","configureCallbacks","verbose","epochs","initialEpoch","numTrainSamples","stepsPerEpoch","doValidation","callbackMetrics","actualCallbacks","callbackList","samples","steps","metrics"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source: keras/callbacks.py */\nimport { add, div, keep, mul, nextFrame, tidy, util } from '@tensorflow/tfjs-core';\nimport { ValueError } from './errors';\nimport { resolveScalarsInLogs } from './logs';\nimport * as generic_utils from './utils/generic_utils';\n/** Verbosity logging level when fitting a model. */\nexport var ModelLoggingVerbosity;\n(function (ModelLoggingVerbosity) {\n    ModelLoggingVerbosity[ModelLoggingVerbosity[\"SILENT\"] = 0] = \"SILENT\";\n    ModelLoggingVerbosity[ModelLoggingVerbosity[\"VERBOSE\"] = 1] = \"VERBOSE\";\n})(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));\n/** How often to yield to the main thread when training (in ms). */\nexport const DEFAULT_YIELD_EVERY_MS = 125;\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\nexport class BaseCallback {\n    constructor() {\n        // TODO(michaelterry): This type is a best guess.\n        this.validationData = null;\n    }\n    setParams(params) {\n        this.params = params;\n    }\n    async onEpochBegin(epoch, logs) { }\n    async onEpochEnd(epoch, logs) { }\n    async onBatchBegin(batch, logs) { }\n    async onBatchEnd(batch, logs) { }\n    async onTrainBegin(logs) { }\n    async onTrainEnd(logs) { }\n    // LayersModel needs to call Callback.setModel(), but cannot actually depend\n    // on Callback because that creates a cyclic dependency.  Providing this no-op\n    // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n    // BaseCallback but not on Callback.  The argument is typed as `Container`\n    // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n    // overrides this method and enforces that the argument is really a\n    // LayersModel.\n    setModel(model) {\n        // Do nothing. Use Callback instead of BaseCallback to track the model.\n    }\n}\n/**\n * Container abstracting a list of callbacks.\n */\nexport class CallbackList {\n    // TODO(cais): When the need arises, uncomment the following lines and\n    // implement the queue for time values.\n    // private deltaTBatch: number;\n    // private deltaTsBatchBegin: Array<number>;\n    // private deltaTsBatchEnd: Array<number>;\n    /**\n     * Constructor of CallbackList.\n     * @param callbacks Array of `Callback` instances.\n     * @param queueLength Queue length for keeping running statistics over\n     *   callback execution time.\n     */\n    constructor(callbacks, queueLength = 10) {\n        // TODO(cais): Make use of queueLength when implementing the queue for time\n        // values.\n        if (callbacks == null) {\n            callbacks = [];\n        }\n        this.callbacks = callbacks;\n        this.queueLength = queueLength;\n    }\n    append(callback) {\n        this.callbacks.push(callback);\n    }\n    setParams(params) {\n        for (const callback of this.callbacks) {\n            callback.setParams(params);\n        }\n    }\n    setModel(model) {\n        for (const callback of this.callbacks) {\n            callback.setModel(model);\n        }\n    }\n    /**\n     * Called at the start of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onEpochBegin(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onEpochBegin(epoch, logs);\n        }\n    }\n    /**\n     * Called at the end of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onEpochEnd(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onEpochEnd(epoch, logs);\n        }\n    }\n    /**\n     * Called  right before processing a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onBatchBegin(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onBatchBegin(batch, logs);\n        }\n    }\n    /**\n     * Called at the end of a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onBatchEnd(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onBatchEnd(batch, logs);\n        }\n    }\n    /**\n     * Called at the beginning of training.\n     * @param logs Dictionary of logs.\n     */\n    async onTrainBegin(logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onTrainBegin(logs);\n        }\n    }\n    /**\n     * Called at the end of training.\n     * @param logs Dictionary of logs.\n     */\n    async onTrainEnd(logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onTrainEnd(logs);\n        }\n    }\n}\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\nexport class BaseLogger extends BaseCallback {\n    constructor() {\n        super();\n    }\n    async onEpochBegin(epoch) {\n        this.seen = 0;\n        this.totals = {};\n    }\n    async onBatchEnd(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        const batchSize = logs['size'] == null ? 0 : logs['size'];\n        this.seen += batchSize;\n        for (const key in logs) {\n            const value = logs[key];\n            if (typeof value === 'number') {\n                if (!this.totals.hasOwnProperty(key)) {\n                    this.totals[key] = 0;\n                }\n                this.totals[key] = this.totals[key] + value * batchSize;\n            }\n            else {\n                let oldTotalsToDispose;\n                if (key in this.totals) {\n                    oldTotalsToDispose = this.totals[key];\n                }\n                else {\n                    this.totals[key] = 0;\n                }\n                const total = tidy(() => add((this.totals[key]), mul(value, batchSize)));\n                this.totals[key] = total;\n                if (oldTotalsToDispose != null) {\n                    oldTotalsToDispose.dispose();\n                }\n            }\n        }\n    }\n    async onEpochEnd(epoch, logs) {\n        if (logs != null) {\n            for (const key of this.params['metrics']) {\n                if (this.totals[key] == null) {\n                    continue;\n                }\n                if (typeof this.totals[key] === 'number') {\n                    logs[key] = this.totals[key] / this.seen;\n                }\n                else {\n                    tidy(() => {\n                        const log = mul(div(1, this.seen), this.totals[key]);\n                        logs[key] = log;\n                        this.totals[key].dispose();\n                        keep(logs[key]);\n                    });\n                }\n            }\n        }\n    }\n}\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\nexport class History extends BaseCallback {\n    async onTrainBegin(logs) {\n        this.epoch = [];\n        this.history = {};\n    }\n    async onEpochEnd(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        this.epoch.push(epoch);\n        for (const key in logs) {\n            if (this.history[key] == null) {\n                this.history[key] = [];\n            }\n            this.history[key].push(logs[key]);\n        }\n    }\n    /**\n     * Await the values of all losses and metrics.\n     */\n    async syncData() {\n        const promises = [];\n        const keys = [];\n        const indices = [];\n        for (const key in this.history) {\n            const valueArray = this.history[key];\n            for (let i = 0; i < valueArray.length; ++i) {\n                if (typeof valueArray[i] !== 'number') {\n                    const valueScalar = valueArray[i];\n                    promises.push(valueScalar.data());\n                    keys.push(key);\n                    indices.push(i);\n                }\n            }\n        }\n        const values = await Promise.all(promises);\n        for (let n = 0; n < values.length; ++n) {\n            const tensorToDispose = this.history[keys[n]][indices[n]];\n            tensorToDispose.dispose();\n            this.history[keys[n]][indices[n]] = values[n][0];\n        }\n    }\n}\n/**\n * Custom callback for training.\n */\nexport class CustomCallback extends BaseCallback {\n    constructor(args, yieldEvery) {\n        super();\n        this.currentEpoch = 0;\n        this.yieldEvery = yieldEvery || 'auto';\n        if (this.yieldEvery === 'auto') {\n            this.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n        }\n        if (this.yieldEvery === 'never' && args.onYield != null) {\n            throw new Error('yieldEvery is `never` but you provided an `onYield` callback. ' +\n                'Either change `yieldEvery` or remove the callback');\n        }\n        if (util.isNumber(this.yieldEvery)) {\n            // Decorate `maybeWait` so it will be called at most once every\n            // `yieldEvery` ms.\n            this.maybeWait = generic_utils.debounce(this.maybeWait.bind(this), this.yieldEvery);\n        }\n        this.trainBegin = args.onTrainBegin;\n        this.trainEnd = args.onTrainEnd;\n        this.epochBegin = args.onEpochBegin;\n        this.epochEnd = args.onEpochEnd;\n        this.batchBegin = args.onBatchBegin;\n        this.batchEnd = args.onBatchEnd;\n        this.yield = args.onYield;\n    }\n    async maybeWait(epoch, batch, logs) {\n        const ps = [];\n        if (this.yield != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.yield(epoch, batch, logs));\n        }\n        ps.push(nextFrame());\n        await Promise.all(ps);\n    }\n    async onEpochBegin(epoch, logs) {\n        this.currentEpoch = epoch;\n        if (this.epochBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.epochBegin(epoch, logs);\n        }\n    }\n    async onEpochEnd(epoch, logs) {\n        const ps = [];\n        if (this.epochEnd != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.epochEnd(epoch, logs));\n        }\n        if (this.yieldEvery === 'epoch') {\n            ps.push(nextFrame());\n        }\n        await Promise.all(ps);\n    }\n    async onBatchBegin(batch, logs) {\n        if (this.batchBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.batchBegin(batch, logs);\n        }\n    }\n    async onBatchEnd(batch, logs) {\n        const ps = [];\n        if (this.batchEnd != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.batchEnd(batch, logs));\n        }\n        if (this.yieldEvery === 'batch') {\n            ps.push(nextFrame());\n        }\n        else if (util.isNumber(this.yieldEvery)) {\n            ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n        }\n        await Promise.all(ps);\n    }\n    async onTrainBegin(logs) {\n        if (this.trainBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.trainBegin(logs);\n        }\n    }\n    async onTrainEnd(logs) {\n        if (this.trainEnd != null) {\n            await resolveScalarsInLogs(logs);\n            await this.trainEnd(logs);\n        }\n    }\n}\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\nexport function standardizeCallbacks(callbacks, yieldEvery) {\n    if (callbacks == null) {\n        callbacks = {};\n    }\n    if (callbacks instanceof BaseCallback) {\n        return [callbacks];\n    }\n    if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n        return callbacks;\n    }\n    // Convert custom callback configs to custom callback objects.\n    const callbackConfigs = generic_utils.toList(callbacks);\n    return callbackConfigs.map(callbackConfig => new CustomCallback(callbackConfig, yieldEvery));\n}\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\nexport class CallbackConstructorRegistry {\n    /**\n     * Blocks public access to constructor.\n     */\n    constructor() { }\n    /**\n     * Register a tf.LayersModel.fit() callback constructor.\n     *\n     * The registered callback constructor will be used to instantiate\n     * callbacks for every tf.LayersModel.fit() call afterwards.\n     *\n     * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n     *   is to be reigstered.\n     * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n     * @throws Error, if the same callbackConstructor has been registered before,\n     *   either at the same or a different `verbosityLevel`.\n     */\n    static registerCallbackConstructor(verbosityLevel, callbackConstructor) {\n        util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), () => `Verbosity level is expected to be an integer >= 0, ` +\n            `but got ${verbosityLevel}`);\n        CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n        if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n            CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n        }\n        CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);\n    }\n    static checkForDuplicate(callbackConstructor) {\n        for (const levelName in CallbackConstructorRegistry.constructors) {\n            const constructors = CallbackConstructorRegistry.constructors[+levelName];\n            constructors.forEach(ctor => {\n                if (ctor === callbackConstructor) {\n                    throw new ValueError('Duplicate callback constructor.');\n                }\n            });\n        }\n    }\n    /**\n     * Clear all registered callback constructors.\n     */\n    static clear() {\n        CallbackConstructorRegistry.constructors = {};\n    }\n    /**\n     * Create callbacks using the registered callback constructors.\n     *\n     * Given `verbosityLevel`, all constructors registered at that level or above\n     * will be called and the instantiated callbacks will be used.\n     *\n     * @param verbosityLevel: Level of verbosity.\n     */\n    static createCallbacks(verbosityLevel) {\n        const constructors = [];\n        for (const levelName in CallbackConstructorRegistry.constructors) {\n            const level = +levelName;\n            if (verbosityLevel >= level) {\n                constructors.push(...CallbackConstructorRegistry.constructors[level]);\n            }\n        }\n        return constructors.map(ctor => new ctor());\n    }\n}\nCallbackConstructorRegistry.constructors = {};\nexport function configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {\n    const history = new History();\n    const actualCallbacks = [\n        new BaseLogger(), ...CallbackConstructorRegistry.createCallbacks(verbose)\n    ];\n    if (callbacks != null) {\n        actualCallbacks.push(...callbacks);\n    }\n    actualCallbacks.push(history);\n    const callbackList = new CallbackList(actualCallbacks);\n    // TODO(cais): Figure out when this LayersModel instance can have a\n    // dynamically\n    //   set property called 'callback_model' as in PyKeras.\n    callbackList.setParams({\n        epochs,\n        initialEpoch,\n        samples: numTrainSamples,\n        steps: stepsPerEpoch,\n        batchSize,\n        verbose,\n        doValidation,\n        metrics: callbackMetrics,\n    });\n    return { callbackList, history };\n}\n"]},"metadata":{},"sourceType":"module"}
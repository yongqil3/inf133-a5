{"ast":null,"code":"import _asyncToGenerator from \"/Users/ryanliang/Downloads/main_movir_picker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport { assert, assertShapesMatch, getTypedArrayFromDType } from '../util';\nimport { tensor } from './tensor';\n/**\n * Returns whether the targets are in the top K predictions.\n *\n * ```js\n * const predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);\n * const targets = tf.tensor1d([2, 0]);\n * const precision = await tf.inTopKAsync(predictions, targets);\n * precision.print();\n * ```\n * @param predictions 2-D or higher `tf.Tensor` with last dimension being\n *     at least `k`.\n * @param targets 1-D or higher `tf.Tensor`.\n * @param k Optional Number of top elements to look at for computing precision,\n *     default to 1.\n *\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\n */\n\nfunction inTopKAsync_(_x, _x2) {\n  return _inTopKAsync_.apply(this, arguments);\n}\n\nfunction _inTopKAsync_() {\n  _inTopKAsync_ = _asyncToGenerator(function* (predictions, targets, k = 1) {\n    const $predictions = convertToTensor(predictions, 'predictions', 'inTopK');\n    const $targets = convertToTensor(targets, 'targets', 'inTopK');\n    assert($predictions.rank > 1, () => 'inTopK() expects the predictions to be of rank 2 or higher, ' + `but got ${$predictions.rank}`);\n    assert($predictions.rank - 1 === $targets.rank, () => `predictions rank should be 1 larger than ` + `targets rank, but got predictions rank ` + `${$predictions.rank} and targets rank ${$targets.rank}`);\n    assertShapesMatch($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, `predictions's shape should be align with the targets' shape, ` + 'except the last dimension.');\n    const lastDim = $predictions.shape[$predictions.shape.length - 1];\n    assert(k > 0 && k <= lastDim, () => `'k' passed to inTopK() must be > 0 && <= the predictions last ` + `dimension (${lastDim}), but got ${k}`);\n    const predictionsVals = yield $predictions.data();\n    const targetsVals = yield $targets.data(); // Reshape predictionsVals into a 2d tensor [batch, lastDim]\n    // and look up topK along lastDim.\n\n    const [batch, size] = [predictionsVals.length / lastDim, lastDim];\n    const precision = getTypedArrayFromDType('bool', batch);\n\n    for (let b = 0; b < batch; b++) {\n      const offset = b * size;\n      const vals = predictionsVals.subarray(offset, offset + size);\n      const valAndInd = [];\n\n      for (let i = 0; i < vals.length; i++) {\n        valAndInd.push({\n          value: vals[i],\n          index: i\n        });\n      }\n\n      valAndInd.sort((a, b) => b.value - a.value);\n      precision[b] = 0;\n\n      for (let i = 0; i < k; i++) {\n        if (valAndInd[i].index === targetsVals[b]) {\n          precision[b] = 1;\n          break;\n        }\n      }\n    }\n\n    if (predictions !== $predictions) {\n      $predictions.dispose();\n    }\n\n    if (targets !== $targets) {\n      $targets.dispose();\n    } // Output precision has the same shape as targets.\n\n\n    return tensor(precision, $targets.shape, 'bool');\n  });\n  return _inTopKAsync_.apply(this, arguments);\n}\n\nexport const inTopKAsync = inTopKAsync_;","map":{"version":3,"sources":["/Users/ryanliang/Downloads/main_movir_picker/node_modules/@tensorflow/tfjs-core/dist/ops/in_top_k.js"],"names":["convertToTensor","assert","assertShapesMatch","getTypedArrayFromDType","tensor","inTopKAsync_","predictions","targets","k","$predictions","$targets","rank","shape","slice","length","lastDim","predictionsVals","data","targetsVals","batch","size","precision","b","offset","vals","subarray","valAndInd","i","push","value","index","sort","a","dispose","inTopKAsync"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport { assert, assertShapesMatch, getTypedArrayFromDType } from '../util';\nimport { tensor } from './tensor';\n/**\n * Returns whether the targets are in the top K predictions.\n *\n * ```js\n * const predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);\n * const targets = tf.tensor1d([2, 0]);\n * const precision = await tf.inTopKAsync(predictions, targets);\n * precision.print();\n * ```\n * @param predictions 2-D or higher `tf.Tensor` with last dimension being\n *     at least `k`.\n * @param targets 1-D or higher `tf.Tensor`.\n * @param k Optional Number of top elements to look at for computing precision,\n *     default to 1.\n *\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\n */\nasync function inTopKAsync_(predictions, targets, k = 1) {\n    const $predictions = convertToTensor(predictions, 'predictions', 'inTopK');\n    const $targets = convertToTensor(targets, 'targets', 'inTopK');\n    assert($predictions.rank > 1, () => 'inTopK() expects the predictions to be of rank 2 or higher, ' +\n        `but got ${$predictions.rank}`);\n    assert($predictions.rank - 1 === $targets.rank, () => `predictions rank should be 1 larger than ` +\n        `targets rank, but got predictions rank ` +\n        `${$predictions.rank} and targets rank ${$targets.rank}`);\n    assertShapesMatch($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, `predictions's shape should be align with the targets' shape, ` +\n        'except the last dimension.');\n    const lastDim = $predictions.shape[$predictions.shape.length - 1];\n    assert(k > 0 && k <= lastDim, () => `'k' passed to inTopK() must be > 0 && <= the predictions last ` +\n        `dimension (${lastDim}), but got ${k}`);\n    const predictionsVals = await $predictions.data();\n    const targetsVals = await $targets.data();\n    // Reshape predictionsVals into a 2d tensor [batch, lastDim]\n    // and look up topK along lastDim.\n    const [batch, size] = [predictionsVals.length / lastDim, lastDim];\n    const precision = getTypedArrayFromDType('bool', batch);\n    for (let b = 0; b < batch; b++) {\n        const offset = b * size;\n        const vals = predictionsVals.subarray(offset, offset + size);\n        const valAndInd = [];\n        for (let i = 0; i < vals.length; i++) {\n            valAndInd.push({ value: vals[i], index: i });\n        }\n        valAndInd.sort((a, b) => b.value - a.value);\n        precision[b] = 0;\n        for (let i = 0; i < k; i++) {\n            if (valAndInd[i].index === targetsVals[b]) {\n                precision[b] = 1;\n                break;\n            }\n        }\n    }\n    if (predictions !== $predictions) {\n        $predictions.dispose();\n    }\n    if (targets !== $targets) {\n        $targets.dispose();\n    }\n    // Output precision has the same shape as targets.\n    return tensor(precision, $targets.shape, 'bool');\n}\nexport const inTopKAsync = inTopKAsync_;\n"]},"metadata":{},"sourceType":"module"}
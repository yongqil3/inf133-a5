{"ast":null,"code":"import _asyncToGenerator from \"/Users/ryanliang/Downloads/main_movir_picker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { scalar } from '@tensorflow/tfjs-core';\nimport { TensorArray } from '../../executor/tensor_array';\nimport { fromTensor, reserve, scatter, split } from '../../executor/tensor_list';\nimport { cloneTensor, getParamValue, getTensor } from './utils';\nexport const executeOp = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (node, tensorMap, context) {\n    switch (node.op) {\n      case 'If':\n      case 'StatelessIf':\n        {\n          const thenFunc = getParamValue('thenBranch', node, tensorMap, context);\n          const elseFunc = getParamValue('elseBranch', node, tensorMap, context);\n          const cond = getParamValue('cond', node, tensorMap, context);\n          const args = getParamValue('args', node, tensorMap, context);\n          const condValue = yield cond.data();\n\n          if (condValue[0]) {\n            return context.functionMap[thenFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);\n          } else {\n            return context.functionMap[elseFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);\n          }\n        }\n\n      case 'While':\n      case 'StatelessWhile':\n        {\n          const bodyFunc = getParamValue('body', node, tensorMap, context);\n          const condFunc = getParamValue('cond', node, tensorMap, context);\n          const args = getParamValue('args', node, tensorMap, context); // Calculate the condition of the loop\n\n          const condResult = yield context.functionMap[condFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);\n          const argIds = args.map(tensor => tensor.id);\n          let condValue = yield condResult[0].data(); // Dispose the intermediate tensors for condition function\n\n          condResult.forEach(tensor => {\n            if (!tensor.kept && argIds.indexOf(tensor.id) === -1) {\n              tensor.dispose();\n            }\n          });\n          let result = args;\n\n          while (condValue[0]) {\n            // Record the previous result for intermediate tensor tracking\n            const origResult = result; // Execution the body of the loop\n\n            result = yield context.functionMap[bodyFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);\n            const resultIds = result.map(tensor => tensor.id); // Dispose the intermediate tensor for body function that is not global\n            // kept, not input/output of the body function\n\n            origResult.forEach(tensor => {\n              if (!tensor.kept && argIds.indexOf(tensor.id) === -1 && resultIds.indexOf(tensor.id) === -1) {\n                tensor.dispose();\n              }\n            }); // Recalcuate the condition of the loop using the latest results.\n\n            const condResult = yield context.functionMap[condFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);\n            condValue = yield condResult[0].data(); // Dispose the intermediate tensors for condition function\n\n            condResult.forEach(tensor => {\n              if (!tensor.kept && argIds.indexOf(tensor.id) === -1 && resultIds.indexOf(tensor.id) === -1) {\n                tensor.dispose();\n              }\n            });\n          }\n\n          return result;\n        }\n\n      case 'LoopCond':\n        {\n          const pred = getParamValue('pred', node, tensorMap, context);\n          return [cloneTensor(pred)];\n        }\n\n      case 'Switch':\n        {\n          const pred = getParamValue('pred', node, tensorMap, context);\n          let data = getParamValue('data', node, tensorMap, context);\n\n          if (!data.kept) {\n            data = cloneTensor(data);\n          } // Outputs nodes :0 => false, :1 => true\n\n\n          return (yield pred.data())[0] ? [undefined, data] : [data, undefined];\n        }\n\n      case 'Merge':\n        {\n          const inputName = node.inputNames.find(name => getTensor(name, tensorMap, context) !== undefined);\n\n          if (inputName) {\n            const data = getTensor(inputName, tensorMap, context);\n            return [cloneTensor(data)];\n          }\n\n          return undefined;\n        }\n\n      case 'Enter':\n        {\n          const frameId = getParamValue('frameName', node, tensorMap, context);\n          const data = getParamValue('tensor', node, tensorMap, context);\n          context.enterFrame(frameId);\n          return [cloneTensor(data)];\n        }\n\n      case 'Exit':\n        {\n          const data = getParamValue('tensor', node, tensorMap, context);\n          context.exitFrame();\n          return [cloneTensor(data)];\n        }\n\n      case 'NextIteration':\n        {\n          const data = getParamValue('tensor', node, tensorMap, context);\n          context.nextIteration();\n          return [cloneTensor(data)];\n        }\n\n      case 'TensorArrayV3':\n        {\n          const size = getParamValue('size', node, tensorMap, context);\n          const dtype = getParamValue('dtype', node, tensorMap, context);\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          const dynamicSize = getParamValue('dynamicSize', node, tensorMap, context);\n          const clearAfterRead = getParamValue('clearAfterRead', node, tensorMap, context);\n          const identicalElementShapes = getParamValue('identicalElementShapes', node, tensorMap, context);\n          const name = getParamValue('name', node, tensorMap, context);\n          const tensorArray = new TensorArray(name, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);\n          context.addTensorArray(tensorArray);\n          return [tensorArray.idTensor, scalar(1.0)];\n        }\n\n      case 'TensorArrayWriteV3':\n        {\n          const id = getParamValue('tensorArrayId', node, tensorMap, context);\n          const index = getParamValue('index', node, tensorMap, context);\n          const writeTensor = getParamValue('tensor', node, tensorMap, context);\n          const writeTensorArray = context.getTensorArray(id.id);\n          writeTensorArray.write(index, writeTensor);\n          return [writeTensorArray.idTensor];\n        }\n\n      case 'TensorArrayReadV3':\n        {\n          const readId = getParamValue('tensorArrayId', node, tensorMap, context);\n          const readIndex = getParamValue('index', node, tensorMap, context);\n          const readTensorArray = context.getTensorArray(readId.id);\n          return [readTensorArray.read(readIndex)];\n        }\n\n      case 'TensorArrayGatherV3':\n        {\n          const gatherId = getParamValue('tensorArrayId', node, tensorMap, context);\n          const gatherIndices = getParamValue('indices', node, tensorMap, context);\n          const gatherDtype = getParamValue('dtype', node, tensorMap, context);\n          const gatherTensorArray = context.getTensorArray(gatherId.id);\n          return [gatherTensorArray.gather(gatherIndices, gatherDtype)];\n        }\n\n      case 'TensorArrayScatterV3':\n        {\n          const scatterId = getParamValue('tensorArrayId', node, tensorMap, context);\n          const scatterIndices = getParamValue('indices', node, tensorMap, context);\n          const scatterTensor = getParamValue('tensor', node, tensorMap, context);\n          const scatterTensorArray = context.getTensorArray(scatterId.id);\n          scatterTensorArray.scatter(scatterIndices, scatterTensor);\n          return [scatterTensorArray.idTensor];\n        }\n\n      case 'TensorArrayConcatV3':\n        {\n          const concatId = getParamValue('tensorArrayId', node, tensorMap, context);\n          const concatTensorArray = context.getTensorArray(concatId.id);\n          const concatDtype = getParamValue('dtype', node, tensorMap, context);\n          return [concatTensorArray.concat(concatDtype)];\n        }\n\n      case 'TensorArraySplitV3':\n        {\n          const splitId = getParamValue('tensorArrayId', node, tensorMap, context);\n          const splitTensor = getParamValue('tensor', node, tensorMap, context);\n          const lengths = getParamValue('lengths', node, tensorMap, context);\n          const splitTensorArray = context.getTensorArray(splitId.id);\n          splitTensorArray.split(lengths, splitTensor);\n          return [splitTensorArray.idTensor];\n        }\n\n      case 'TensorArraySizeV3':\n        {\n          const sizeId = getParamValue('tensorArrayId', node, tensorMap, context);\n          const sizeTensorArray = context.getTensorArray(sizeId.id);\n          return [scalar(sizeTensorArray.size(), 'int32')];\n        }\n\n      case 'TensorArrayCloseV3':\n        {\n          const closeId = getParamValue('tensorArrayId', node, tensorMap, context);\n          const closeTensorArray = context.getTensorArray(closeId.id);\n          closeTensorArray.clearAndClose();\n          return [closeTensorArray.idTensor];\n        }\n\n      case 'TensorListSetItem':\n        {\n          const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          const index = getParamValue('index', node, tensorMap, context);\n          const writeTensor = getParamValue('tensor', node, tensorMap, context);\n          const tensorList = context.getTensorList(idTensor.id);\n          tensorList.setItem(index, writeTensor);\n          return [tensorList.idTensor];\n        }\n\n      case 'TensorListGetItem':\n        {\n          const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          const readIndex = getParamValue('index', node, tensorMap, context);\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          const elementDType = getParamValue('elementDType', node, tensorMap, context);\n          const tensorList = context.getTensorList(idTensor.id);\n          return [tensorList.getItem(readIndex, elementShape, elementDType)];\n        }\n\n      case 'TensorListScatterV2':\n      case 'TensorListScatter':\n        {\n          const scatterIndices = getParamValue('indices', node, tensorMap, context);\n          const scatterTensor = getParamValue('tensor', node, tensorMap, context);\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          const numElements = getParamValue('numElements', node, tensorMap, context);\n          const tensorList = scatter(scatterTensor, scatterIndices, elementShape, numElements);\n          context.addTensorList(tensorList);\n          return [tensorList.idTensor];\n        }\n\n      case 'TensorListReserve':\n      case 'EmptyTensorList':\n        {\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          const elementDtype = getParamValue('elementDType', node, tensorMap, context);\n          let numElementsParam;\n\n          if (node.op === 'TensorListReserve') {\n            numElementsParam = 'numElements';\n          } else {\n            numElementsParam = 'maxNumElements';\n          }\n\n          const numElements = getParamValue(numElementsParam, node, tensorMap, context);\n          const tensorList = reserve(elementShape, elementDtype, numElements);\n          context.addTensorList(tensorList);\n          return [tensorList.idTensor];\n        }\n\n      case 'TensorListGather':\n        {\n          const gatherId = getParamValue('tensorListId', node, tensorMap, context);\n          const gatherIndices = getParamValue('indices', node, tensorMap, context);\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          const elementDtype = getParamValue('elementDType', node, tensorMap, context);\n          const tensorList = context.getTensorList(gatherId.id);\n          return [tensorList.gather(gatherIndices, elementDtype, elementShape)];\n        }\n\n      case 'TensorListStack':\n        {\n          const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          const elementDtype = getParamValue('elementDType', node, tensorMap, context);\n          const numElements = getParamValue('numElements', node, tensorMap, context);\n          const tensorList = context.getTensorList(idTensor.id);\n          return [tensorList.stack(elementShape, elementDtype, numElements)];\n        }\n\n      case 'TensorListFromTensor':\n        {\n          const tensor = getParamValue('tensor', node, tensorMap, context);\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          const elementDtype = getParamValue('elementDType', node, tensorMap, context);\n          const tensorList = fromTensor(tensor, elementShape, elementDtype);\n          context.addTensorList(tensorList);\n          return [tensorList.idTensor];\n        }\n\n      case 'TensorListConcat':\n        {\n          const concatId = getParamValue('tensorListId', node, tensorMap, context);\n          const tensorList = context.getTensorList(concatId.id);\n          const concatDtype = getParamValue('dtype', node, tensorMap, context);\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          return [tensorList.concat(concatDtype, elementShape)];\n        }\n\n      case 'TensorListPushBack':\n        {\n          const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          const writeTensor = getParamValue('tensor', node, tensorMap, context);\n          const tensorList = context.getTensorList(idTensor.id);\n          tensorList.pushBack(writeTensor);\n          return [tensorList.idTensor];\n        }\n\n      case 'TensorListPopBack':\n        {\n          const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          const elementDType = getParamValue('elementDType', node, tensorMap, context);\n          const tensorList = context.getTensorList(idTensor.id);\n          return [tensorList.popBack(elementShape, elementDType)];\n        }\n\n      case 'TensorListSplit':\n        {\n          const splitTensor = getParamValue('tensor', node, tensorMap, context);\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          const lengths = getParamValue('lengths', node, tensorMap, context);\n          const tensorList = split(splitTensor, lengths, elementShape);\n          context.addTensorList(tensorList);\n          return [tensorList.idTensor];\n        }\n\n      default:\n        throw TypeError(`Node type ${node.op} is not implemented`);\n    }\n  });\n\n  return function executeOp(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport const CATEGORY = 'control';","map":{"version":3,"sources":["/Users/ryanliang/Downloads/main_movir_picker/node_modules/@tensorflow/tfjs-converter/dist/operations/executors/control_executor.js"],"names":["scalar","TensorArray","fromTensor","reserve","scatter","split","cloneTensor","getParamValue","getTensor","executeOp","node","tensorMap","context","op","thenFunc","elseFunc","cond","args","condValue","data","functionMap","executeFunctionAsync","tensorArrayMap","tensorListMap","bodyFunc","condFunc","condResult","argIds","map","tensor","id","forEach","kept","indexOf","dispose","result","origResult","resultIds","pred","undefined","inputName","inputNames","find","name","frameId","enterFrame","exitFrame","nextIteration","size","dtype","elementShape","dynamicSize","clearAfterRead","identicalElementShapes","tensorArray","addTensorArray","idTensor","index","writeTensor","writeTensorArray","getTensorArray","write","readId","readIndex","readTensorArray","read","gatherId","gatherIndices","gatherDtype","gatherTensorArray","gather","scatterId","scatterIndices","scatterTensor","scatterTensorArray","concatId","concatTensorArray","concatDtype","concat","splitId","splitTensor","lengths","splitTensorArray","sizeId","sizeTensorArray","closeId","closeTensorArray","clearAndClose","tensorList","getTensorList","setItem","elementDType","getItem","numElements","addTensorList","elementDtype","numElementsParam","stack","pushBack","popBack","TypeError","CATEGORY"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { scalar } from '@tensorflow/tfjs-core';\nimport { TensorArray } from '../../executor/tensor_array';\nimport { fromTensor, reserve, scatter, split } from '../../executor/tensor_list';\nimport { cloneTensor, getParamValue, getTensor } from './utils';\nexport const executeOp = async (node, tensorMap, context) => {\n    switch (node.op) {\n        case 'If':\n        case 'StatelessIf': {\n            const thenFunc = getParamValue('thenBranch', node, tensorMap, context);\n            const elseFunc = getParamValue('elseBranch', node, tensorMap, context);\n            const cond = getParamValue('cond', node, tensorMap, context);\n            const args = getParamValue('args', node, tensorMap, context);\n            const condValue = await cond.data();\n            if (condValue[0]) {\n                return context.functionMap[thenFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);\n            }\n            else {\n                return context.functionMap[elseFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);\n            }\n        }\n        case 'While':\n        case 'StatelessWhile': {\n            const bodyFunc = getParamValue('body', node, tensorMap, context);\n            const condFunc = getParamValue('cond', node, tensorMap, context);\n            const args = getParamValue('args', node, tensorMap, context);\n            // Calculate the condition of the loop\n            const condResult = (await context.functionMap[condFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap));\n            const argIds = args.map(tensor => tensor.id);\n            let condValue = await condResult[0].data();\n            // Dispose the intermediate tensors for condition function\n            condResult.forEach(tensor => {\n                if (!tensor.kept && argIds.indexOf(tensor.id) === -1) {\n                    tensor.dispose();\n                }\n            });\n            let result = args;\n            while (condValue[0]) {\n                // Record the previous result for intermediate tensor tracking\n                const origResult = result;\n                // Execution the body of the loop\n                result = await context.functionMap[bodyFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);\n                const resultIds = result.map(tensor => tensor.id);\n                // Dispose the intermediate tensor for body function that is not global\n                // kept, not input/output of the body function\n                origResult.forEach(tensor => {\n                    if (!tensor.kept && argIds.indexOf(tensor.id) === -1 &&\n                        resultIds.indexOf(tensor.id) === -1) {\n                        tensor.dispose();\n                    }\n                });\n                // Recalcuate the condition of the loop using the latest results.\n                const condResult = (await context.functionMap[condFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap));\n                condValue = await condResult[0].data();\n                // Dispose the intermediate tensors for condition function\n                condResult.forEach(tensor => {\n                    if (!tensor.kept && argIds.indexOf(tensor.id) === -1 &&\n                        resultIds.indexOf(tensor.id) === -1) {\n                        tensor.dispose();\n                    }\n                });\n            }\n            return result;\n        }\n        case 'LoopCond': {\n            const pred = getParamValue('pred', node, tensorMap, context);\n            return [cloneTensor(pred)];\n        }\n        case 'Switch': {\n            const pred = getParamValue('pred', node, tensorMap, context);\n            let data = getParamValue('data', node, tensorMap, context);\n            if (!data.kept) {\n                data = cloneTensor(data);\n            }\n            // Outputs nodes :0 => false, :1 => true\n            return (await pred.data())[0] ? [undefined, data] : [data, undefined];\n        }\n        case 'Merge': {\n            const inputName = node.inputNames.find(name => getTensor(name, tensorMap, context) !== undefined);\n            if (inputName) {\n                const data = getTensor(inputName, tensorMap, context);\n                return [cloneTensor(data)];\n            }\n            return undefined;\n        }\n        case 'Enter': {\n            const frameId = getParamValue('frameName', node, tensorMap, context);\n            const data = getParamValue('tensor', node, tensorMap, context);\n            context.enterFrame(frameId);\n            return [cloneTensor(data)];\n        }\n        case 'Exit': {\n            const data = getParamValue('tensor', node, tensorMap, context);\n            context.exitFrame();\n            return [cloneTensor(data)];\n        }\n        case 'NextIteration': {\n            const data = getParamValue('tensor', node, tensorMap, context);\n            context.nextIteration();\n            return [cloneTensor(data)];\n        }\n        case 'TensorArrayV3': {\n            const size = getParamValue('size', node, tensorMap, context);\n            const dtype = getParamValue('dtype', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const dynamicSize = getParamValue('dynamicSize', node, tensorMap, context);\n            const clearAfterRead = getParamValue('clearAfterRead', node, tensorMap, context);\n            const identicalElementShapes = getParamValue('identicalElementShapes', node, tensorMap, context);\n            const name = getParamValue('name', node, tensorMap, context);\n            const tensorArray = new TensorArray(name, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);\n            context.addTensorArray(tensorArray);\n            return [tensorArray.idTensor, scalar(1.0)];\n        }\n        case 'TensorArrayWriteV3': {\n            const id = getParamValue('tensorArrayId', node, tensorMap, context);\n            const index = getParamValue('index', node, tensorMap, context);\n            const writeTensor = getParamValue('tensor', node, tensorMap, context);\n            const writeTensorArray = context.getTensorArray(id.id);\n            writeTensorArray.write(index, writeTensor);\n            return [writeTensorArray.idTensor];\n        }\n        case 'TensorArrayReadV3': {\n            const readId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const readIndex = getParamValue('index', node, tensorMap, context);\n            const readTensorArray = context.getTensorArray(readId.id);\n            return [readTensorArray.read(readIndex)];\n        }\n        case 'TensorArrayGatherV3': {\n            const gatherId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const gatherIndices = getParamValue('indices', node, tensorMap, context);\n            const gatherDtype = getParamValue('dtype', node, tensorMap, context);\n            const gatherTensorArray = context.getTensorArray(gatherId.id);\n            return [gatherTensorArray.gather(gatherIndices, gatherDtype)];\n        }\n        case 'TensorArrayScatterV3': {\n            const scatterId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const scatterIndices = getParamValue('indices', node, tensorMap, context);\n            const scatterTensor = getParamValue('tensor', node, tensorMap, context);\n            const scatterTensorArray = context.getTensorArray(scatterId.id);\n            scatterTensorArray.scatter(scatterIndices, scatterTensor);\n            return [scatterTensorArray.idTensor];\n        }\n        case 'TensorArrayConcatV3': {\n            const concatId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const concatTensorArray = context.getTensorArray(concatId.id);\n            const concatDtype = getParamValue('dtype', node, tensorMap, context);\n            return [concatTensorArray.concat(concatDtype)];\n        }\n        case 'TensorArraySplitV3': {\n            const splitId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const splitTensor = getParamValue('tensor', node, tensorMap, context);\n            const lengths = getParamValue('lengths', node, tensorMap, context);\n            const splitTensorArray = context.getTensorArray(splitId.id);\n            splitTensorArray.split(lengths, splitTensor);\n            return [splitTensorArray.idTensor];\n        }\n        case 'TensorArraySizeV3': {\n            const sizeId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const sizeTensorArray = context.getTensorArray(sizeId.id);\n            return [scalar(sizeTensorArray.size(), 'int32')];\n        }\n        case 'TensorArrayCloseV3': {\n            const closeId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const closeTensorArray = context.getTensorArray(closeId.id);\n            closeTensorArray.clearAndClose();\n            return [closeTensorArray.idTensor];\n        }\n        case 'TensorListSetItem': {\n            const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n            const index = getParamValue('index', node, tensorMap, context);\n            const writeTensor = getParamValue('tensor', node, tensorMap, context);\n            const tensorList = context.getTensorList(idTensor.id);\n            tensorList.setItem(index, writeTensor);\n            return [tensorList.idTensor];\n        }\n        case 'TensorListGetItem': {\n            const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n            const readIndex = getParamValue('index', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const elementDType = getParamValue('elementDType', node, tensorMap, context);\n            const tensorList = context.getTensorList(idTensor.id);\n            return [tensorList.getItem(readIndex, elementShape, elementDType)];\n        }\n        case 'TensorListScatterV2':\n        case 'TensorListScatter': {\n            const scatterIndices = getParamValue('indices', node, tensorMap, context);\n            const scatterTensor = getParamValue('tensor', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const numElements = getParamValue('numElements', node, tensorMap, context);\n            const tensorList = scatter(scatterTensor, scatterIndices, elementShape, numElements);\n            context.addTensorList(tensorList);\n            return [tensorList.idTensor];\n        }\n        case 'TensorListReserve':\n        case 'EmptyTensorList': {\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const elementDtype = getParamValue('elementDType', node, tensorMap, context);\n            let numElementsParam;\n            if (node.op === 'TensorListReserve') {\n                numElementsParam = 'numElements';\n            }\n            else {\n                numElementsParam = 'maxNumElements';\n            }\n            const numElements = getParamValue(numElementsParam, node, tensorMap, context);\n            const tensorList = reserve(elementShape, elementDtype, numElements);\n            context.addTensorList(tensorList);\n            return [tensorList.idTensor];\n        }\n        case 'TensorListGather': {\n            const gatherId = getParamValue('tensorListId', node, tensorMap, context);\n            const gatherIndices = getParamValue('indices', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const elementDtype = getParamValue('elementDType', node, tensorMap, context);\n            const tensorList = context.getTensorList(gatherId.id);\n            return [tensorList.gather(gatherIndices, elementDtype, elementShape)];\n        }\n        case 'TensorListStack': {\n            const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const elementDtype = getParamValue('elementDType', node, tensorMap, context);\n            const numElements = getParamValue('numElements', node, tensorMap, context);\n            const tensorList = context.getTensorList(idTensor.id);\n            return [tensorList.stack(elementShape, elementDtype, numElements)];\n        }\n        case 'TensorListFromTensor': {\n            const tensor = getParamValue('tensor', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const elementDtype = getParamValue('elementDType', node, tensorMap, context);\n            const tensorList = fromTensor(tensor, elementShape, elementDtype);\n            context.addTensorList(tensorList);\n            return [tensorList.idTensor];\n        }\n        case 'TensorListConcat': {\n            const concatId = getParamValue('tensorListId', node, tensorMap, context);\n            const tensorList = context.getTensorList(concatId.id);\n            const concatDtype = getParamValue('dtype', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            return [tensorList.concat(concatDtype, elementShape)];\n        }\n        case 'TensorListPushBack': {\n            const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n            const writeTensor = getParamValue('tensor', node, tensorMap, context);\n            const tensorList = context.getTensorList(idTensor.id);\n            tensorList.pushBack(writeTensor);\n            return [tensorList.idTensor];\n        }\n        case 'TensorListPopBack': {\n            const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const elementDType = getParamValue('elementDType', node, tensorMap, context);\n            const tensorList = context.getTensorList(idTensor.id);\n            return [tensorList.popBack(elementShape, elementDType)];\n        }\n        case 'TensorListSplit': {\n            const splitTensor = getParamValue('tensor', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const lengths = getParamValue('lengths', node, tensorMap, context);\n            const tensorList = split(splitTensor, lengths, elementShape);\n            context.addTensorList(tensorList);\n            return [tensorList.idTensor];\n        }\n        default:\n            throw TypeError(`Node type ${node.op} is not implemented`);\n    }\n};\nexport const CATEGORY = 'control';\n"]},"metadata":{},"sourceType":"module"}
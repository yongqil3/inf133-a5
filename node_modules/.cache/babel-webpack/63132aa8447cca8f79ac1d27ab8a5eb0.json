{"ast":null,"code":"import _asyncToGenerator from \"/Users/ryanliang/Downloads/main_movir_picker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { browser, cast, env, expandDims, image, reshape, tensor1d, tensor2d, tidy, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of image tensors from webcam video stream. Only works in\n * browser environment.\n */\n\nexport class WebcamIterator extends LazyIterator {\n  constructor(webcamVideoElement, webcamConfig) {\n    super();\n    this.webcamVideoElement = webcamVideoElement;\n    this.webcamConfig = webcamConfig;\n    this.isClosed = true;\n    this.resize = false;\n\n    if (this.needToResize()) {\n      this.resize = true;\n      this.cropSize = [this.webcamConfig.resizeHeight, this.webcamConfig.resizeWidth];\n      this.cropBoxInd = tensor1d([0], 'int32');\n\n      if (this.webcamConfig.centerCrop) {\n        // Calculate the box based on resizing shape.\n        const widthCroppingRatio = this.webcamConfig.resizeWidth * 1.0 / this.webcamVideoElement.width;\n        const heightCroppingRatio = this.webcamConfig.resizeHeight * 1.0 / this.webcamVideoElement.height;\n        const widthCropStart = (1 - widthCroppingRatio) / 2;\n        const heightCropStart = (1 - heightCroppingRatio) / 2;\n        const widthCropEnd = widthCropStart + widthCroppingRatio;\n        const heightCropEnd = heightCroppingRatio + heightCropStart;\n        this.cropBox = tensor2d([heightCropStart, widthCropStart, heightCropEnd, widthCropEnd], [1, 4]);\n      } else {\n        this.cropBox = tensor2d([0, 0, 1, 1], [1, 4]);\n      }\n    }\n  }\n\n  summary() {\n    return `webcam`;\n  } // Construct a WebcamIterator and start it's video stream.\n\n\n  static create(webcamVideoElement, webcamConfig = {}) {\n    return _asyncToGenerator(function* () {\n      if (env().get('IS_NODE')) {\n        throw new Error('tf.data.webcam is only supported in browser environment.');\n      }\n\n      if (!webcamVideoElement) {\n        // If webcam video element is not provided, create a hidden video element\n        // with provided width and height.\n        webcamVideoElement = document.createElement('video');\n\n        if (!webcamConfig.resizeWidth || !webcamConfig.resizeHeight) {\n          throw new Error('Please provide webcam video element, or resizeWidth and ' + 'resizeHeight to create a hidden video element.');\n        }\n\n        webcamVideoElement.width = webcamConfig.resizeWidth;\n        webcamVideoElement.height = webcamConfig.resizeHeight;\n      }\n\n      const webcamIterator = new WebcamIterator(webcamVideoElement, webcamConfig); // Call async function to initialize the video stream.\n\n      yield webcamIterator.start();\n      return webcamIterator;\n    })();\n  } // Async function to start video stream.\n\n\n  start() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.webcamConfig.facingMode) {\n        util.assert(_this.webcamConfig.facingMode === 'user' || _this.webcamConfig.facingMode === 'environment', () => `Invalid webcam facing mode: ${_this.webcamConfig.facingMode}. ` + `Please provide 'user' or 'environment'`);\n      }\n\n      try {\n        _this.stream = yield navigator.mediaDevices.getUserMedia({\n          video: {\n            deviceId: _this.webcamConfig.deviceId,\n            facingMode: _this.webcamConfig.facingMode ? _this.webcamConfig.facingMode : 'user',\n            width: _this.webcamVideoElement.width,\n            height: _this.webcamVideoElement.height\n          }\n        });\n      } catch (e) {\n        // Modify the error message but leave the stack trace intact\n        e.message = `Error thrown while initializing video stream: ${e.message}`;\n        throw e;\n      }\n\n      if (!_this.stream) {\n        throw new Error('Could not obtain video from webcam.');\n      } // Older browsers may not have srcObject\n\n\n      try {\n        _this.webcamVideoElement.srcObject = _this.stream;\n      } catch (error) {\n        console.log(error);\n        _this.webcamVideoElement.src = window.URL.createObjectURL(_this.stream);\n      } // Start the webcam video stream\n\n\n      _this.webcamVideoElement.play();\n\n      _this.isClosed = false;\n      return new Promise(resolve => {\n        // Add event listener to make sure the webcam has been fully initialized.\n        _this.webcamVideoElement.onloadedmetadata = () => {\n          resolve();\n        };\n      });\n    })();\n  }\n\n  next() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2.isClosed) {\n        return {\n          value: null,\n          done: true\n        };\n      }\n\n      let img;\n\n      try {\n        img = browser.fromPixels(_this2.webcamVideoElement);\n      } catch (e) {\n        throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`);\n      }\n\n      if (_this2.resize) {\n        try {\n          return {\n            value: _this2.cropAndResizeFrame(img),\n            done: false\n          };\n        } catch (e) {\n          throw new Error(`Error thrown cropping the video: ${e.message}`);\n        } finally {\n          img.dispose();\n        }\n      } else {\n        return {\n          value: img,\n          done: false\n        };\n      }\n    })();\n  }\n\n  needToResize() {\n    // If resizeWidth and resizeHeight are provided, and different from the\n    // width and height of original HTMLVideoElement, then resizing and cropping\n    // is required.\n    if (this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight && (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth || this.webcamVideoElement.height !== this.webcamConfig.resizeHeight)) {\n      return true;\n    }\n\n    return false;\n  } // Cropping and resizing each frame based on config\n\n\n  cropAndResizeFrame(img) {\n    return tidy(() => {\n      const expandedImage = expandDims(cast(img, 'float32'), 0);\n      let resizedImage;\n      resizedImage = image.cropAndResize(expandedImage, this.cropBox, this.cropBoxInd, this.cropSize, 'bilinear'); // Extract image from batch cropping.\n\n      const shape = resizedImage.shape;\n      return reshape(resizedImage, shape.slice(1));\n    });\n  } // Capture one frame from the video stream, and extract the value from\n  // iterator.next() result.\n\n\n  capture() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this3.next()).value;\n    })();\n  } // Stop the video stream and pause webcam iterator.\n\n\n  stop() {\n    const tracks = this.stream.getTracks();\n    tracks.forEach(track => track.stop());\n\n    try {\n      this.webcamVideoElement.srcObject = null;\n    } catch (error) {\n      console.log(error);\n      this.webcamVideoElement.src = null;\n    }\n\n    this.isClosed = true;\n  } // Override toArray() function to prevent collecting.\n\n\n  toArray() {\n    throw new Error('Can not convert infinite video stream to array.');\n  }\n\n}","map":{"version":3,"sources":["/Users/ryanliang/Downloads/main_movir_picker/node_modules/@tensorflow/tfjs-data/dist/iterators/webcam_iterator.js"],"names":["browser","cast","env","expandDims","image","reshape","tensor1d","tensor2d","tidy","util","LazyIterator","WebcamIterator","constructor","webcamVideoElement","webcamConfig","isClosed","resize","needToResize","cropSize","resizeHeight","resizeWidth","cropBoxInd","centerCrop","widthCroppingRatio","width","heightCroppingRatio","height","widthCropStart","heightCropStart","widthCropEnd","heightCropEnd","cropBox","summary","create","get","Error","document","createElement","webcamIterator","start","facingMode","assert","stream","navigator","mediaDevices","getUserMedia","video","deviceId","e","message","srcObject","error","console","log","src","window","URL","createObjectURL","play","Promise","resolve","onloadedmetadata","next","value","done","img","fromPixels","JSON","stringify","cropAndResizeFrame","dispose","expandedImage","resizedImage","cropAndResize","shape","slice","capture","stop","tracks","getTracks","forEach","track","toArray"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,OAAT,EAAkBC,IAAlB,EAAwBC,GAAxB,EAA6BC,UAA7B,EAAyCC,KAAzC,EAAgDC,OAAhD,EAAyDC,QAAzD,EAAmEC,QAAnE,EAA6EC,IAA7E,EAAmFC,IAAnF,QAA+F,uBAA/F;AACA,SAASC,YAAT,QAA6B,iBAA7B;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,cAAN,SAA6BD,YAA7B,CAA0C;AAC7CE,EAAAA,WAAW,CAACC,kBAAD,EAAqBC,YAArB,EAAmC;AAC1C;AACA,SAAKD,kBAAL,GAA0BA,kBAA1B;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKC,QAAL,GAAgB,IAAhB;AACA,SAAKC,MAAL,GAAc,KAAd;;AACA,QAAI,KAAKC,YAAL,EAAJ,EAAyB;AACrB,WAAKD,MAAL,GAAc,IAAd;AACA,WAAKE,QAAL,GACI,CAAC,KAAKJ,YAAL,CAAkBK,YAAnB,EAAiC,KAAKL,YAAL,CAAkBM,WAAnD,CADJ;AAEA,WAAKC,UAAL,GAAkBf,QAAQ,CAAC,CAAC,CAAD,CAAD,EAAM,OAAN,CAA1B;;AACA,UAAI,KAAKQ,YAAL,CAAkBQ,UAAtB,EAAkC;AAC9B;AACA,cAAMC,kBAAkB,GAAG,KAAKT,YAAL,CAAkBM,WAAlB,GAAgC,GAAhC,GAAsC,KAAKP,kBAAL,CAAwBW,KAAzF;AACA,cAAMC,mBAAmB,GAAG,KAAKX,YAAL,CAAkBK,YAAlB,GAAiC,GAAjC,GACxB,KAAKN,kBAAL,CAAwBa,MAD5B;AAEA,cAAMC,cAAc,GAAG,CAAC,IAAIJ,kBAAL,IAA2B,CAAlD;AACA,cAAMK,eAAe,GAAG,CAAC,IAAIH,mBAAL,IAA4B,CAApD;AACA,cAAMI,YAAY,GAAGF,cAAc,GAAGJ,kBAAtC;AACA,cAAMO,aAAa,GAAGL,mBAAmB,GAAGG,eAA5C;AACA,aAAKG,OAAL,GAAexB,QAAQ,CAAC,CAACqB,eAAD,EAAkBD,cAAlB,EAAkCG,aAAlC,EAAiDD,YAAjD,CAAD,EAAiE,CAAC,CAAD,EAAI,CAAJ,CAAjE,CAAvB;AACH,OAVD,MAWK;AACD,aAAKE,OAAL,GAAexB,QAAQ,CAAC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAD,EAAe,CAAC,CAAD,EAAI,CAAJ,CAAf,CAAvB;AACH;AACJ;AACJ;;AACDyB,EAAAA,OAAO,GAAG;AACN,WAAQ,QAAR;AACH,GA9B4C,CA+B7C;;;AACmB,SAANC,MAAM,CAACpB,kBAAD,EAAqBC,YAAY,GAAG,EAApC,EAAwC;AAAA;AACvD,UAAIZ,GAAG,GAAGgC,GAAN,CAAU,SAAV,CAAJ,EAA0B;AACtB,cAAM,IAAIC,KAAJ,CAAU,0DAAV,CAAN;AACH;;AACD,UAAI,CAACtB,kBAAL,EAAyB;AACrB;AACA;AACAA,QAAAA,kBAAkB,GAAGuB,QAAQ,CAACC,aAAT,CAAuB,OAAvB,CAArB;;AACA,YAAI,CAACvB,YAAY,CAACM,WAAd,IAA6B,CAACN,YAAY,CAACK,YAA/C,EAA6D;AACzD,gBAAM,IAAIgB,KAAJ,CAAU,6DACZ,gDADE,CAAN;AAEH;;AACDtB,QAAAA,kBAAkB,CAACW,KAAnB,GAA2BV,YAAY,CAACM,WAAxC;AACAP,QAAAA,kBAAkB,CAACa,MAAnB,GAA4BZ,YAAY,CAACK,YAAzC;AACH;;AACD,YAAMmB,cAAc,GAAG,IAAI3B,cAAJ,CAAmBE,kBAAnB,EAAuCC,YAAvC,CAAvB,CAfuD,CAgBvD;;AACA,YAAMwB,cAAc,CAACC,KAAf,EAAN;AACA,aAAOD,cAAP;AAlBuD;AAmB1D,GAnD4C,CAoD7C;;;AACMC,EAAAA,KAAK,GAAG;AAAA;;AAAA;AACV,UAAI,KAAI,CAACzB,YAAL,CAAkB0B,UAAtB,EAAkC;AAC9B/B,QAAAA,IAAI,CAACgC,MAAL,CAAa,KAAI,CAAC3B,YAAL,CAAkB0B,UAAlB,KAAiC,MAAlC,IACP,KAAI,CAAC1B,YAAL,CAAkB0B,UAAlB,KAAiC,aADtC,EACsD,MAAO,+BAA8B,KAAI,CAAC1B,YAAL,CAAkB0B,UAAW,IAA5D,GACvD,wCAFL;AAGH;;AACD,UAAI;AACA,QAAA,KAAI,CAACE,MAAL,SAAoBC,SAAS,CAACC,YAAV,CAAuBC,YAAvB,CAAoC;AACpDC,UAAAA,KAAK,EAAE;AACHC,YAAAA,QAAQ,EAAE,KAAI,CAACjC,YAAL,CAAkBiC,QADzB;AAEHP,YAAAA,UAAU,EAAE,KAAI,CAAC1B,YAAL,CAAkB0B,UAAlB,GACR,KAAI,CAAC1B,YAAL,CAAkB0B,UADV,GAER,MAJD;AAKHhB,YAAAA,KAAK,EAAE,KAAI,CAACX,kBAAL,CAAwBW,KAL5B;AAMHE,YAAAA,MAAM,EAAE,KAAI,CAACb,kBAAL,CAAwBa;AAN7B;AAD6C,SAApC,CAApB;AAUH,OAXD,CAYA,OAAOsB,CAAP,EAAU;AACN;AACAA,QAAAA,CAAC,CAACC,OAAF,GAAa,iDAAgDD,CAAC,CAACC,OAAQ,EAAvE;AACA,cAAMD,CAAN;AACH;;AACD,UAAI,CAAC,KAAI,CAACN,MAAV,EAAkB;AACd,cAAM,IAAIP,KAAJ,CAAU,qCAAV,CAAN;AACH,OAzBS,CA0BV;;;AACA,UAAI;AACA,QAAA,KAAI,CAACtB,kBAAL,CAAwBqC,SAAxB,GAAoC,KAAI,CAACR,MAAzC;AACH,OAFD,CAGA,OAAOS,KAAP,EAAc;AACVC,QAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACA,QAAA,KAAI,CAACtC,kBAAL,CAAwByC,GAAxB,GAA8BC,MAAM,CAACC,GAAP,CAAWC,eAAX,CAA2B,KAAI,CAACf,MAAhC,CAA9B;AACH,OAjCS,CAkCV;;;AACA,MAAA,KAAI,CAAC7B,kBAAL,CAAwB6C,IAAxB;;AACA,MAAA,KAAI,CAAC3C,QAAL,GAAgB,KAAhB;AACA,aAAO,IAAI4C,OAAJ,CAAYC,OAAO,IAAI;AAC1B;AACA,QAAA,KAAI,CAAC/C,kBAAL,CAAwBgD,gBAAxB,GAA2C,MAAM;AAC7CD,UAAAA,OAAO;AACV,SAFD;AAGH,OALM,CAAP;AArCU;AA2Cb;;AACKE,EAAAA,IAAI,GAAG;AAAA;;AAAA;AACT,UAAI,MAAI,CAAC/C,QAAT,EAAmB;AACf,eAAO;AAAEgD,UAAAA,KAAK,EAAE,IAAT;AAAeC,UAAAA,IAAI,EAAE;AAArB,SAAP;AACH;;AACD,UAAIC,GAAJ;;AACA,UAAI;AACAA,QAAAA,GAAG,GAAGjE,OAAO,CAACkE,UAAR,CAAmB,MAAI,CAACrD,kBAAxB,CAAN;AACH,OAFD,CAGA,OAAOmC,CAAP,EAAU;AACN,cAAM,IAAIb,KAAJ,CAAW,4CAA2CgC,IAAI,CAACC,SAAL,CAAepB,CAAf,CAAkB,EAAxE,CAAN;AACH;;AACD,UAAI,MAAI,CAAChC,MAAT,EAAiB;AACb,YAAI;AACA,iBAAO;AAAE+C,YAAAA,KAAK,EAAE,MAAI,CAACM,kBAAL,CAAwBJ,GAAxB,CAAT;AAAuCD,YAAAA,IAAI,EAAE;AAA7C,WAAP;AACH,SAFD,CAGA,OAAOhB,CAAP,EAAU;AACN,gBAAM,IAAIb,KAAJ,CAAW,oCAAmCa,CAAC,CAACC,OAAQ,EAAxD,CAAN;AACH,SALD,SAMQ;AACJgB,UAAAA,GAAG,CAACK,OAAJ;AACH;AACJ,OAVD,MAWK;AACD,eAAO;AAAEP,UAAAA,KAAK,EAAEE,GAAT;AAAcD,UAAAA,IAAI,EAAE;AAApB,SAAP;AACH;AAxBQ;AAyBZ;;AACD/C,EAAAA,YAAY,GAAG;AACX;AACA;AACA;AACA,QAAI,KAAKH,YAAL,CAAkBM,WAAlB,IAAiC,KAAKN,YAAL,CAAkBK,YAAnD,KACC,KAAKN,kBAAL,CAAwBW,KAAxB,KAAkC,KAAKV,YAAL,CAAkBM,WAApD,IACG,KAAKP,kBAAL,CAAwBa,MAAxB,KAAmC,KAAKZ,YAAL,CAAkBK,YAFzD,CAAJ,EAE4E;AACxE,aAAO,IAAP;AACH;;AACD,WAAO,KAAP;AACH,GArI4C,CAsI7C;;;AACAkD,EAAAA,kBAAkB,CAACJ,GAAD,EAAM;AACpB,WAAOzD,IAAI,CAAC,MAAM;AACd,YAAM+D,aAAa,GAAGpE,UAAU,CAACF,IAAI,CAACgE,GAAD,EAAM,SAAN,CAAL,EAAwB,CAAxB,CAAhC;AACA,UAAIO,YAAJ;AACAA,MAAAA,YAAY,GAAGpE,KAAK,CAACqE,aAAN,CAAoBF,aAApB,EAAmC,KAAKxC,OAAxC,EAAiD,KAAKV,UAAtD,EAAkE,KAAKH,QAAvE,EAAiF,UAAjF,CAAf,CAHc,CAId;;AACA,YAAMwD,KAAK,GAAGF,YAAY,CAACE,KAA3B;AACA,aAAOrE,OAAO,CAACmE,YAAD,EAAeE,KAAK,CAACC,KAAN,CAAY,CAAZ,CAAf,CAAd;AACH,KAPU,CAAX;AAQH,GAhJ4C,CAiJ7C;AACA;;;AACMC,EAAAA,OAAO,GAAG;AAAA;;AAAA;AACZ,aAAO,OAAO,MAAI,CAACd,IAAL,EAAP,EAAoBC,KAA3B;AADY;AAEf,GArJ4C,CAsJ7C;;;AACAc,EAAAA,IAAI,GAAG;AACH,UAAMC,MAAM,GAAG,KAAKpC,MAAL,CAAYqC,SAAZ,EAAf;AACAD,IAAAA,MAAM,CAACE,OAAP,CAAeC,KAAK,IAAIA,KAAK,CAACJ,IAAN,EAAxB;;AACA,QAAI;AACA,WAAKhE,kBAAL,CAAwBqC,SAAxB,GAAoC,IAApC;AACH,KAFD,CAGA,OAAOC,KAAP,EAAc;AACVC,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACA,WAAKtC,kBAAL,CAAwByC,GAAxB,GAA8B,IAA9B;AACH;;AACD,SAAKvC,QAAL,GAAgB,IAAhB;AACH,GAlK4C,CAmK7C;;;AACAmE,EAAAA,OAAO,GAAG;AACN,UAAM,IAAI/C,KAAJ,CAAU,iDAAV,CAAN;AACH;;AAtK4C","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { browser, cast, env, expandDims, image, reshape, tensor1d, tensor2d, tidy, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of image tensors from webcam video stream. Only works in\n * browser environment.\n */\nexport class WebcamIterator extends LazyIterator {\n    constructor(webcamVideoElement, webcamConfig) {\n        super();\n        this.webcamVideoElement = webcamVideoElement;\n        this.webcamConfig = webcamConfig;\n        this.isClosed = true;\n        this.resize = false;\n        if (this.needToResize()) {\n            this.resize = true;\n            this.cropSize =\n                [this.webcamConfig.resizeHeight, this.webcamConfig.resizeWidth];\n            this.cropBoxInd = tensor1d([0], 'int32');\n            if (this.webcamConfig.centerCrop) {\n                // Calculate the box based on resizing shape.\n                const widthCroppingRatio = this.webcamConfig.resizeWidth * 1.0 / this.webcamVideoElement.width;\n                const heightCroppingRatio = this.webcamConfig.resizeHeight * 1.0 /\n                    this.webcamVideoElement.height;\n                const widthCropStart = (1 - widthCroppingRatio) / 2;\n                const heightCropStart = (1 - heightCroppingRatio) / 2;\n                const widthCropEnd = widthCropStart + widthCroppingRatio;\n                const heightCropEnd = heightCroppingRatio + heightCropStart;\n                this.cropBox = tensor2d([heightCropStart, widthCropStart, heightCropEnd, widthCropEnd], [1, 4]);\n            }\n            else {\n                this.cropBox = tensor2d([0, 0, 1, 1], [1, 4]);\n            }\n        }\n    }\n    summary() {\n        return `webcam`;\n    }\n    // Construct a WebcamIterator and start it's video stream.\n    static async create(webcamVideoElement, webcamConfig = {}) {\n        if (env().get('IS_NODE')) {\n            throw new Error('tf.data.webcam is only supported in browser environment.');\n        }\n        if (!webcamVideoElement) {\n            // If webcam video element is not provided, create a hidden video element\n            // with provided width and height.\n            webcamVideoElement = document.createElement('video');\n            if (!webcamConfig.resizeWidth || !webcamConfig.resizeHeight) {\n                throw new Error('Please provide webcam video element, or resizeWidth and ' +\n                    'resizeHeight to create a hidden video element.');\n            }\n            webcamVideoElement.width = webcamConfig.resizeWidth;\n            webcamVideoElement.height = webcamConfig.resizeHeight;\n        }\n        const webcamIterator = new WebcamIterator(webcamVideoElement, webcamConfig);\n        // Call async function to initialize the video stream.\n        await webcamIterator.start();\n        return webcamIterator;\n    }\n    // Async function to start video stream.\n    async start() {\n        if (this.webcamConfig.facingMode) {\n            util.assert((this.webcamConfig.facingMode === 'user') ||\n                (this.webcamConfig.facingMode === 'environment'), () => `Invalid webcam facing mode: ${this.webcamConfig.facingMode}. ` +\n                `Please provide 'user' or 'environment'`);\n        }\n        try {\n            this.stream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    deviceId: this.webcamConfig.deviceId,\n                    facingMode: this.webcamConfig.facingMode ?\n                        this.webcamConfig.facingMode :\n                        'user',\n                    width: this.webcamVideoElement.width,\n                    height: this.webcamVideoElement.height\n                }\n            });\n        }\n        catch (e) {\n            // Modify the error message but leave the stack trace intact\n            e.message = `Error thrown while initializing video stream: ${e.message}`;\n            throw e;\n        }\n        if (!this.stream) {\n            throw new Error('Could not obtain video from webcam.');\n        }\n        // Older browsers may not have srcObject\n        try {\n            this.webcamVideoElement.srcObject = this.stream;\n        }\n        catch (error) {\n            console.log(error);\n            this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);\n        }\n        // Start the webcam video stream\n        this.webcamVideoElement.play();\n        this.isClosed = false;\n        return new Promise(resolve => {\n            // Add event listener to make sure the webcam has been fully initialized.\n            this.webcamVideoElement.onloadedmetadata = () => {\n                resolve();\n            };\n        });\n    }\n    async next() {\n        if (this.isClosed) {\n            return { value: null, done: true };\n        }\n        let img;\n        try {\n            img = browser.fromPixels(this.webcamVideoElement);\n        }\n        catch (e) {\n            throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`);\n        }\n        if (this.resize) {\n            try {\n                return { value: this.cropAndResizeFrame(img), done: false };\n            }\n            catch (e) {\n                throw new Error(`Error thrown cropping the video: ${e.message}`);\n            }\n            finally {\n                img.dispose();\n            }\n        }\n        else {\n            return { value: img, done: false };\n        }\n    }\n    needToResize() {\n        // If resizeWidth and resizeHeight are provided, and different from the\n        // width and height of original HTMLVideoElement, then resizing and cropping\n        // is required.\n        if (this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight &&\n            (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth ||\n                this.webcamVideoElement.height !== this.webcamConfig.resizeHeight)) {\n            return true;\n        }\n        return false;\n    }\n    // Cropping and resizing each frame based on config\n    cropAndResizeFrame(img) {\n        return tidy(() => {\n            const expandedImage = expandDims(cast(img, 'float32'), (0));\n            let resizedImage;\n            resizedImage = image.cropAndResize(expandedImage, this.cropBox, this.cropBoxInd, this.cropSize, 'bilinear');\n            // Extract image from batch cropping.\n            const shape = resizedImage.shape;\n            return reshape(resizedImage, shape.slice(1));\n        });\n    }\n    // Capture one frame from the video stream, and extract the value from\n    // iterator.next() result.\n    async capture() {\n        return (await this.next()).value;\n    }\n    // Stop the video stream and pause webcam iterator.\n    stop() {\n        const tracks = this.stream.getTracks();\n        tracks.forEach(track => track.stop());\n        try {\n            this.webcamVideoElement.srcObject = null;\n        }\n        catch (error) {\n            console.log(error);\n            this.webcamVideoElement.src = null;\n        }\n        this.isClosed = true;\n    }\n    // Override toArray() function to prevent collecting.\n    toArray() {\n        throw new Error('Can not convert infinite video stream to array.');\n    }\n}\n"]},"metadata":{},"sourceType":"module"}
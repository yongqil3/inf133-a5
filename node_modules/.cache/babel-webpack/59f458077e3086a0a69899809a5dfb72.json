{"ast":null,"code":"import _asyncToGenerator from \"/Users/ryanliang/Downloads/main_movir_picker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext, setWebGLContext } from './canvas_util';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport class GPGPUContext {\n  constructor(gl) {\n    this.outputTexture = null;\n    this.program = null;\n    this.disposed = false;\n    this.vertexAttrsAreBound = false;\n    this.itemsToPoll = [];\n    const glVersion = env().getNumber('WEBGL_VERSION');\n\n    if (gl != null) {\n      this.gl = gl;\n      setWebGLContext(glVersion, gl);\n    } else {\n      this.gl = getWebGLContext(glVersion);\n    } // WebGL 2.0 enables texture floats without an extension.\n\n\n    let COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n      const TEXTURE_FLOAT = 'OES_texture_float';\n      const TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n      this.textureFloatExtension = webgl_util.getExtensionOrThrow(this.gl, TEXTURE_FLOAT);\n\n      if (webgl_util.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n        this.textureHalfFloatExtension = webgl_util.getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error('GL context does not support half float textures, yet the ' + 'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n\n      this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension = webgl_util.getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error('GL context does not support color renderable half floats, yet ' + 'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n    } else {\n      COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n        this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      } else if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension = this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      } else {\n        throw new Error('GL context does not support color renderable floats');\n      }\n    }\n\n    this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);\n    this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);\n    this.framebuffer = webgl_util.createFramebuffer(this.gl);\n    this.textureConfig = tex_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);\n  }\n\n  get debug() {\n    return env().getBool('DEBUG');\n  }\n\n  dispose() {\n    if (this.disposed) {\n      return;\n    }\n\n    if (this.program != null) {\n      console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' + ' This is probably a resource leak, delete the program with ' + 'GPGPUContext.deleteProgram before disposing.');\n    }\n\n    if (this.outputTexture != null) {\n      console.warn('Disposing a GPGPUContext that still has a bound output matrix ' + 'texture.  This is probably a resource leak, delete the output ' + 'matrix texture with GPGPUContext.deleteMatrixTexture before ' + 'disposing.');\n    }\n\n    const gl = this.gl;\n    webgl_util.callAndCheck(gl, () => gl.finish());\n    webgl_util.callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));\n    this.disposed = true;\n  }\n\n  createFloat32MatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n\n  createFloat16MatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n\n  createUnsignedBytesMatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n\n  uploadPixelDataToTexture(texture, pixels) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);\n  }\n\n  uploadDenseMatrixToTexture(texture, width, height, data) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);\n  }\n\n  createFloat16PackedMatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n\n  createPackedMatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n\n  deleteMatrixTexture(texture) {\n    this.throwIfDisposed();\n\n    if (this.outputTexture === texture) {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n      this.outputTexture = null;\n    }\n\n    webgl_util.callAndCheck(this.gl, () => this.gl.deleteTexture(texture));\n  }\n\n  downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {\n    return this.downloadMatrixDriver(texture, () => gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(this.gl, rows, columns, this.textureConfig));\n  }\n\n  downloadPackedMatrixFromBuffer(buffer, batch, rows, columns, physicalRows, physicalCols) {\n    return gpgpu_util.downloadPackedMatrixFromBuffer(this.gl, buffer, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);\n  }\n\n  downloadFloat32MatrixFromBuffer(buffer, size) {\n    return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n  }\n\n  createBufferFromTexture(texture, rows, columns) {\n    this.bindTextureToFrameBuffer(texture);\n    const result = gpgpu_util.createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);\n    this.unbindTextureToFrameBuffer();\n    return result;\n  }\n\n  createAndWaitForFence() {\n    const fenceContext = this.createFence(this.gl);\n    return this.pollFence(fenceContext);\n  }\n\n  createFence(gl) {\n    let query;\n    let isFencePassed;\n\n    if (env().getBool('WEBGL_FENCE_API_ENABLED')) {\n      const gl2 = gl;\n      const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n      gl.flush();\n\n      isFencePassed = () => {\n        const status = gl2.clientWaitSync(sync, 0, 0);\n        return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;\n      };\n\n      query = sync;\n    } else if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n      query = this.beginQuery();\n      this.endQuery();\n\n      isFencePassed = () => this.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n    } else {\n      // If we have no way to fence, return true immediately. This will fire in\n      // WebGL 1.0 when there is no disjoint query timer. In this case, because\n      // the fence passes immediately, we'll immediately ask for a download of\n      // the texture, which will cause the UI thread to hang.\n      isFencePassed = () => true;\n    }\n\n    return {\n      query,\n      isFencePassed\n    };\n  }\n\n  downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {\n    return this.downloadMatrixDriver(texture, () => gpgpu_util.downloadMatrixFromPackedOutputTexture(this.gl, physicalRows, physicalCols));\n  }\n\n  createProgram(fragmentShaderSource) {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    const fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);\n    const vertexShader = gpgpu_util.createVertexShader(gl);\n    const program = webgl_util.createProgram(gl);\n    webgl_util.callAndCheck(gl, () => gl.attachShader(program, vertexShader));\n    webgl_util.callAndCheck(gl, () => gl.attachShader(program, fragmentShader));\n    webgl_util.linkProgram(gl, program);\n\n    if (this.debug) {\n      webgl_util.validateProgram(gl, program);\n    }\n\n    if (!this.vertexAttrsAreBound) {\n      this.setProgram(program);\n      this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);\n    }\n\n    return program;\n  }\n\n  deleteProgram(program) {\n    this.throwIfDisposed();\n\n    if (program === this.program) {\n      this.program = null;\n    }\n\n    if (program != null) {\n      webgl_util.callAndCheck(this.gl, () => this.gl.deleteProgram(program));\n    }\n  }\n\n  setProgram(program) {\n    this.throwIfDisposed();\n    this.program = program;\n\n    if (this.program != null && this.debug) {\n      webgl_util.validateProgram(this.gl, this.program);\n    }\n\n    webgl_util.callAndCheck(this.gl, () => this.gl.useProgram(program));\n  }\n\n  getUniformLocation(program, uniformName, shouldThrow = true) {\n    this.throwIfDisposed();\n\n    if (shouldThrow) {\n      return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);\n    } else {\n      return webgl_util.getProgramUniformLocation(this.gl, program, uniformName);\n    }\n  }\n\n  getAttributeLocation(program, attribute) {\n    this.throwIfDisposed();\n    return webgl_util.callAndCheck(this.gl, () => this.gl.getAttribLocation(program, attribute));\n  }\n\n  getUniformLocationNoThrow(program, uniformName) {\n    this.throwIfDisposed();\n    return this.gl.getUniformLocation(program, uniformName);\n  }\n\n  setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    webgl_util.bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);\n  }\n\n  setOutputMatrixTexture(outputMatrixTexture, rows, columns) {\n    this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n  }\n\n  setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {\n    this.throwIfDisposed();\n    const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n  }\n\n  setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n    this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);\n  }\n\n  setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n    throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n  }\n\n  debugValidate() {\n    if (this.program != null) {\n      webgl_util.validateProgram(this.gl, this.program);\n    }\n\n    webgl_util.validateFramebuffer(this.gl);\n  }\n\n  executeProgram() {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    const gl = this.gl;\n\n    if (this.debug) {\n      this.debugValidate();\n    }\n\n    webgl_util.callAndCheck(gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));\n  }\n\n  blockUntilAllProgramsCompleted() {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(this.gl, () => this.gl.finish());\n  }\n\n  getQueryTimerExtension() {\n    if (this.disjointQueryTimerExtension == null) {\n      this.disjointQueryTimerExtension = webgl_util.getExtensionOrThrow(this.gl, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ? 'EXT_disjoint_timer_query_webgl2' : 'EXT_disjoint_timer_query');\n    }\n\n    return this.disjointQueryTimerExtension;\n  }\n\n  getQueryTimerExtensionWebGL2() {\n    return this.getQueryTimerExtension();\n  }\n\n  getQueryTimerExtensionWebGL1() {\n    return this.getQueryTimerExtension();\n  }\n\n  beginQuery() {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      const query = gl2.createQuery();\n      gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n      return query;\n    }\n\n    const ext = this.getQueryTimerExtensionWebGL1();\n    const query = ext.createQueryEXT();\n    ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n    return query;\n  }\n\n  endQuery() {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      gl2.endQuery(ext.TIME_ELAPSED_EXT);\n      return;\n    }\n\n    const ext = this.getQueryTimerExtensionWebGL1();\n    ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n  }\n\n  waitForQueryAndGetTime(query) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield util.repeatedTry(() => _this.disposed || // while testing contexts are created / disposed\n      // in rapid succession, so without this check we\n      // may poll for the query timer indefinitely\n      _this.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));\n      return _this.getQueryTime(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n    })();\n  }\n\n  getQueryTime(query, queryTimerVersion) {\n    if (queryTimerVersion === 0) {\n      return null;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl;\n      const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT); // Return milliseconds.\n\n      return timeElapsedNanos / 1000000;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n      const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT); // Return milliseconds.\n\n      return timeElapsedNanos / 1000000;\n    }\n  }\n\n  isQueryAvailable(query, queryTimerVersion) {\n    if (queryTimerVersion === 0) {\n      return true;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      const available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n      const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);\n\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    }\n  }\n\n  pollFence(fenceContext) {\n    return new Promise(resolve => {\n      this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());\n    });\n  }\n\n  pollItems() {\n    // Find the last query that has finished.\n    const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));\n\n    for (let i = 0; i <= index; ++i) {\n      const {\n        resolveFn\n      } = this.itemsToPoll[i];\n      resolveFn();\n    }\n\n    this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n  }\n\n  addItemToPoll(isDoneFn, resolveFn) {\n    this.itemsToPoll.push({\n      isDoneFn,\n      resolveFn\n    });\n\n    if (this.itemsToPoll.length > 1) {\n      // We already have a running loop that polls.\n      return;\n    } // Start a new loop that polls.\n\n\n    util.repeatedTry(() => {\n      this.pollItems(); // End the loop if no more items to poll.\n\n      return this.itemsToPoll.length === 0;\n    });\n  }\n\n  bindTextureToFrameBuffer(texture) {\n    this.throwIfDisposed();\n    webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);\n\n    if (this.debug) {\n      webgl_util.validateFramebuffer(this.gl);\n    }\n  }\n\n  unbindTextureToFrameBuffer() {\n    if (this.outputTexture != null) {\n      webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);\n\n      if (this.debug) {\n        webgl_util.validateFramebuffer(this.gl);\n      }\n    } else {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n    }\n  }\n\n  downloadMatrixDriver(texture, downloadAndDecode) {\n    this.bindTextureToFrameBuffer(texture);\n    const result = downloadAndDecode();\n    this.unbindTextureToFrameBuffer();\n    return result;\n  }\n\n  setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);\n\n    if (this.debug) {\n      webgl_util.validateFramebuffer(gl);\n    }\n\n    this.outputTexture = outputMatrixTextureMaybePacked;\n    webgl_util.callAndCheck(gl, () => gl.viewport(0, 0, width, height));\n    webgl_util.callAndCheck(gl, () => gl.scissor(0, 0, width, height));\n  }\n\n  setOutputMatrixWriteRegionDriver(x, y, width, height) {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(this.gl, () => this.gl.scissor(x, y, width, height));\n  }\n\n  throwIfDisposed() {\n    if (this.disposed) {\n      throw new Error('Attempted to use disposed GPGPUContext.');\n    }\n  }\n\n  throwIfNoProgram() {\n    if (this.program == null) {\n      throw new Error('No GPU program is currently set.');\n    }\n  }\n\n}\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\n\nexport function linearSearchLastTrue(arr) {\n  let i = 0;\n\n  for (; i < arr.length; ++i) {\n    const isDone = arr[i]();\n\n    if (!isDone) {\n      break;\n    }\n  }\n\n  return i - 1;\n}","map":{"version":3,"sources":["/Users/ryanliang/Downloads/main_movir_picker/node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_context.js"],"names":["env","util","getWebGLContext","setWebGLContext","gpgpu_util","tex_util","webgl_util","GPGPUContext","constructor","gl","outputTexture","program","disposed","vertexAttrsAreBound","itemsToPoll","glVersion","getNumber","COLOR_BUFFER_FLOAT","COLOR_BUFFER_HALF_FLOAT","TEXTURE_FLOAT","TEXTURE_HALF_FLOAT","textureFloatExtension","getExtensionOrThrow","hasExtension","textureHalfFloatExtension","get","Error","colorBufferFloatExtension","getExtension","colorBufferHalfFloatExtension","vertexBuffer","createVertexBuffer","indexBuffer","createIndexBuffer","framebuffer","createFramebuffer","textureConfig","getTextureConfig","debug","getBool","dispose","console","warn","callAndCheck","finish","bindFramebuffer","FRAMEBUFFER","deleteFramebuffer","bindBuffer","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","deleteBuffer","createFloat32MatrixTexture","rows","columns","throwIfDisposed","createFloat16MatrixTexture","createUnsignedBytesMatrixTexture","uploadPixelDataToTexture","texture","pixels","uploadDenseMatrixToTexture","width","height","data","createFloat16PackedMatrixTexture","createPackedMatrixTexture","deleteMatrixTexture","unbindColorTextureFromFramebuffer","deleteTexture","downloadByteEncodedFloatMatrixFromOutputTexture","downloadMatrixDriver","downloadPackedMatrixFromBuffer","buffer","batch","physicalRows","physicalCols","downloadFloat32MatrixFromBuffer","size","createBufferFromTexture","bindTextureToFrameBuffer","result","createBufferFromOutputTexture","unbindTextureToFrameBuffer","createAndWaitForFence","fenceContext","createFence","pollFence","query","isFencePassed","gl2","sync","fenceSync","SYNC_GPU_COMMANDS_COMPLETE","flush","status","clientWaitSync","ALREADY_SIGNALED","CONDITION_SATISFIED","beginQuery","endQuery","isQueryAvailable","downloadMatrixFromPackedTexture","downloadMatrixFromPackedOutputTexture","createProgram","fragmentShaderSource","fragmentShader","createFragmentShader","vertexShader","createVertexShader","attachShader","linkProgram","validateProgram","setProgram","bindVertexProgramAttributeStreams","deleteProgram","useProgram","getUniformLocation","uniformName","shouldThrow","getProgramUniformLocationOrThrow","getProgramUniformLocation","getAttributeLocation","attribute","getAttribLocation","getUniformLocationNoThrow","setInputMatrixTexture","inputMatrixTexture","uniformLocation","textureUnit","throwIfNoProgram","bindTextureToProgramUniformSampler","setOutputMatrixTexture","outputMatrixTexture","setOutputMatrixTextureDriver","setOutputPackedMatrixTexture","outputPackedMatrixTexture","getPackedMatrixTextureShapeWidthHeight","setOutputMatrixWriteRegion","startRow","numRows","startColumn","numColumns","setOutputMatrixWriteRegionDriver","setOutputPackedMatrixWriteRegion","debugValidate","validateFramebuffer","executeProgram","drawElements","TRIANGLES","UNSIGNED_SHORT","blockUntilAllProgramsCompleted","getQueryTimerExtension","disjointQueryTimerExtension","getQueryTimerExtensionWebGL2","getQueryTimerExtensionWebGL1","ext","createQuery","TIME_ELAPSED_EXT","createQueryEXT","beginQueryEXT","endQueryEXT","waitForQueryAndGetTime","repeatedTry","getQueryTime","queryTimerVersion","timeElapsedNanos","getQueryParameter","QUERY_RESULT","getQueryObjectEXT","QUERY_RESULT_EXT","available","QUERY_RESULT_AVAILABLE","disjoint","getParameter","GPU_DISJOINT_EXT","QUERY_RESULT_AVAILABLE_EXT","Promise","resolve","addItemToPoll","pollItems","index","linearSearchLastTrue","map","x","isDoneFn","i","resolveFn","slice","push","length","bindColorTextureToFramebuffer","downloadAndDecode","outputMatrixTextureMaybePacked","viewport","scissor","y","arr","isDone"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext, setWebGLContext } from './canvas_util';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport class GPGPUContext {\n    constructor(gl) {\n        this.outputTexture = null;\n        this.program = null;\n        this.disposed = false;\n        this.vertexAttrsAreBound = false;\n        this.itemsToPoll = [];\n        const glVersion = env().getNumber('WEBGL_VERSION');\n        if (gl != null) {\n            this.gl = gl;\n            setWebGLContext(glVersion, gl);\n        }\n        else {\n            this.gl = getWebGLContext(glVersion);\n        }\n        // WebGL 2.0 enables texture floats without an extension.\n        let COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n        const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n        if (env().getNumber('WEBGL_VERSION') === 1) {\n            const TEXTURE_FLOAT = 'OES_texture_float';\n            const TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n            this.textureFloatExtension =\n                webgl_util.getExtensionOrThrow(this.gl, TEXTURE_FLOAT);\n            if (webgl_util.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n                this.textureHalfFloatExtension =\n                    webgl_util.getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);\n            }\n            else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n                throw new Error('GL context does not support half float textures, yet the ' +\n                    'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n            }\n            this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n            if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n                this.colorBufferHalfFloatExtension =\n                    webgl_util.getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);\n            }\n            else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n                throw new Error('GL context does not support color renderable half floats, yet ' +\n                    'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n            }\n        }\n        else {\n            COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n            if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n                this.colorBufferFloatExtension =\n                    this.gl.getExtension(COLOR_BUFFER_FLOAT);\n            }\n            else if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n                this.colorBufferHalfFloatExtension =\n                    this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n            }\n            else {\n                throw new Error('GL context does not support color renderable floats');\n            }\n        }\n        this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);\n        this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);\n        this.framebuffer = webgl_util.createFramebuffer(this.gl);\n        this.textureConfig =\n            tex_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);\n    }\n    get debug() {\n        return env().getBool('DEBUG');\n    }\n    dispose() {\n        if (this.disposed) {\n            return;\n        }\n        if (this.program != null) {\n            console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +\n                ' This is probably a resource leak, delete the program with ' +\n                'GPGPUContext.deleteProgram before disposing.');\n        }\n        if (this.outputTexture != null) {\n            console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +\n                'texture.  This is probably a resource leak, delete the output ' +\n                'matrix texture with GPGPUContext.deleteMatrixTexture before ' +\n                'disposing.');\n        }\n        const gl = this.gl;\n        webgl_util.callAndCheck(gl, () => gl.finish());\n        webgl_util.callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n        webgl_util.callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));\n        webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));\n        webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));\n        webgl_util.callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));\n        this.disposed = true;\n    }\n    createFloat32MatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    createFloat16MatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    createUnsignedBytesMatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    uploadPixelDataToTexture(texture, pixels) {\n        this.throwIfDisposed();\n        gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);\n    }\n    uploadDenseMatrixToTexture(texture, width, height, data) {\n        this.throwIfDisposed();\n        gpgpu_util.uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);\n    }\n    createFloat16PackedMatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    createPackedMatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    deleteMatrixTexture(texture) {\n        this.throwIfDisposed();\n        if (this.outputTexture === texture) {\n            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n            this.outputTexture = null;\n        }\n        webgl_util.callAndCheck(this.gl, () => this.gl.deleteTexture(texture));\n    }\n    downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {\n        return this.downloadMatrixDriver(texture, () => gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(this.gl, rows, columns, this.textureConfig));\n    }\n    downloadPackedMatrixFromBuffer(buffer, batch, rows, columns, physicalRows, physicalCols) {\n        return gpgpu_util.downloadPackedMatrixFromBuffer(this.gl, buffer, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);\n    }\n    downloadFloat32MatrixFromBuffer(buffer, size) {\n        return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n    }\n    createBufferFromTexture(texture, rows, columns) {\n        this.bindTextureToFrameBuffer(texture);\n        const result = gpgpu_util.createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);\n        this.unbindTextureToFrameBuffer();\n        return result;\n    }\n    createAndWaitForFence() {\n        const fenceContext = this.createFence(this.gl);\n        return this.pollFence(fenceContext);\n    }\n    createFence(gl) {\n        let query;\n        let isFencePassed;\n        if (env().getBool('WEBGL_FENCE_API_ENABLED')) {\n            const gl2 = gl;\n            const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n            gl.flush();\n            isFencePassed = () => {\n                const status = gl2.clientWaitSync(sync, 0, 0);\n                return status === gl2.ALREADY_SIGNALED ||\n                    status === gl2.CONDITION_SATISFIED;\n            };\n            query = sync;\n        }\n        else if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n            query = this.beginQuery();\n            this.endQuery();\n            isFencePassed = () => this.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n        }\n        else {\n            // If we have no way to fence, return true immediately. This will fire in\n            // WebGL 1.0 when there is no disjoint query timer. In this case, because\n            // the fence passes immediately, we'll immediately ask for a download of\n            // the texture, which will cause the UI thread to hang.\n            isFencePassed = () => true;\n        }\n        return { query, isFencePassed };\n    }\n    downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {\n        return this.downloadMatrixDriver(texture, () => gpgpu_util.downloadMatrixFromPackedOutputTexture(this.gl, physicalRows, physicalCols));\n    }\n    createProgram(fragmentShaderSource) {\n        this.throwIfDisposed();\n        const gl = this.gl;\n        const fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);\n        const vertexShader = gpgpu_util.createVertexShader(gl);\n        const program = webgl_util.createProgram(gl);\n        webgl_util.callAndCheck(gl, () => gl.attachShader(program, vertexShader));\n        webgl_util.callAndCheck(gl, () => gl.attachShader(program, fragmentShader));\n        webgl_util.linkProgram(gl, program);\n        if (this.debug) {\n            webgl_util.validateProgram(gl, program);\n        }\n        if (!this.vertexAttrsAreBound) {\n            this.setProgram(program);\n            this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);\n        }\n        return program;\n    }\n    deleteProgram(program) {\n        this.throwIfDisposed();\n        if (program === this.program) {\n            this.program = null;\n        }\n        if (program != null) {\n            webgl_util.callAndCheck(this.gl, () => this.gl.deleteProgram(program));\n        }\n    }\n    setProgram(program) {\n        this.throwIfDisposed();\n        this.program = program;\n        if ((this.program != null) && this.debug) {\n            webgl_util.validateProgram(this.gl, this.program);\n        }\n        webgl_util.callAndCheck(this.gl, () => this.gl.useProgram(program));\n    }\n    getUniformLocation(program, uniformName, shouldThrow = true) {\n        this.throwIfDisposed();\n        if (shouldThrow) {\n            return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);\n        }\n        else {\n            return webgl_util.getProgramUniformLocation(this.gl, program, uniformName);\n        }\n    }\n    getAttributeLocation(program, attribute) {\n        this.throwIfDisposed();\n        return webgl_util.callAndCheck(this.gl, () => this.gl.getAttribLocation(program, attribute));\n    }\n    getUniformLocationNoThrow(program, uniformName) {\n        this.throwIfDisposed();\n        return this.gl.getUniformLocation(program, uniformName);\n    }\n    setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {\n        this.throwIfDisposed();\n        this.throwIfNoProgram();\n        webgl_util.bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);\n    }\n    setOutputMatrixTexture(outputMatrixTexture, rows, columns) {\n        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n    }\n    setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {\n        this.throwIfDisposed();\n        const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n    }\n    setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);\n    }\n    setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n    }\n    debugValidate() {\n        if (this.program != null) {\n            webgl_util.validateProgram(this.gl, this.program);\n        }\n        webgl_util.validateFramebuffer(this.gl);\n    }\n    executeProgram() {\n        this.throwIfDisposed();\n        this.throwIfNoProgram();\n        const gl = this.gl;\n        if (this.debug) {\n            this.debugValidate();\n        }\n        webgl_util.callAndCheck(gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));\n    }\n    blockUntilAllProgramsCompleted() {\n        this.throwIfDisposed();\n        webgl_util.callAndCheck(this.gl, () => this.gl.finish());\n    }\n    getQueryTimerExtension() {\n        if (this.disjointQueryTimerExtension == null) {\n            this.disjointQueryTimerExtension =\n                webgl_util.getExtensionOrThrow(this.gl, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ?\n                    'EXT_disjoint_timer_query_webgl2' :\n                    'EXT_disjoint_timer_query');\n        }\n        return this.disjointQueryTimerExtension;\n    }\n    getQueryTimerExtensionWebGL2() {\n        return this.getQueryTimerExtension();\n    }\n    getQueryTimerExtensionWebGL1() {\n        return this.getQueryTimerExtension();\n    }\n    beginQuery() {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n            const gl2 = this.gl;\n            const ext = this.getQueryTimerExtensionWebGL2();\n            const query = gl2.createQuery();\n            gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n            return query;\n        }\n        const ext = this.getQueryTimerExtensionWebGL1();\n        const query = ext.createQueryEXT();\n        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n        return query;\n    }\n    endQuery() {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n            const gl2 = this.gl;\n            const ext = this.getQueryTimerExtensionWebGL2();\n            gl2.endQuery(ext.TIME_ELAPSED_EXT);\n            return;\n        }\n        const ext = this.getQueryTimerExtensionWebGL1();\n        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n    }\n    async waitForQueryAndGetTime(query) {\n        await util.repeatedTry(() => this.disposed || // while testing contexts are created / disposed\n            // in rapid succession, so without this check we\n            // may poll for the query timer indefinitely\n            this.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));\n        return this.getQueryTime(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n    }\n    getQueryTime(query, queryTimerVersion) {\n        if (queryTimerVersion === 0) {\n            return null;\n        }\n        if (queryTimerVersion === 2) {\n            const gl2 = this.gl;\n            const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);\n            // Return milliseconds.\n            return timeElapsedNanos / 1000000;\n        }\n        else {\n            const ext = this.getQueryTimerExtensionWebGL1();\n            const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);\n            // Return milliseconds.\n            return timeElapsedNanos / 1000000;\n        }\n    }\n    isQueryAvailable(query, queryTimerVersion) {\n        if (queryTimerVersion === 0) {\n            return true;\n        }\n        if (queryTimerVersion === 2) {\n            const gl2 = this.gl;\n            const ext = this.getQueryTimerExtensionWebGL2();\n            const available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n            if (this.disjoint == null) {\n                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n            }\n            return available && !this.disjoint;\n        }\n        else {\n            const ext = this.getQueryTimerExtensionWebGL1();\n            const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);\n            if (this.disjoint == null) {\n                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n            }\n            return available && !this.disjoint;\n        }\n    }\n    pollFence(fenceContext) {\n        return new Promise(resolve => {\n            this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());\n        });\n    }\n    pollItems() {\n        // Find the last query that has finished.\n        const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));\n        for (let i = 0; i <= index; ++i) {\n            const { resolveFn } = this.itemsToPoll[i];\n            resolveFn();\n        }\n        this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n    }\n    addItemToPoll(isDoneFn, resolveFn) {\n        this.itemsToPoll.push({ isDoneFn, resolveFn });\n        if (this.itemsToPoll.length > 1) {\n            // We already have a running loop that polls.\n            return;\n        }\n        // Start a new loop that polls.\n        util.repeatedTry(() => {\n            this.pollItems();\n            // End the loop if no more items to poll.\n            return this.itemsToPoll.length === 0;\n        });\n    }\n    bindTextureToFrameBuffer(texture) {\n        this.throwIfDisposed();\n        webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);\n        if (this.debug) {\n            webgl_util.validateFramebuffer(this.gl);\n        }\n    }\n    unbindTextureToFrameBuffer() {\n        if (this.outputTexture != null) {\n            webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);\n            if (this.debug) {\n                webgl_util.validateFramebuffer(this.gl);\n            }\n        }\n        else {\n            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n        }\n    }\n    downloadMatrixDriver(texture, downloadAndDecode) {\n        this.bindTextureToFrameBuffer(texture);\n        const result = downloadAndDecode();\n        this.unbindTextureToFrameBuffer();\n        return result;\n    }\n    setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {\n        this.throwIfDisposed();\n        const gl = this.gl;\n        webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);\n        if (this.debug) {\n            webgl_util.validateFramebuffer(gl);\n        }\n        this.outputTexture = outputMatrixTextureMaybePacked;\n        webgl_util.callAndCheck(gl, () => gl.viewport(0, 0, width, height));\n        webgl_util.callAndCheck(gl, () => gl.scissor(0, 0, width, height));\n    }\n    setOutputMatrixWriteRegionDriver(x, y, width, height) {\n        this.throwIfDisposed();\n        webgl_util.callAndCheck(this.gl, () => this.gl.scissor(x, y, width, height));\n    }\n    throwIfDisposed() {\n        if (this.disposed) {\n            throw new Error('Attempted to use disposed GPGPUContext.');\n        }\n    }\n    throwIfNoProgram() {\n        if (this.program == null) {\n            throw new Error('No GPU program is currently set.');\n        }\n    }\n}\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\nexport function linearSearchLastTrue(arr) {\n    let i = 0;\n    for (; i < arr.length; ++i) {\n        const isDone = arr[i]();\n        if (!isDone) {\n            break;\n        }\n    }\n    return i - 1;\n}\n"]},"metadata":{},"sourceType":"module"}
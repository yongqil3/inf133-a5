{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from './environment';\nimport * as util from './util';\nexport class Profiler {\n  constructor(backendTimer, logger) {\n    this.backendTimer = backendTimer;\n    this.logger = logger;\n\n    if (logger == null) {\n      this.logger = new Logger();\n    }\n  }\n\n  profileKernel(kernelName, inputs, f) {\n    let outputs;\n\n    const holdResultWrapperFn = () => {\n      outputs = f();\n    };\n\n    let timer;\n    const start = util.now();\n\n    if (this.backendTimer.timerAvailable()) {\n      timer = this.backendTimer.time(holdResultWrapperFn);\n    } else {\n      holdResultWrapperFn();\n\n      for (const output of outputs) {\n        output.dataSync();\n      }\n\n      timer = Promise.resolve({\n        kernelMs: util.now() - start\n      });\n    }\n\n    if (env().getBool('CHECK_COMPUTATION_FOR_ERRORS')) {\n      for (let i = 0; i < outputs.length; i++) {\n        const output = outputs[i]; // Dangling promise here because we don't want to propagate up\n        // asynchronicity.\n\n        output.data().then(tensorVals => {\n          checkComputationForErrors(tensorVals, output.dtype, kernelName);\n        });\n      }\n    }\n\n    const kernelProfile = {\n      kernelName,\n      outputs,\n      inputs,\n      timeMs: timer.then(timing => timing.kernelMs),\n      extraInfo: timer.then(timing => timing.getExtraProfileInfo != null ? timing.getExtraProfileInfo() : '')\n    };\n    return kernelProfile;\n  }\n\n  logKernelProfile(kernelProfile) {\n    const {\n      kernelName,\n      outputs,\n      timeMs,\n      inputs,\n      extraInfo\n    } = kernelProfile;\n    outputs.forEach(result => {\n      Promise.all([result.data(), timeMs, extraInfo]).then(valueContainer => {\n        this.logger.logKernelProfile(kernelName, result, valueContainer[0], valueContainer[1], inputs, valueContainer[2]);\n      });\n    });\n  }\n\n}\nexport function checkComputationForErrors(vals, dtype, kernelName) {\n  if (dtype !== 'float32') {\n    // Only floating point computations will generate NaN values\n    return false;\n  }\n\n  for (let i = 0; i < vals.length; i++) {\n    const num = vals[i];\n\n    if (isNaN(num) || !isFinite(num)) {\n      // Throwing custom exception so behavior is testable.\n      console.warn(`Found ${num} in the result of '${kernelName}'`);\n      return true;\n    }\n  }\n\n  return false;\n}\nexport class Logger {\n  logKernelProfile(name, result, vals, timeMs, inputs, extraInfo) {\n    const time = typeof timeMs === 'number' ? util.rightPad(`${timeMs}ms`, 9) : timeMs['error'];\n    const paddedName = util.rightPad(name, 25);\n    const rank = result.rank;\n    const size = result.size;\n    const shape = util.rightPad(result.shape.toString(), 14);\n    let inputShapesDescription = '';\n\n    for (const name in inputs) {\n      const input = inputs[name];\n\n      if (input != null) {\n        // The input might be a non-tensor (e.g HTMLImageElement), in which case\n        // we claim the output shape as input shape.\n        const inputShape = input.shape || result.shape;\n        const inputRank = inputShape.length;\n        inputShapesDescription += `${name}: ${inputRank}D ${inputRank > 0 ? inputShape : ''} `;\n      }\n    }\n\n    console.log(`%c${paddedName}\\t%c${time}\\t%c${rank}D ${shape}\\t%c${size}\\t%c${inputShapesDescription}\\t%c${extraInfo}`, 'font-weight:bold', 'color:red', 'color:blue', 'color: orange', 'color: green', 'color: steelblue');\n  }\n\n}","map":{"version":3,"sources":["/Users/ryanliang/Downloads/main_movir_picker/node_modules/@tensorflow/tfjs-core/dist/profiler.js"],"names":["env","util","Profiler","constructor","backendTimer","logger","Logger","profileKernel","kernelName","inputs","f","outputs","holdResultWrapperFn","timer","start","now","timerAvailable","time","output","dataSync","Promise","resolve","kernelMs","getBool","i","length","data","then","tensorVals","checkComputationForErrors","dtype","kernelProfile","timeMs","timing","extraInfo","getExtraProfileInfo","logKernelProfile","forEach","result","all","valueContainer","vals","num","isNaN","isFinite","console","warn","name","rightPad","paddedName","rank","size","shape","toString","inputShapesDescription","input","inputShape","inputRank","log"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from './environment';\nimport * as util from './util';\nexport class Profiler {\n    constructor(backendTimer, logger) {\n        this.backendTimer = backendTimer;\n        this.logger = logger;\n        if (logger == null) {\n            this.logger = new Logger();\n        }\n    }\n    profileKernel(kernelName, inputs, f) {\n        let outputs;\n        const holdResultWrapperFn = () => {\n            outputs = f();\n        };\n        let timer;\n        const start = util.now();\n        if (this.backendTimer.timerAvailable()) {\n            timer = this.backendTimer.time(holdResultWrapperFn);\n        }\n        else {\n            holdResultWrapperFn();\n            for (const output of outputs) {\n                output.dataSync();\n            }\n            timer = Promise.resolve({ kernelMs: util.now() - start });\n        }\n        if (env().getBool('CHECK_COMPUTATION_FOR_ERRORS')) {\n            for (let i = 0; i < outputs.length; i++) {\n                const output = outputs[i];\n                // Dangling promise here because we don't want to propagate up\n                // asynchronicity.\n                output.data().then(tensorVals => {\n                    checkComputationForErrors(tensorVals, output.dtype, kernelName);\n                });\n            }\n        }\n        const kernelProfile = {\n            kernelName,\n            outputs,\n            inputs,\n            timeMs: timer.then(timing => timing.kernelMs),\n            extraInfo: timer.then(timing => timing.getExtraProfileInfo != null ?\n                timing.getExtraProfileInfo() :\n                '')\n        };\n        return kernelProfile;\n    }\n    logKernelProfile(kernelProfile) {\n        const { kernelName, outputs, timeMs, inputs, extraInfo } = kernelProfile;\n        outputs.forEach(result => {\n            Promise.all([result.data(), timeMs, extraInfo]).then(valueContainer => {\n                this.logger.logKernelProfile(kernelName, result, valueContainer[0], valueContainer[1], inputs, valueContainer[2]);\n            });\n        });\n    }\n}\nexport function checkComputationForErrors(vals, dtype, kernelName) {\n    if (dtype !== 'float32') {\n        // Only floating point computations will generate NaN values\n        return false;\n    }\n    for (let i = 0; i < vals.length; i++) {\n        const num = vals[i];\n        if (isNaN(num) || !isFinite(num)) {\n            // Throwing custom exception so behavior is testable.\n            console.warn(`Found ${num} in the result of '${kernelName}'`);\n            return true;\n        }\n    }\n    return false;\n}\nexport class Logger {\n    logKernelProfile(name, result, vals, timeMs, inputs, extraInfo) {\n        const time = typeof timeMs === 'number' ? util.rightPad(`${timeMs}ms`, 9) :\n            timeMs['error'];\n        const paddedName = util.rightPad(name, 25);\n        const rank = result.rank;\n        const size = result.size;\n        const shape = util.rightPad(result.shape.toString(), 14);\n        let inputShapesDescription = '';\n        for (const name in inputs) {\n            const input = inputs[name];\n            if (input != null) {\n                // The input might be a non-tensor (e.g HTMLImageElement), in which case\n                // we claim the output shape as input shape.\n                const inputShape = input.shape || result.shape;\n                const inputRank = inputShape.length;\n                inputShapesDescription +=\n                    `${name}: ${inputRank}D ${inputRank > 0 ? inputShape : ''} `;\n            }\n        }\n        console.log(`%c${paddedName}\\t%c${time}\\t%c${rank}D ${shape}\\t%c${size}\\t%c${inputShapesDescription}\\t%c${extraInfo}`, 'font-weight:bold', 'color:red', 'color:blue', 'color: orange', 'color: green', 'color: steelblue');\n    }\n}\n"]},"metadata":{},"sourceType":"module"}
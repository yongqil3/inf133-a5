{"ast":null,"code":"import _asyncToGenerator from \"/Users/ryanliang/Downloads/main_movir_picker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/* Original source keras/models.py */\nimport { dispose, io, serialization, util } from '@tensorflow/tfjs-core';\nimport { getUid } from './backend/state';\nimport { Input } from './engine/input_layer';\nimport { getSourceInputs, Node } from './engine/topology';\nimport { LayersModel } from './engine/training';\nimport { NotImplementedError, RuntimeError, ValueError } from './errors';\nimport { deserialize } from './layers/serialization';\nimport * as generic_utils from './utils/generic_utils';\nimport { convertPythonicToTs } from './utils/serialization_utils';\nimport { getExactlyOneShape } from './utils/types_utils';\n/**\n * Parses a JSON model configuration file and returns a model instance.\n *\n * ```js\n * // This example shows how to serialize a model using `toJSON()` and\n * // deserialize it as another model using `tf.models.modelFromJSON()`.\n * // Note: this example serializes and deserializes only the topology\n * // of the model; the weights of the loaded model will be different\n * // from those of the the original model, due to random weight\n * // initialization.\n * // To load the topology and weights of a model, use `tf.loadLayersModel()`.\n * const model1 = tf.sequential();\n * model1.add(tf.layers.repeatVector({inputShape: [2], n: 4}));\n * // Serialize `model1` as a JSON object.\n * const model1JSON = model1.toJSON(null, false);\n * model1.summary();\n *\n * const model2 = await tf.models.modelFromJSON(model1JSON);\n * model2.summary();\n * ```\n *\n *  @param modelAndWeightsConfig JSON object or string encoding a model and\n *       weights configuration. It can also be only the topology JSON of the\n *       model, in which case the weights will not be loaded.\n *  @param custom_objects Optional dictionary mapping names\n *       (strings) to custom classes or functions to be\n *       considered during deserialization.\n * @returns A TensorFlow.js Layers `tf.LayersModel` instance (uncompiled).\n */\n\nexport function modelFromJSON(_x, _x2) {\n  return _modelFromJSON.apply(this, arguments);\n}\n/**\n * Load a model, including its topology and optionally weights.  See the\n * Tutorial named \"How to import a Keras Model\" for usage examples.\n *\n * Example 1: Save `model`'s topology and weights to browser [local\n * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('localstorage://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('localstorage://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 2. Saving `model`'s topology and weights to browser\n * [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('indexeddb://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 3. Load a model from user-selected files from HTML\n * [file input\n * elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file).\n *\n * ```js\n * // Note: this code snippet will not work without the HTML elements in the\n * //   page\n * const jsonUpload = document.getElementById('json-upload');\n * const weightsUpload = document.getElementById('weights-upload');\n *\n * const model = await tf.loadLayersModel(\n *     tf.io.browserFiles([jsonUpload.files[0], weightsUpload.files[0]]));\n * ```\n *\n * Example 4. Load a model from an HTTP server.\n *\n * ```js\n * const model = await\n *     tf.loadLayersModel('https://storage.googleapis.com/tfjs-models/tfjs/iris_v1/model.json');\n * model.summary();\n * ```\n *\n * @param pathOrIOHandler Can be either of the two formats\n *   1. A string path to the `ModelAndWeightsConfig` JSON describing\n *      the model in the canonical TensorFlow.js format. This path will be\n *      interpreted as a relative HTTP path, to which `fetch` will be used to\n *      request the model topology and weight manifest JSON.\n *      The content of the JSON file is assumed to be a JSON object with the\n *      following fields and values:\n *      - 'modelTopology': A JSON object that can be either of:\n *        1. a model architecture JSON consistent with the format of the return\n *            value of `keras.Model.to_json()`\n *        2. a full model JSON in the format of `keras.models.save_model()`.\n *      - 'weightsManifest': A TensorFlow.js weights manifest.\n *      See the Python converter function `save_model()` for more details.\n *      It is also assumed that model weights can be accessed from relative\n *      paths described by the `paths` fields in weights manifest.\n *   2. An `tf.io.IOHandler` object that loads model artifacts with its `load`\n *      method.\n * @param options Optional configuration arguments for the model loading,\n *   including:\n *   - `strict`: Require that the provided weights exactly match those required\n *     by the layers.  Default true.  Passing false means that both extra\n *     weights and missing weights will be silently ignored.\n *   - `onProgress`: A progress callback of the form:\n *     `(fraction: number) => void`. This callback can be used to monitor the\n *     model-loading process.\n * @returns A `Promise` of `tf.LayersModel`, with the topology and weights\n *     loaded.\n */\n\nfunction _modelFromJSON() {\n  _modelFromJSON = _asyncToGenerator(function* (modelAndWeightsConfig, customObjects) {\n    if (!('modelTopology' in modelAndWeightsConfig)) {\n      modelAndWeightsConfig = {\n        modelTopology: modelAndWeightsConfig\n      };\n    }\n\n    modelAndWeightsConfig = modelAndWeightsConfig;\n    let modelTopology = modelAndWeightsConfig.modelTopology;\n\n    if (modelTopology['model_config'] != null) {\n      // If the model-topology JSON contains a 'model_config' field, then it is\n      // a full model JSON (e.g., from `keras.Model.save()`), which contains\n      // not only the model's architecture in its 'model_config' field, but\n      // additional information such as the model's optimizer. We use only the\n      // 'model_config' field currently.\n      modelTopology = modelTopology['model_config'];\n    }\n\n    const tsConfig = convertPythonicToTs(modelTopology);\n    const model = deserialize(tsConfig, customObjects);\n\n    if (modelAndWeightsConfig.weightsManifest != null) {\n      // Load the weight values keyed by the original tensor names in the model\n      // file that was loaded.  These should match the keys of the weight\n      // manifest.\n      const weightValues = yield io.loadWeights(modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix, model.weights.map(weight => weight.originalName)); // Map the weights to the unique tensor names generated during model loading\n\n      const uniqueWeightValues = {};\n\n      for (const weight of model.weights) {\n        uniqueWeightValues[weight.originalName] = weightValues[weight.originalName];\n      }\n\n      model.loadWeights(uniqueWeightValues); // Dispose temporary weight values.\n\n      dispose(weightValues);\n    }\n\n    return model;\n  });\n  return _modelFromJSON.apply(this, arguments);\n}\n\nexport function loadLayersModelInternal(_x3, _x4) {\n  return _loadLayersModelInternal.apply(this, arguments);\n}\n/**\n * Load a model and optionally its weights, using an IOHandler object.\n *\n * @param handler The instance of `IOHandler` to be used during the model\n *   loading.\n * @param customObjects Any optional custom objects to be used during model\n *   loading.\n * @param strict Whether the weight loading will be done in strict mode.\n *   Default: `true`.\n */\n\nfunction _loadLayersModelInternal() {\n  _loadLayersModelInternal = _asyncToGenerator(function* (pathOrIOHandler, options) {\n    if (options == null) {\n      options = {};\n    }\n\n    if (typeof pathOrIOHandler === 'string') {\n      const handlers = io.getLoadHandlers(pathOrIOHandler, options);\n\n      if (handlers.length === 0) {\n        // For backward compatibility: if no load handler can be found,\n        // assume it is a relative http path.\n        // TODO(cais): Reformat the args into a single `LoadOptions` once the core\n        // is refactored.\n        handlers.push(io.browserHTTPRequest(pathOrIOHandler, options));\n      } else if (handlers.length > 1) {\n        throw new ValueError(`Found more than one (${handlers.length}) load handlers for ` + `URL '${pathOrIOHandler}'`);\n      }\n\n      pathOrIOHandler = handlers[0];\n    }\n\n    return loadLayersModelFromIOHandler(pathOrIOHandler, undefined, options);\n  });\n  return _loadLayersModelInternal.apply(this, arguments);\n}\n\nexport function loadLayersModelFromIOHandler(_x5, _x6, _x7) {\n  return _loadLayersModelFromIOHandler.apply(this, arguments);\n}\n\nfunction _loadLayersModelFromIOHandler() {\n  _loadLayersModelFromIOHandler = _asyncToGenerator(function* (handler, customObjects, options) {\n    if (options == null) {\n      options = {};\n    }\n\n    if (handler.load == null) {\n      throw new ValueError('Cannot proceed with model loading because the IOHandler provided ' + 'does not have the `load` method implemented.');\n    }\n\n    const artifacts = yield handler.load();\n    let modelTopology = artifacts.modelTopology;\n\n    if (modelTopology['model_config'] != null) {\n      modelTopology = modelTopology['model_config'];\n    }\n\n    const strict = options.strict == null ? true : options.strict; // If weights are provided and the weight-loading mode is strict, use\n    // fast weight initialization. This skips costly initializers such as\n    // 'orthogonal' and saves unnecessary computation in cases where\n    // the initialized weight values will immediately be overwritten by\n    // loaded weight values.\n\n    const fastWeightInit = artifacts.weightData != null && artifacts.weightSpecs != null && strict;\n    const model = deserialize(convertPythonicToTs(modelTopology), customObjects, fastWeightInit);\n    const trainingConfig = artifacts.trainingConfig;\n\n    if (trainingConfig != null) {\n      model.loadTrainingConfig(trainingConfig);\n    }\n\n    if (artifacts.userDefinedMetadata != null) {\n      model.setUserDefinedMetadata(artifacts.userDefinedMetadata);\n    } // If weightData is present, load the weights into the model.\n\n\n    if (artifacts.weightData != null) {\n      // Loading weights requires weightSpecs.\n      if (artifacts.weightSpecs == null) {\n        throw new ValueError('LayersModel artifacts contains weight data, but not weight specs. ' + 'Therefore loading of weights cannot proceed.');\n      }\n\n      const {\n        modelWeights,\n        optimizerWeights\n      } = decodeModelAndOptimizerWeights(artifacts.weightData, artifacts.weightSpecs);\n      model.loadWeights(modelWeights, strict);\n\n      if (model.optimizer != null && optimizerWeights.length > 0) {\n        yield model.optimizer.setWeights(optimizerWeights);\n      } // Dispose temporary weight values.\n\n\n      dispose(modelWeights);\n      dispose(optimizerWeights.map(w => w.tensor));\n    }\n\n    return model;\n  });\n  return _loadLayersModelFromIOHandler.apply(this, arguments);\n}\n\nfunction decodeModelAndOptimizerWeights(buffer, specs) {\n  const name2Tensor = io.decodeWeights(buffer, specs);\n  const modelWeights = {};\n  const optimizerWeights = [];\n  specs.forEach(spec => {\n    if (spec.group === 'optimizer') {\n      optimizerWeights.push({\n        name: spec.name,\n        tensor: name2Tensor[spec.name]\n      });\n    } else {\n      modelWeights[spec.name] = name2Tensor[spec.name];\n    }\n  });\n  return {\n    modelWeights,\n    optimizerWeights\n  };\n}\n/**\n * A model with a stack of layers, feeding linearly from one to the next.\n *\n * `tf.sequential` is a factory function that creates an instance of\n * `tf.Sequential`.\n *\n * ```js\n *  // Define a model for linear regression.\n *  const model = tf.sequential();\n *  model.add(tf.layers.dense({units: 1, inputShape: [1]}));\n *\n *  // Prepare the model for training: Specify the loss and the optimizer.\n *  model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n *\n *  // Generate some synthetic data for training.\n *  const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);\n *  const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);\n *\n *  // Train the model using the data then do inference on a data point the\n *  // model hasn't seen:\n *  await model.fit(xs, ys);\n *  model.predict(tf.tensor2d([5], [1, 1])).print();\n * ```\n *\n * @doc {heading: 'Models', subheading: 'Classes'}\n */\n\n\nexport class Sequential extends LayersModel {\n  constructor(args) {\n    super({\n      inputs: [],\n      outputs: []\n    });\n    args = args || {};\n    this.trainable = true;\n    this.built = false; // Set model name.\n\n    this.name = args.name != null ? args.name : getUid('sequential_'); // Add to the model any layers passed to the constructor.\n\n    if (args.layers != null) {\n      for (const layer of args.layers) {\n        this.add(layer);\n      }\n    }\n  } // Helper function to Sequential.add  Throws if the new output shape will be\n  // invalid.\n\n\n  checkShape(layer) {\n    const shape = layer.inboundNodes[0].outputTensors[0].shape;\n\n    if (shape.some(x => x < 0)) {\n      throw new ValueError('Negative dimension size caused by adding layer ' + `${layer.name} with input shape [` + `${layer.inboundNodes[0].inputTensors[0].shape}]`);\n    }\n  }\n  /**\n   * Adds a layer instance on top of the layer stack.\n   *\n   * ```js\n   *  const model = tf.sequential();\n   *  model.add(tf.layers.dense({units: 8, inputShape: [1]}));\n   *  model.add(tf.layers.dense({units: 4, activation: 'relu6'}));\n   *  model.add(tf.layers.dense({units: 1, activation: 'relu6'}));\n   *  // Note that the untrained model is random at this point.\n   *  model.predict(tf.randomNormal([10, 1])).print();\n   * ```\n   * @param layer Layer instance.\n   *\n   * @exception ValueError In case the `layer` argument does not know its\n   * input shape.\n   * @exception ValueError In case the `layer` argument has multiple output\n   *   tensors, or is already connected somewhere else (forbidden in\n   *   `Sequential` models).\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n\n\n  add(layer) {\n    const isLayerModelInstance = layer instanceof Sequential || layer instanceof LayersModel;\n    let modelLayer;\n\n    if (isLayerModelInstance) {\n      modelLayer = layer;\n\n      if (modelLayer.outputs.length !== 1) {\n        throw new ValueError('All layers in a Sequential model ' + 'should have a single output tensor. ' + 'For multi-output layers, ' + 'use the functional API.');\n      }\n\n      if (modelLayer.inputs.length !== 1) {\n        throw new ValueError('All layers in a Sequential model ' + 'should have a single input tensor. ' + 'For multi-input layers, ' + 'use the functional API.');\n      }\n    }\n\n    if (this.outputs.length === 0) {\n      // first layer in model: check that it is an input layer\n      if (layer.inboundNodes.length === 0) {\n        // create an input layer\n        if (layer.batchInputShape == null) {\n          throw new ValueError('The first layer in a Sequential model must ' + 'get an `inputShape` or `batchInputShape` argument.');\n        } // Instantiate the input layer.\n\n\n        const x = Input({\n          batchShape: layer.batchInputShape,\n          dtype: layer.dtype,\n          name: layer.name + '_input'\n        }); // This will build the current layer and create the node connecting\n        // the current layer to the input layer we just created.\n\n        layer.apply(x);\n      }\n\n      if (isLayerModelInstance) {\n        this.outputs = modelLayer.outputs;\n        this.inputs = modelLayer.inputs;\n      } else {\n        if (layer.inboundNodes.length !== 1) {\n          throw new ValueError('A layer added to a Sequential model must not already be ' + `connected somewhere else. LayersModel received layer ${layer.name} ` + `which has ${layer.inboundNodes.length} pre-existing inbound ` + 'connections.');\n        }\n\n        if (layer.inboundNodes[0].outputTensors.length !== 1) {\n          throw new ValueError('All layers in a Sequential model ' + 'should have a single output tensor. ' + 'For multi-output layers, ' + 'use the functional API.');\n        }\n\n        this.checkShape(layer);\n        this.outputs = [layer.inboundNodes[0].outputTensors[0]];\n        this.inputs = getSourceInputs(this.outputs[0]);\n      }\n\n      this.inboundNodes = []; // We create an input node, which we will keep updated\n      // as we add more layers.\n      // (This call has side effects.)\n      // tslint:disable-next-line:no-unused-expression\n\n      new Node({\n        outboundLayer: this,\n        inboundLayers: [],\n        nodeIndices: [],\n        tensorIndices: [],\n        inputTensors: this.inputs,\n        outputTensors: this.outputs,\n        // no model-level masking for now\n        inputMasks: generic_utils.pyListRepeat(null, this.inputs.length),\n        outputMasks: [null],\n        inputShapes: this.inputs.map(x => x.shape),\n        outputShapes: this.outputs[0].shape\n      });\n    } else {\n      const outputTensor = layer.apply(this.outputs[0]);\n\n      if (Array.isArray(outputTensor)) {\n        throw new TypeError('All layers in a Sequential model ' + 'should have a single output tensor. ' + 'For multi-output layers, ' + 'use the functional API.');\n      }\n\n      this.checkShape(layer);\n      this.outputs = [outputTensor]; // update self.inbound_nodes\n\n      this.inboundNodes[0].outputTensors = this.outputs;\n      this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n    }\n\n    this.layers.push(layer);\n    this.built = false;\n  }\n  /**\n   * Removes the last layer in the model.\n   *\n   * @exception TypeError if there are no layers in the model.\n   */\n\n\n  pop() {\n    if (this.layers.length === 0) {\n      throw new TypeError('There are no layers in the model.');\n    }\n\n    this.layers.pop();\n\n    if (this.layers.length === 0) {\n      this.outputs = [];\n      this.inboundNodes = [];\n      this.outboundNodes = [];\n    } else {\n      const lastLayerIndex = this.layers.length - 1;\n      this.layers[lastLayerIndex].outboundNodes = [];\n      this.outputs = [this.layers[lastLayerIndex].output]; // update self.inbound_nodes\n\n      this.inboundNodes[0].outputTensors = this.outputs;\n      this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n    }\n  }\n\n  call(inputs, kwargs) {\n    if (this.model == null) {\n      this.build();\n    }\n\n    return this.model.call(inputs, kwargs);\n  }\n\n  build(inputShape) {\n    // Call `getExactlyOneShape` without using its return value,\n    // to verify that exactly one input shape is provided.\n    getExactlyOneShape(inputShape);\n\n    if (this.inputs.length === 0 || this.outputs.length === 0) {\n      throw new TypeError('Sequential model cannot be built: model is empty.' + ' Add some layers first.');\n    } // actually create the model\n\n\n    this.model = new LayersModel({\n      inputs: this.inputs,\n      outputs: this.outputs[0],\n      name: this.name + '_model'\n    });\n    this.model.trainable = this.trainable; // mirror model attributes\n\n    this.supportsMasking = this.model.supportsMasking; // TODO(michaelterry): Add caches\n\n    this.inputLayers = this.model.inputLayers;\n    this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;\n    this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;\n    this.outputLayers = this.model.outputLayers;\n    this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;\n    this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;\n    this.nodesByDepth = this.model.nodesByDepth;\n    this.containerNodes = this.model.containerNodes;\n    this.outputNames = this.model.outputNames;\n    this.inputNames = this.model.inputNames; // TODO(michaelterry): Add feedInputNames, feedInputs, if needed.\n    // TODO(michaelterry): Add callbackModel if needed.\n\n    this.built = true;\n  }\n\n  countParams() {\n    if (!this.built) {\n      this.build();\n    }\n\n    return super.countParams();\n  }\n  /**\n   * Print a text summary of the Sequential model's layers.\n   *\n   * The summary includes\n   * - Name and type of all layers that comprise the model.\n   * - Output shape(s) of the layers\n   * - Number of weight parameters of each layer\n   * - The total number of trainable and non-trainable parameters of the\n   * model.\n   *\n   * ```js\n   * const model = tf.sequential();\n   * model.add(\n   *     tf.layers.dense({units: 100, inputShape: [10], activation: 'relu'}));\n   * model.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));\n   *\n   * model.summary();\n   * ```\n   *\n   * @param lineLength Custom line length, in number of characters.\n   * @param positions Custom widths of each of the columns, as either\n   *   fractions of `lineLength` (e.g., `[0.5, 0.75, 1]`) or absolute number\n   *   of characters (e.g., `[30, 50, 65]`). Each number corresponds to\n   *   right-most (i.e., ending) position of a column.\n   * @param printFn Custom print function. Can be used to replace the default\n   *   `console.log`. For example, you can use `x => {}` to mute the printed\n   *   messages in the console.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n\n\n  summary(lineLength, positions, printFn = console.log) {\n    if (!this.built) {\n      this.build();\n    }\n\n    super.summary(lineLength, positions, printFn);\n  }\n  /**\n   * Sets the weights of the model.\n   *\n   * @param weights Should be a list of Tensors with shapes and types matching\n   *   the output of `model.getWeights()`.\n   */\n\n\n  setWeights(weights) {\n    if (this.model == null) {\n      this.build();\n    }\n\n    this.model.setWeights(weights);\n  }\n  /**\n   * Returns the loss value & metrics values for the model in test mode.\n   *\n   * Loss and metrics are specified during `compile()`, which needs to happen\n   * before calls to `evaluate()`.\n   *\n   * Computation is done in batches.\n   *\n   * ```js\n   * const model = tf.sequential({\n   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n   * });\n   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n   * const result = model.evaluate(tf.ones([8, 10]), tf.ones([8, 1]), {\n   *   batchSize: 4,\n   * });\n   * result.print();\n   * ```\n   *\n   * @param x `tf.Tensor` of test data, or an `Array` of `tf.Tensor`s if the\n   * model has multiple inputs.\n   * @param y `tf.Tensor` of target data, or an `Array` of `tf.Tensor`s if the\n   * model has multiple outputs.\n   * @param args A `ModelEvaluateConfig`, containing optional fields.\n   *\n   * @return `Scalar` test loss (if the model has a single output and no\n   *   metrics) or `Array` of `Scalar`s (if the model has multiple outputs\n   *   and/or metrics). The attribute `model.metricsNames`\n   *   will give you the display labels for the scalar outputs.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n\n\n  evaluate(x, y, args = {}) {\n    if (!this.built) {\n      throw new RuntimeError('The model needs to be compiled before being used.');\n    }\n\n    return this.model.evaluate(x, y, args);\n  } // TODO(cais): Add code snippet below once real dataset objects are\n  //   available.\n\n  /**\n   * Evaluate model using a dataset object.\n   *\n   * Note: Unlike `evaluate()`, this method is asynchronous (`async`);\n   *\n   * @param dataset A dataset object. Its `iterator()` method is expected\n   *   to generate a dataset iterator object, the `next()` method of which\n   *   is expected to produce data batches for evaluation. The return value\n   *   of the `next()` call ought to contain a boolean `done` field and a\n   *   `value` field. The `value` field is expected to be an array of two\n   *   `tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former\n   *   case is for models with exactly one input and one output (e.g..\n   *   a sequential model). The latter case is for models with multiple\n   *   inputs and/or multiple outputs. Of the two items in the array, the\n   *   first is the input feature(s) and the second is the output target(s).\n   * @param args A configuration object for the dataset-based evaluation.\n   * @returns Loss and metric values as an Array of `Scalar` objects.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n\n\n  evaluateDataset(dataset, args) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this.built) {\n        throw new RuntimeError('The model needs to be compiled before being used.');\n      }\n\n      return _this.model.evaluateDataset(dataset, args);\n    })();\n  }\n  /**\n   * Generates output predictions for the input samples.\n   *\n   * Computation is done in batches.\n   *\n   * Note: the \"step\" mode of predict() is currently not supported.\n   *   This is because the TensorFow.js core backend is imperative only.\n   *\n   * ```js\n   * const model = tf.sequential({\n   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n   * });\n   * model.predict(tf.ones([2, 10])).print();\n   * ```\n   *\n   * @param x The input data, as a Tensor, or an `Array` of `tf.Tensor`s if\n   *   the model has multiple inputs.\n   * @param conifg A `ModelPredictConfig` object containing optional fields.\n   *\n   * @return `tf.Tensor`(s) of predictions.\n   *\n   * @exception ValueError In case of mismatch between the provided input data\n   *   and the model's expectations, or in case a stateful model receives a\n   *   number of samples that is not a multiple of the batch size.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n\n\n  predict(x, args = {}) {\n    if (this.model == null) {\n      this.build();\n    }\n\n    return this.model.predict(x, args);\n  }\n  /**\n   * Returns predictions for a single batch of samples.\n   *\n   * @param x: Input samples, as a Tensor, or list of Tensors (if the model\n   *   has multiple inputs).\n   * @return Tensor(s) of predictions\n   */\n\n\n  predictOnBatch(x) {\n    if (this.model == null) {\n      this.build();\n    }\n\n    return this.model.predictOnBatch(x);\n  }\n  /**\n   * See `LayersModel.compile`.\n   *\n   * @param args\n   */\n\n\n  compile(args) {\n    this.build();\n    this.model.compile(args);\n    this.optimizer_ = this.model.optimizer; // tslint:disable-next-line:no-any\n\n    this.isOptimizerOwned = this.model.isOptimizerOwned;\n    this.loss = this.model.loss;\n    this.metrics = this.model.metrics; // TODO(cais): Add this.lossWeights, this.sampleWeightMode,\n    //   this.weightedMetrics, this.targets.\n\n    this.metricsTensors = this.model.metricsTensors;\n    this.metricsNames = this.model.metricsNames; // TODO(cais): Add sampleWeights.\n  }\n\n  get optimizer() {\n    return this.model == null ? undefined : this.model.optimizer;\n  }\n\n  set optimizer(optimizer) {\n    this.model.optimizer = optimizer;\n  }\n  /**\n   * Trains the model for a fixed number of epochs (iterations on a dataset).\n   *\n   * ```js\n   * const model = tf.sequential({\n   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n   * });\n   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n   * const history = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {\n   *   batchSize: 4,\n   *   epochs: 3\n   * });\n   * console.log(history.history.loss[0]);\n   * ```\n   *\n   * @param x `tf.Tensor` of training data, or an array of `tf.Tensor`s if the\n   * model has multiple inputs. If all inputs in the model are named, you can\n   * also pass a dictionary mapping input names to `tf.Tensor`s.\n   * @param y `tf.Tensor` of target (label) data, or an array of `tf.Tensor`s if\n   * the model has multiple outputs. If all outputs in the model are named, you\n   *  can also pass a dictionary mapping output names to `tf.Tensor`s.\n   * @param args  A `ModelFitConfig`, containing optional fields.\n   *\n   * @return A `History` instance. Its `history` attribute contains all\n   *   information collected during training.\n   *\n   * @exception ValueError In case of mismatch between the provided input data\n   *   and what the model expects.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n\n\n  fit(x, y, args = {}) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this2.built) {\n        throw new RuntimeError('The model needs to be compiled before ' + 'being used.');\n      }\n\n      return _this2.model.fit(x, y, args);\n    })();\n  }\n  /**\n   * Trains the model using a dataset object.\n   *\n   * ```js\n   * const xArray = [\n   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n   * ];\n   * const yArray = [1, 1, 1, 1];\n   * // Create a dataset from the JavaScript array.\n   * const xDataset = tf.data.array(xArray);\n   * const yDataset = tf.data.array(yArray);\n   * // Zip combines the `x` and `y` Datasets into a single Dataset, the\n   * // iterator of which will return an object containing of two tensors,\n   * // corresponding to `x` and `y`.  The call to `batch(4)` will bundle\n   * // four such samples into a single object, with the same keys now pointing\n   * // to tensors that hold 4 examples, organized along the batch dimension.\n   * // The call to `shuffle(4)` causes each iteration through the dataset to\n   * // happen in a different order.  The size of the shuffle window is 4.\n   * const xyDataset = tf.data.zip({xs: xDataset, ys: yDataset})\n   *     .batch(4)\n   *     .shuffle(4);\n   * const model = tf.sequential({\n   *   layers: [tf.layers.dense({units: 1, inputShape: [9]})]\n   * });\n   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n   * const history = await model.fitDataset(xyDataset, {\n   *   epochs: 4,\n   *   callbacks: {onEpochEnd: (epoch, logs) => console.log(logs.loss)}\n   * });\n   * ```\n   *\n   * @param dataset A dataset object. Its `iterator()` method is expected to\n   *   generate a dataset iterator object, the `next()` method of which is\n   *   expected to produce data batches for evaluation. The return value of the\n   *   `next()` call ought to contain a boolean `done` field and a `value`\n   *   field.\n   *\n   *   The `value` field is expected to be an object of with fields\n   *   `xs` and `ys`, which point to the feature tensor and the target tensor,\n   *   respectively. This case is for models with exactly one input and one\n   *   output (e.g.. a sequential model). For example:\n   *   ```js\n   *   {value: {xs: xsTensor, ys: ysTensor}, done: false}\n   *   ```\n   *\n   *   If the model has multiple inputs, the `xs` field of `value` should\n   *   be an object mapping input names to their respective feature tensors.\n   *   For example:\n   *   ```js\n   *   {\n   *     value: {\n   *       xs: {\n   *         input_1: xsTensor1,\n   *         input_2: xsTensor2\n   *       },\n   *       ys: ysTensor\n   *     },\n   *     done: false\n   *   }\n   *   ```\n   *   If the model has multiple outputs, the `ys` field of `value` should\n   *   be an object mapping output names to their respective target tensors.\n   *   For example:\n   *   ```js\n   *   {\n   *     value: {\n   *       xs: xsTensor,\n   *       ys: {\n   *         output_1: ysTensor1,\n   *         output_2: ysTensor2\n   *       },\n   *     },\n   *     done: false\n   *   }\n   *   ```\n   * @param args A `ModelFitDatasetArgs`, containing optional fields.\n   *\n   * @return A `History` instance. Its `history` attribute contains all\n   *   information collected during training.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}\n   */\n\n\n  fitDataset(dataset, args) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this3.built) {\n        throw new RuntimeError('The model needs to be compiled before ' + 'being used.');\n      }\n\n      return _this3.model.fitDataset(dataset, args);\n    })();\n  }\n  /**\n   * Runs a single gradient update on a single batch of data.\n   *\n   * This method differs from `fit()` and `fitDataset()` in the following\n   * regards:\n   *   - It operates on exactly one batch of data.\n   *   - It returns only the loss and matric values, instead of\n   *     returning the batch-by-batch loss and metric values.\n   *   - It doesn't support fine-grained options such as verbosity and\n   *     callbacks.\n   *\n   * @param x Input data. It could be one of the following:\n   *   - A `tf.Tensor`, or an Array of `tf.Tensor`s (in case the model has\n   *     multiple inputs).\n   *   - An Object mapping input names to corresponding `tf.Tensor` (if the\n   *     model has named inputs).\n   * @param y Target darta. It could be either a `tf.Tensor` a multiple\n   *   `tf.Tensor`s. It should be consistent with `x`.\n   * @returns Training loss or losses (in case the model has\n   *   multiple outputs), along with metrics (if any), as numbers.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n\n\n  trainOnBatch(x, y) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this4.model.trainOnBatch(x, y);\n    })();\n  }\n  /* See parent class for JsDoc */\n\n  /** @nocollapse */\n\n\n  static fromConfig(cls, config, customObjects = {}, fastWeightInit = false) {\n    let configArray;\n    let extraModelConfig = {};\n\n    if (config instanceof Array) {\n      if (!(config[0].className != null) || config[0]['className'] === 'Merge') {\n        throw new ValueError('Legacy serialization format not supported yet.');\n      }\n\n      configArray = config;\n    } else {\n      util.assert(config['layers'] != null, () => `When the config data for a Sequential model is not an Array, ` + `it must be an Object that contains the 'layers' field.`);\n      configArray = config['layers'];\n      delete config['layers'];\n      extraModelConfig = config;\n    }\n\n    const model = new cls(extraModelConfig);\n\n    if (!(model instanceof Sequential)) {\n      throw new NotImplementedError(`Sequential.fromConfig called on non-Sequential input: ${model}`);\n    }\n\n    for (const conf of configArray) {\n      const customObjects = undefined;\n      const layer = deserialize(conf, customObjects, fastWeightInit);\n\n      if (fastWeightInit) {\n        layer.setFastWeightInitDuringBuild(true);\n      }\n\n      model.add(layer);\n    }\n\n    return model;\n  }\n  /**\n   * Setter used for force stopping of LayersModel.fit() (i.e., training).\n   *\n   * Example:\n   *\n   * ```js\n   * const model = tf.sequential();\n   * model.add(tf.layers.dense({units: 1, inputShape: [10]}));\n   * model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n   * const xs = tf.ones([8, 10]);\n   * const ys = tf.zeros([8, 1]);\n   *\n   * const history = await model.fit(xs, ys, {\n   *   epochs: 10,\n   *   callbacks: {\n   *     onEpochEnd: async (epoch, logs) => {\n   *       if (epoch === 2) {\n   *         model.stopTraining = true;\n   *       }\n   *     }\n   *   }\n   * });\n   *\n   * // There should be only 3 values in the loss array, instead of 10 values,\n   * // due to the stopping after 3 epochs.\n   * console.log(history.history.loss);\n   * ```\n   */\n\n\n  set stopTraining(stop) {\n    // TODO(cais): When refactoring to remove the composition pattern happens,\n    // remove this method overriding.\n    if (this.model == null) {\n      throw new ValueError('Cannot set the stopTraining property of a sequential model before ' + 'it is compiled.');\n    }\n\n    this.model.stopTraining = stop;\n  }\n\n  get stopTraining() {\n    if (this.model == null) {\n      throw new ValueError('Cannot get the stopTraining property of a sequential model before ' + 'it is compiled.');\n    }\n\n    return this.model.stopTraining;\n  } // TODO(cais): Override get trainableWeights() here\n  // tslint:disable-next-line:no-any\n\n\n  getConfig() {\n    // NOTE(cais): We override the return type of getConfig() to `any` here,\n    //   because the `Sequential` class is a special case among `Container`\n    //   subtypes in that its getConfig() method returns an Array (not a\n    //   dict).\n    const layers = [];\n\n    for (const layer of this.layers) {\n      const dict = {};\n      dict['className'] = layer.getClassName();\n      dict['config'] = layer.getConfig();\n      layers.push(dict);\n    }\n\n    return {\n      name: this.name,\n      layers\n    };\n  }\n\n}\n/** @nocollapse */\n\nSequential.className = 'Sequential';\nserialization.registerClass(Sequential);","map":{"version":3,"sources":["/Users/ryanliang/Downloads/main_movir_picker/node_modules/@tensorflow/tfjs-layers/dist/models.js"],"names":["dispose","io","serialization","util","getUid","Input","getSourceInputs","Node","LayersModel","NotImplementedError","RuntimeError","ValueError","deserialize","generic_utils","convertPythonicToTs","getExactlyOneShape","modelFromJSON","modelAndWeightsConfig","customObjects","modelTopology","tsConfig","model","weightsManifest","weightValues","loadWeights","pathPrefix","weights","map","weight","originalName","uniqueWeightValues","loadLayersModelInternal","pathOrIOHandler","options","handlers","getLoadHandlers","length","push","browserHTTPRequest","loadLayersModelFromIOHandler","undefined","handler","load","artifacts","strict","fastWeightInit","weightData","weightSpecs","trainingConfig","loadTrainingConfig","userDefinedMetadata","setUserDefinedMetadata","modelWeights","optimizerWeights","decodeModelAndOptimizerWeights","optimizer","setWeights","w","tensor","buffer","specs","name2Tensor","decodeWeights","forEach","spec","group","name","Sequential","constructor","args","inputs","outputs","trainable","built","layers","layer","add","checkShape","shape","inboundNodes","outputTensors","some","x","inputTensors","isLayerModelInstance","modelLayer","batchInputShape","batchShape","dtype","apply","outboundLayer","inboundLayers","nodeIndices","tensorIndices","inputMasks","pyListRepeat","outputMasks","inputShapes","outputShapes","outputTensor","Array","isArray","TypeError","pop","outboundNodes","lastLayerIndex","output","call","kwargs","build","inputShape","supportsMasking","inputLayers","inputLayersNodeIndices","inputLayersTensorIndices","outputLayers","outputLayersNodeIndices","outputLayersTensorIndices","nodesByDepth","containerNodes","outputNames","inputNames","countParams","summary","lineLength","positions","printFn","console","log","evaluate","y","evaluateDataset","dataset","predict","predictOnBatch","compile","optimizer_","isOptimizerOwned","loss","metrics","metricsTensors","metricsNames","fit","fitDataset","trainOnBatch","fromConfig","cls","config","configArray","extraModelConfig","className","assert","conf","setFastWeightInitDuringBuild","stopTraining","stop","getConfig","dict","getClassName","registerClass"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA,SAASA,OAAT,EAAkBC,EAAlB,EAAsBC,aAAtB,EAAqCC,IAArC,QAAiD,uBAAjD;AACA,SAASC,MAAT,QAAuB,iBAAvB;AACA,SAASC,KAAT,QAAsB,sBAAtB;AACA,SAASC,eAAT,EAA0BC,IAA1B,QAAsC,mBAAtC;AACA,SAASC,WAAT,QAA4B,mBAA5B;AACA,SAASC,mBAAT,EAA8BC,YAA9B,EAA4CC,UAA5C,QAA8D,UAA9D;AACA,SAASC,WAAT,QAA4B,wBAA5B;AACA,OAAO,KAAKC,aAAZ,MAA+B,uBAA/B;AACA,SAASC,mBAAT,QAAoC,6BAApC;AACA,SAASC,kBAAT,QAAmC,qBAAnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,gBAAsBC,aAAtB;AAAA;AAAA;AAiCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;qCAxHO,WAA6BC,qBAA7B,EAAoDC,aAApD,EAAmE;AACtE,QAAI,EAAE,mBAAmBD,qBAArB,CAAJ,EAAiD;AAC7CA,MAAAA,qBAAqB,GAAG;AAAEE,QAAAA,aAAa,EAAEF;AAAjB,OAAxB;AACH;;AACDA,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ACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,OAAO,CAACC,UAAD,EAAaC,SAAb,EAAwBC,OAAO,GAAGC,OAAO,CAACC,GAA1C,EAA+C;AAClD,QAAI,CAAC,KAAKvD,KAAV,EAAiB;AACb,WAAKoC,KAAL;AACH;;AACD,UAAMc,OAAN,CAAcC,UAAd,EAA0BC,SAA1B,EAAqCC,OAArC;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACItE,EAAAA,UAAU,CAAC9B,OAAD,EAAU;AAChB,QAAI,KAAKL,KAAL,IAAc,IAAlB,EAAwB;AACpB,WAAKwF,KAAL;AACH;;AACD,SAAKxF,KAAL,CAAWmC,UAAX,CAAsB9B,OAAtB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIuG,EAAAA,QAAQ,CAAC/C,CAAD,EAAIgD,CAAJ,EAAO7D,IAAI,GAAG,EAAd,EAAkB;AACtB,QAAI,CAAC,KAAKI,KAAV,EAAiB;AACb,YAAM,IAAI/D,YAAJ,CAAiB,mDAAjB,CAAN;AACH;;AACD,WAAO,KAAKW,KAAL,CAAW4G,QAAX,CAAoB/C,CAApB,EAAuBgD,CAAvB,EAA0B7D,IAA1B,CAAP;AACH,GApSuC,CAqSxC;AACA;;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACU8D,EAAAA,eAAe,CAACC,OAAD,EAAU/D,IAAV,EAAgB;AAAA;;AAAA;AACjC,UAAI,CAAC,KAAI,CAACI,KAAV,EAAiB;AACb,cAAM,IAAI/D,YAAJ,CAAiB,mDAAjB,CAAN;AACH;;AACD,aAAO,KAAI,CAACW,KAAL,CAAW8G,eAAX,CAA2BC,OAA3B,EAAoC/D,IAApC,CAAP;AAJiC;AAKpC;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIgE,EAAAA,OAAO,CAACnD,CAAD,EAAIb,IAAI,GAAG,EAAX,EAAe;AAClB,QAAI,KAAKhD,KAAL,IAAc,IAAlB,EAAwB;AACpB,WAAKwF,KAAL;AACH;;AACD,WAAO,KAAKxF,KAAL,CAAWgH,OAAX,CAAmBnD,CAAnB,EAAsBb,IAAtB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIiE,EAAAA,cAAc,CAACpD,CAAD,EAAI;AACd,QAAI,KAAK7D,KAAL,IAAc,IAAlB,EAAwB;AACpB,WAAKwF,KAAL;AACH;;AACD,WAAO,KAAKxF,KAAL,CAAWiH,cAAX,CAA0BpD,CAA1B,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIqD,EAAAA,OAAO,CAAClE,IAAD,EAAO;AACV,SAAKwC,KAAL;AACA,SAAKxF,KAAL,CAAWkH,OAAX,CAAmBlE,IAAnB;AACA,SAAKmE,UAAL,GAAkB,KAAKnH,KAAL,CAAWkC,SAA7B,CAHU,CAIV;;AACA,SAAKkF,gBAAL,GAAwB,KAAKpH,KAAL,CAAWoH,gBAAnC;AACA,SAAKC,IAAL,GAAY,KAAKrH,KAAL,CAAWqH,IAAvB;AACA,SAAKC,OAAL,GAAe,KAAKtH,KAAL,CAAWsH,OAA1B,CAPU,CAQV;AACA;;AACA,SAAKC,cAAL,GAAsB,KAAKvH,KAAL,CAAWuH,cAAjC;AACA,SAAKC,YAAL,GAAoB,KAAKxH,KAAL,CAAWwH,YAA/B,CAXU,CAYV;AACH;;AACY,MAATtF,SAAS,GAAG;AACZ,WAAO,KAAKlC,KAAL,IAAc,IAAd,GAAqBmB,SAArB,GAAiC,KAAKnB,KAAL,CAAWkC,SAAnD;AACH;;AACY,MAATA,SAAS,CAACA,SAAD,EAAY;AACrB,SAAKlC,KAAL,CAAWkC,SAAX,GAAuBA,SAAvB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACUuF,EAAAA,GAAG,CAAC5D,CAAD,EAAIgD,CAAJ,EAAO7D,IAAI,GAAG,EAAd,EAAkB;AAAA;;AAAA;AACvB,UAAI,CAAC,MAAI,CAACI,KAAV,EAAiB;AACb,cAAM,IAAI/D,YAAJ,CAAiB,2CACnB,aADE,CAAN;AAEH;;AACD,aAAO,MAAI,CAACW,KAAL,CAAWyH,GAAX,CAAe5D,CAAf,EAAkBgD,CAAlB,EAAqB7D,IAArB,CAAP;AALuB;AAM1B;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACU0E,EAAAA,UAAU,CAACX,OAAD,EAAU/D,IAAV,EAAgB;AAAA;;AAAA;AAC5B,UAAI,CAAC,MAAI,CAACI,KAAV,EAAiB;AACb,cAAM,IAAI/D,YAAJ,CAAiB,2CACnB,aADE,CAAN;AAEH;;AACD,aAAO,MAAI,CAACW,KAAL,CAAW0H,UAAX,CAAsBX,OAAtB,EAA+B/D,IAA/B,CAAP;AAL4B;AAM/B;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source keras/models.py */\nimport { dispose, io, serialization, util } from '@tensorflow/tfjs-core';\nimport { getUid } from './backend/state';\nimport { Input } from './engine/input_layer';\nimport { getSourceInputs, Node } from './engine/topology';\nimport { LayersModel } from './engine/training';\nimport { NotImplementedError, RuntimeError, ValueError } from './errors';\nimport { deserialize } from './layers/serialization';\nimport * as generic_utils from './utils/generic_utils';\nimport { convertPythonicToTs } from './utils/serialization_utils';\nimport { getExactlyOneShape } from './utils/types_utils';\n/**\n * Parses a JSON model configuration file and returns a model instance.\n *\n * ```js\n * // This example shows how to serialize a model using `toJSON()` and\n * // deserialize it as another model using `tf.models.modelFromJSON()`.\n * // Note: this example serializes and deserializes only the topology\n * // of the model; the weights of the loaded model will be different\n * // from those of the the original model, due to random weight\n * // initialization.\n * // To load the topology and weights of a model, use `tf.loadLayersModel()`.\n * const model1 = tf.sequential();\n * model1.add(tf.layers.repeatVector({inputShape: [2], n: 4}));\n * // Serialize `model1` as a JSON object.\n * const model1JSON = model1.toJSON(null, false);\n * model1.summary();\n *\n * const model2 = await tf.models.modelFromJSON(model1JSON);\n * model2.summary();\n * ```\n *\n *  @param modelAndWeightsConfig JSON object or string encoding a model and\n *       weights configuration. It can also be only the topology JSON of the\n *       model, in which case the weights will not be loaded.\n *  @param custom_objects Optional dictionary mapping names\n *       (strings) to custom classes or functions to be\n *       considered during deserialization.\n * @returns A TensorFlow.js Layers `tf.LayersModel` instance (uncompiled).\n */\nexport async function modelFromJSON(modelAndWeightsConfig, customObjects) {\n    if (!('modelTopology' in modelAndWeightsConfig)) {\n        modelAndWeightsConfig = { modelTopology: modelAndWeightsConfig };\n    }\n    modelAndWeightsConfig = modelAndWeightsConfig;\n    let modelTopology = modelAndWeightsConfig.modelTopology;\n    if (modelTopology['model_config'] != null) {\n        // If the model-topology JSON contains a 'model_config' field, then it is\n        // a full model JSON (e.g., from `keras.Model.save()`), which contains\n        // not only the model's architecture in its 'model_config' field, but\n        // additional information such as the model's optimizer. We use only the\n        // 'model_config' field currently.\n        modelTopology = modelTopology['model_config'];\n    }\n    const tsConfig = convertPythonicToTs(modelTopology);\n    const model = deserialize(tsConfig, customObjects);\n    if (modelAndWeightsConfig.weightsManifest != null) {\n        // Load the weight values keyed by the original tensor names in the model\n        // file that was loaded.  These should match the keys of the weight\n        // manifest.\n        const weightValues = await io.loadWeights(modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix, model.weights.map(weight => weight.originalName));\n        // Map the weights to the unique tensor names generated during model loading\n        const uniqueWeightValues = {};\n        for (const weight of model.weights) {\n            uniqueWeightValues[weight.originalName] =\n                weightValues[weight.originalName];\n        }\n        model.loadWeights(uniqueWeightValues);\n        // Dispose temporary weight values.\n        dispose(weightValues);\n    }\n    return model;\n}\n/**\n * Load a model, including its topology and optionally weights.  See the\n * Tutorial named \"How to import a Keras Model\" for usage examples.\n *\n * Example 1: Save `model`'s topology and weights to browser [local\n * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('localstorage://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('localstorage://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 2. Saving `model`'s topology and weights to browser\n * [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('indexeddb://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 3. Load a model from user-selected files from HTML\n * [file input\n * elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file).\n *\n * ```js\n * // Note: this code snippet will not work without the HTML elements in the\n * //   page\n * const jsonUpload = document.getElementById('json-upload');\n * const weightsUpload = document.getElementById('weights-upload');\n *\n * const model = await tf.loadLayersModel(\n *     tf.io.browserFiles([jsonUpload.files[0], weightsUpload.files[0]]));\n * ```\n *\n * Example 4. Load a model from an HTTP server.\n *\n * ```js\n * const model = await\n *     tf.loadLayersModel('https://storage.googleapis.com/tfjs-models/tfjs/iris_v1/model.json');\n * model.summary();\n * ```\n *\n * @param pathOrIOHandler Can be either of the two formats\n *   1. A string path to the `ModelAndWeightsConfig` JSON describing\n *      the model in the canonical TensorFlow.js format. This path will be\n *      interpreted as a relative HTTP path, to which `fetch` will be used to\n *      request the model topology and weight manifest JSON.\n *      The content of the JSON file is assumed to be a JSON object with the\n *      following fields and values:\n *      - 'modelTopology': A JSON object that can be either of:\n *        1. a model architecture JSON consistent with the format of the return\n *            value of `keras.Model.to_json()`\n *        2. a full model JSON in the format of `keras.models.save_model()`.\n *      - 'weightsManifest': A TensorFlow.js weights manifest.\n *      See the Python converter function `save_model()` for more details.\n *      It is also assumed that model weights can be accessed from relative\n *      paths described by the `paths` fields in weights manifest.\n *   2. An `tf.io.IOHandler` object that loads model artifacts with its `load`\n *      method.\n * @param options Optional configuration arguments for the model loading,\n *   including:\n *   - `strict`: Require that the provided weights exactly match those required\n *     by the layers.  Default true.  Passing false means that both extra\n *     weights and missing weights will be silently ignored.\n *   - `onProgress`: A progress callback of the form:\n *     `(fraction: number) => void`. This callback can be used to monitor the\n *     model-loading process.\n * @returns A `Promise` of `tf.LayersModel`, with the topology and weights\n *     loaded.\n */\nexport async function loadLayersModelInternal(pathOrIOHandler, options) {\n    if (options == null) {\n        options = {};\n    }\n    if (typeof pathOrIOHandler === 'string') {\n        const handlers = io.getLoadHandlers(pathOrIOHandler, options);\n        if (handlers.length === 0) {\n            // For backward compatibility: if no load handler can be found,\n            // assume it is a relative http path.\n            // TODO(cais): Reformat the args into a single `LoadOptions` once the core\n            // is refactored.\n            handlers.push(io.browserHTTPRequest(pathOrIOHandler, options));\n        }\n        else if (handlers.length > 1) {\n            throw new ValueError(`Found more than one (${handlers.length}) load handlers for ` +\n                `URL '${pathOrIOHandler}'`);\n        }\n        pathOrIOHandler = handlers[0];\n    }\n    return loadLayersModelFromIOHandler(pathOrIOHandler, undefined, options);\n}\n/**\n * Load a model and optionally its weights, using an IOHandler object.\n *\n * @param handler The instance of `IOHandler` to be used during the model\n *   loading.\n * @param customObjects Any optional custom objects to be used during model\n *   loading.\n * @param strict Whether the weight loading will be done in strict mode.\n *   Default: `true`.\n */\nexport async function loadLayersModelFromIOHandler(handler, customObjects, options) {\n    if (options == null) {\n        options = {};\n    }\n    if (handler.load == null) {\n        throw new ValueError('Cannot proceed with model loading because the IOHandler provided ' +\n            'does not have the `load` method implemented.');\n    }\n    const artifacts = await handler.load();\n    let modelTopology = artifacts.modelTopology;\n    if (modelTopology['model_config'] != null) {\n        modelTopology = modelTopology['model_config'];\n    }\n    const strict = options.strict == null ? true : options.strict;\n    // If weights are provided and the weight-loading mode is strict, use\n    // fast weight initialization. This skips costly initializers such as\n    // 'orthogonal' and saves unnecessary computation in cases where\n    // the initialized weight values will immediately be overwritten by\n    // loaded weight values.\n    const fastWeightInit = artifacts.weightData != null && artifacts.weightSpecs != null && strict;\n    const model = deserialize(convertPythonicToTs(modelTopology), customObjects, fastWeightInit);\n    const trainingConfig = artifacts.trainingConfig;\n    if (trainingConfig != null) {\n        model.loadTrainingConfig(trainingConfig);\n    }\n    if (artifacts.userDefinedMetadata != null) {\n        model.setUserDefinedMetadata(artifacts.userDefinedMetadata);\n    }\n    // If weightData is present, load the weights into the model.\n    if (artifacts.weightData != null) {\n        // Loading weights requires weightSpecs.\n        if (artifacts.weightSpecs == null) {\n            throw new ValueError('LayersModel artifacts contains weight data, but not weight specs. ' +\n                'Therefore loading of weights cannot proceed.');\n        }\n        const { modelWeights, optimizerWeights } = decodeModelAndOptimizerWeights(artifacts.weightData, artifacts.weightSpecs);\n        model.loadWeights(modelWeights, strict);\n        if (model.optimizer != null && optimizerWeights.length > 0) {\n            await model.optimizer.setWeights(optimizerWeights);\n        }\n        // Dispose temporary weight values.\n        dispose(modelWeights);\n        dispose(optimizerWeights.map(w => w.tensor));\n    }\n    return model;\n}\nfunction decodeModelAndOptimizerWeights(buffer, specs) {\n    const name2Tensor = io.decodeWeights(buffer, specs);\n    const modelWeights = {};\n    const optimizerWeights = [];\n    specs.forEach(spec => {\n        if (spec.group === 'optimizer') {\n            optimizerWeights.push({ name: spec.name, tensor: name2Tensor[spec.name] });\n        }\n        else {\n            modelWeights[spec.name] = name2Tensor[spec.name];\n        }\n    });\n    return { modelWeights, optimizerWeights };\n}\n/**\n * A model with a stack of layers, feeding linearly from one to the next.\n *\n * `tf.sequential` is a factory function that creates an instance of\n * `tf.Sequential`.\n *\n * ```js\n *  // Define a model for linear regression.\n *  const model = tf.sequential();\n *  model.add(tf.layers.dense({units: 1, inputShape: [1]}));\n *\n *  // Prepare the model for training: Specify the loss and the optimizer.\n *  model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n *\n *  // Generate some synthetic data for training.\n *  const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);\n *  const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);\n *\n *  // Train the model using the data then do inference on a data point the\n *  // model hasn't seen:\n *  await model.fit(xs, ys);\n *  model.predict(tf.tensor2d([5], [1, 1])).print();\n * ```\n *\n * @doc {heading: 'Models', subheading: 'Classes'}\n */\nexport class Sequential extends LayersModel {\n    constructor(args) {\n        super({ inputs: [], outputs: [] });\n        args = args || {};\n        this.trainable = true;\n        this.built = false;\n        // Set model name.\n        this.name = (args.name != null) ? args.name : getUid('sequential_');\n        // Add to the model any layers passed to the constructor.\n        if (args.layers != null) {\n            for (const layer of args.layers) {\n                this.add(layer);\n            }\n        }\n    }\n    // Helper function to Sequential.add  Throws if the new output shape will be\n    // invalid.\n    checkShape(layer) {\n        const shape = layer.inboundNodes[0].outputTensors[0].shape;\n        if (shape.some(x => x < 0)) {\n            throw new ValueError('Negative dimension size caused by adding layer ' +\n                `${layer.name} with input shape [` +\n                `${layer.inboundNodes[0].inputTensors[0].shape}]`);\n        }\n    }\n    /**\n     * Adds a layer instance on top of the layer stack.\n     *\n     * ```js\n     *  const model = tf.sequential();\n     *  model.add(tf.layers.dense({units: 8, inputShape: [1]}));\n     *  model.add(tf.layers.dense({units: 4, activation: 'relu6'}));\n     *  model.add(tf.layers.dense({units: 1, activation: 'relu6'}));\n     *  // Note that the untrained model is random at this point.\n     *  model.predict(tf.randomNormal([10, 1])).print();\n     * ```\n     * @param layer Layer instance.\n     *\n     * @exception ValueError In case the `layer` argument does not know its\n     * input shape.\n     * @exception ValueError In case the `layer` argument has multiple output\n     *   tensors, or is already connected somewhere else (forbidden in\n     *   `Sequential` models).\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    add(layer) {\n        const isLayerModelInstance = layer instanceof Sequential || layer instanceof LayersModel;\n        let modelLayer;\n        if (isLayerModelInstance) {\n            modelLayer = layer;\n            if (modelLayer.outputs.length !== 1) {\n                throw new ValueError('All layers in a Sequential model ' +\n                    'should have a single output tensor. ' +\n                    'For multi-output layers, ' +\n                    'use the functional API.');\n            }\n            if (modelLayer.inputs.length !== 1) {\n                throw new ValueError('All layers in a Sequential model ' +\n                    'should have a single input tensor. ' +\n                    'For multi-input layers, ' +\n                    'use the functional API.');\n            }\n        }\n        if (this.outputs.length === 0) {\n            // first layer in model: check that it is an input layer\n            if (layer.inboundNodes.length === 0) {\n                // create an input layer\n                if (layer.batchInputShape == null) {\n                    throw new ValueError('The first layer in a Sequential model must ' +\n                        'get an `inputShape` or `batchInputShape` argument.');\n                }\n                // Instantiate the input layer.\n                const x = Input({\n                    batchShape: layer.batchInputShape,\n                    dtype: layer.dtype,\n                    name: layer.name + '_input'\n                });\n                // This will build the current layer and create the node connecting\n                // the current layer to the input layer we just created.\n                layer.apply(x);\n            }\n            if (isLayerModelInstance) {\n                this.outputs = modelLayer.outputs;\n                this.inputs = modelLayer.inputs;\n            }\n            else {\n                if (layer.inboundNodes.length !== 1) {\n                    throw new ValueError('A layer added to a Sequential model must not already be ' +\n                        `connected somewhere else. LayersModel received layer ${layer.name} ` +\n                        `which has ${layer.inboundNodes.length} pre-existing inbound ` +\n                        'connections.');\n                }\n                if (layer.inboundNodes[0].outputTensors.length !== 1) {\n                    throw new ValueError('All layers in a Sequential model ' +\n                        'should have a single output tensor. ' +\n                        'For multi-output layers, ' +\n                        'use the functional API.');\n                }\n                this.checkShape(layer);\n                this.outputs = [layer.inboundNodes[0].outputTensors[0]];\n                this.inputs = getSourceInputs(this.outputs[0]);\n            }\n            this.inboundNodes = [];\n            // We create an input node, which we will keep updated\n            // as we add more layers.\n            // (This call has side effects.)\n            // tslint:disable-next-line:no-unused-expression\n            new Node({\n                outboundLayer: this,\n                inboundLayers: [],\n                nodeIndices: [],\n                tensorIndices: [],\n                inputTensors: this.inputs,\n                outputTensors: this.outputs,\n                // no model-level masking for now\n                inputMasks: generic_utils.pyListRepeat(null, this.inputs.length),\n                outputMasks: [null],\n                inputShapes: this.inputs.map(x => x.shape),\n                outputShapes: this.outputs[0].shape\n            });\n        }\n        else {\n            const outputTensor = layer.apply(this.outputs[0]);\n            if (Array.isArray(outputTensor)) {\n                throw new TypeError('All layers in a Sequential model ' +\n                    'should have a single output tensor. ' +\n                    'For multi-output layers, ' +\n                    'use the functional API.');\n            }\n            this.checkShape(layer);\n            this.outputs = [outputTensor];\n            // update self.inbound_nodes\n            this.inboundNodes[0].outputTensors = this.outputs;\n            this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n        }\n        this.layers.push(layer);\n        this.built = false;\n    }\n    /**\n     * Removes the last layer in the model.\n     *\n     * @exception TypeError if there are no layers in the model.\n     */\n    pop() {\n        if (this.layers.length === 0) {\n            throw new TypeError('There are no layers in the model.');\n        }\n        this.layers.pop();\n        if (this.layers.length === 0) {\n            this.outputs = [];\n            this.inboundNodes = [];\n            this.outboundNodes = [];\n        }\n        else {\n            const lastLayerIndex = this.layers.length - 1;\n            this.layers[lastLayerIndex].outboundNodes = [];\n            this.outputs = [this.layers[lastLayerIndex].output];\n            // update self.inbound_nodes\n            this.inboundNodes[0].outputTensors = this.outputs;\n            this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n        }\n    }\n    call(inputs, kwargs) {\n        if (this.model == null) {\n            this.build();\n        }\n        return this.model.call(inputs, kwargs);\n    }\n    build(inputShape) {\n        // Call `getExactlyOneShape` without using its return value,\n        // to verify that exactly one input shape is provided.\n        getExactlyOneShape(inputShape);\n        if (this.inputs.length === 0 || this.outputs.length === 0) {\n            throw new TypeError('Sequential model cannot be built: model is empty.' +\n                ' Add some layers first.');\n        }\n        // actually create the model\n        this.model = new LayersModel({\n            inputs: this.inputs,\n            outputs: this.outputs[0],\n            name: this.name + '_model'\n        });\n        this.model.trainable = this.trainable;\n        // mirror model attributes\n        this.supportsMasking = this.model.supportsMasking;\n        // TODO(michaelterry): Add caches\n        this.inputLayers = this.model.inputLayers;\n        this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;\n        this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;\n        this.outputLayers = this.model.outputLayers;\n        this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;\n        this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;\n        this.nodesByDepth = this.model.nodesByDepth;\n        this.containerNodes = this.model.containerNodes;\n        this.outputNames = this.model.outputNames;\n        this.inputNames = this.model.inputNames;\n        // TODO(michaelterry): Add feedInputNames, feedInputs, if needed.\n        // TODO(michaelterry): Add callbackModel if needed.\n        this.built = true;\n    }\n    countParams() {\n        if (!this.built) {\n            this.build();\n        }\n        return super.countParams();\n    }\n    /**\n     * Print a text summary of the Sequential model's layers.\n     *\n     * The summary includes\n     * - Name and type of all layers that comprise the model.\n     * - Output shape(s) of the layers\n     * - Number of weight parameters of each layer\n     * - The total number of trainable and non-trainable parameters of the\n     * model.\n     *\n     * ```js\n     * const model = tf.sequential();\n     * model.add(\n     *     tf.layers.dense({units: 100, inputShape: [10], activation: 'relu'}));\n     * model.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));\n     *\n     * model.summary();\n     * ```\n     *\n     * @param lineLength Custom line length, in number of characters.\n     * @param positions Custom widths of each of the columns, as either\n     *   fractions of `lineLength` (e.g., `[0.5, 0.75, 1]`) or absolute number\n     *   of characters (e.g., `[30, 50, 65]`). Each number corresponds to\n     *   right-most (i.e., ending) position of a column.\n     * @param printFn Custom print function. Can be used to replace the default\n     *   `console.log`. For example, you can use `x => {}` to mute the printed\n     *   messages in the console.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    summary(lineLength, positions, printFn = console.log) {\n        if (!this.built) {\n            this.build();\n        }\n        super.summary(lineLength, positions, printFn);\n    }\n    /**\n     * Sets the weights of the model.\n     *\n     * @param weights Should be a list of Tensors with shapes and types matching\n     *   the output of `model.getWeights()`.\n     */\n    setWeights(weights) {\n        if (this.model == null) {\n            this.build();\n        }\n        this.model.setWeights(weights);\n    }\n    /**\n     * Returns the loss value & metrics values for the model in test mode.\n     *\n     * Loss and metrics are specified during `compile()`, which needs to happen\n     * before calls to `evaluate()`.\n     *\n     * Computation is done in batches.\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const result = model.evaluate(tf.ones([8, 10]), tf.ones([8, 1]), {\n     *   batchSize: 4,\n     * });\n     * result.print();\n     * ```\n     *\n     * @param x `tf.Tensor` of test data, or an `Array` of `tf.Tensor`s if the\n     * model has multiple inputs.\n     * @param y `tf.Tensor` of target data, or an `Array` of `tf.Tensor`s if the\n     * model has multiple outputs.\n     * @param args A `ModelEvaluateConfig`, containing optional fields.\n     *\n     * @return `Scalar` test loss (if the model has a single output and no\n     *   metrics) or `Array` of `Scalar`s (if the model has multiple outputs\n     *   and/or metrics). The attribute `model.metricsNames`\n     *   will give you the display labels for the scalar outputs.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    evaluate(x, y, args = {}) {\n        if (!this.built) {\n            throw new RuntimeError('The model needs to be compiled before being used.');\n        }\n        return this.model.evaluate(x, y, args);\n    }\n    // TODO(cais): Add code snippet below once real dataset objects are\n    //   available.\n    /**\n     * Evaluate model using a dataset object.\n     *\n     * Note: Unlike `evaluate()`, this method is asynchronous (`async`);\n     *\n     * @param dataset A dataset object. Its `iterator()` method is expected\n     *   to generate a dataset iterator object, the `next()` method of which\n     *   is expected to produce data batches for evaluation. The return value\n     *   of the `next()` call ought to contain a boolean `done` field and a\n     *   `value` field. The `value` field is expected to be an array of two\n     *   `tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former\n     *   case is for models with exactly one input and one output (e.g..\n     *   a sequential model). The latter case is for models with multiple\n     *   inputs and/or multiple outputs. Of the two items in the array, the\n     *   first is the input feature(s) and the second is the output target(s).\n     * @param args A configuration object for the dataset-based evaluation.\n     * @returns Loss and metric values as an Array of `Scalar` objects.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    async evaluateDataset(dataset, args) {\n        if (!this.built) {\n            throw new RuntimeError('The model needs to be compiled before being used.');\n        }\n        return this.model.evaluateDataset(dataset, args);\n    }\n    /**\n     * Generates output predictions for the input samples.\n     *\n     * Computation is done in batches.\n     *\n     * Note: the \"step\" mode of predict() is currently not supported.\n     *   This is because the TensorFow.js core backend is imperative only.\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.predict(tf.ones([2, 10])).print();\n     * ```\n     *\n     * @param x The input data, as a Tensor, or an `Array` of `tf.Tensor`s if\n     *   the model has multiple inputs.\n     * @param conifg A `ModelPredictConfig` object containing optional fields.\n     *\n     * @return `tf.Tensor`(s) of predictions.\n     *\n     * @exception ValueError In case of mismatch between the provided input data\n     *   and the model's expectations, or in case a stateful model receives a\n     *   number of samples that is not a multiple of the batch size.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    predict(x, args = {}) {\n        if (this.model == null) {\n            this.build();\n        }\n        return this.model.predict(x, args);\n    }\n    /**\n     * Returns predictions for a single batch of samples.\n     *\n     * @param x: Input samples, as a Tensor, or list of Tensors (if the model\n     *   has multiple inputs).\n     * @return Tensor(s) of predictions\n     */\n    predictOnBatch(x) {\n        if (this.model == null) {\n            this.build();\n        }\n        return this.model.predictOnBatch(x);\n    }\n    /**\n     * See `LayersModel.compile`.\n     *\n     * @param args\n     */\n    compile(args) {\n        this.build();\n        this.model.compile(args);\n        this.optimizer_ = this.model.optimizer;\n        // tslint:disable-next-line:no-any\n        this.isOptimizerOwned = this.model.isOptimizerOwned;\n        this.loss = this.model.loss;\n        this.metrics = this.model.metrics;\n        // TODO(cais): Add this.lossWeights, this.sampleWeightMode,\n        //   this.weightedMetrics, this.targets.\n        this.metricsTensors = this.model.metricsTensors;\n        this.metricsNames = this.model.metricsNames;\n        // TODO(cais): Add sampleWeights.\n    }\n    get optimizer() {\n        return this.model == null ? undefined : this.model.optimizer;\n    }\n    set optimizer(optimizer) {\n        this.model.optimizer = optimizer;\n    }\n    /**\n     * Trains the model for a fixed number of epochs (iterations on a dataset).\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const history = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {\n     *   batchSize: 4,\n     *   epochs: 3\n     * });\n     * console.log(history.history.loss[0]);\n     * ```\n     *\n     * @param x `tf.Tensor` of training data, or an array of `tf.Tensor`s if the\n     * model has multiple inputs. If all inputs in the model are named, you can\n     * also pass a dictionary mapping input names to `tf.Tensor`s.\n     * @param y `tf.Tensor` of target (label) data, or an array of `tf.Tensor`s if\n     * the model has multiple outputs. If all outputs in the model are named, you\n     *  can also pass a dictionary mapping output names to `tf.Tensor`s.\n     * @param args  A `ModelFitConfig`, containing optional fields.\n     *\n     * @return A `History` instance. Its `history` attribute contains all\n     *   information collected during training.\n     *\n     * @exception ValueError In case of mismatch between the provided input data\n     *   and what the model expects.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    async fit(x, y, args = {}) {\n        if (!this.built) {\n            throw new RuntimeError('The model needs to be compiled before ' +\n                'being used.');\n        }\n        return this.model.fit(x, y, args);\n    }\n    /**\n     * Trains the model using a dataset object.\n     *\n     * ```js\n     * const xArray = [\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     * ];\n     * const yArray = [1, 1, 1, 1];\n     * // Create a dataset from the JavaScript array.\n     * const xDataset = tf.data.array(xArray);\n     * const yDataset = tf.data.array(yArray);\n     * // Zip combines the `x` and `y` Datasets into a single Dataset, the\n     * // iterator of which will return an object containing of two tensors,\n     * // corresponding to `x` and `y`.  The call to `batch(4)` will bundle\n     * // four such samples into a single object, with the same keys now pointing\n     * // to tensors that hold 4 examples, organized along the batch dimension.\n     * // The call to `shuffle(4)` causes each iteration through the dataset to\n     * // happen in a different order.  The size of the shuffle window is 4.\n     * const xyDataset = tf.data.zip({xs: xDataset, ys: yDataset})\n     *     .batch(4)\n     *     .shuffle(4);\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [9]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const history = await model.fitDataset(xyDataset, {\n     *   epochs: 4,\n     *   callbacks: {onEpochEnd: (epoch, logs) => console.log(logs.loss)}\n     * });\n     * ```\n     *\n     * @param dataset A dataset object. Its `iterator()` method is expected to\n     *   generate a dataset iterator object, the `next()` method of which is\n     *   expected to produce data batches for evaluation. The return value of the\n     *   `next()` call ought to contain a boolean `done` field and a `value`\n     *   field.\n     *\n     *   The `value` field is expected to be an object of with fields\n     *   `xs` and `ys`, which point to the feature tensor and the target tensor,\n     *   respectively. This case is for models with exactly one input and one\n     *   output (e.g.. a sequential model). For example:\n     *   ```js\n     *   {value: {xs: xsTensor, ys: ysTensor}, done: false}\n     *   ```\n     *\n     *   If the model has multiple inputs, the `xs` field of `value` should\n     *   be an object mapping input names to their respective feature tensors.\n     *   For example:\n     *   ```js\n     *   {\n     *     value: {\n     *       xs: {\n     *         input_1: xsTensor1,\n     *         input_2: xsTensor2\n     *       },\n     *       ys: ysTensor\n     *     },\n     *     done: false\n     *   }\n     *   ```\n     *   If the model has multiple outputs, the `ys` field of `value` should\n     *   be an object mapping output names to their respective target tensors.\n     *   For example:\n     *   ```js\n     *   {\n     *     value: {\n     *       xs: xsTensor,\n     *       ys: {\n     *         output_1: ysTensor1,\n     *         output_2: ysTensor2\n     *       },\n     *     },\n     *     done: false\n     *   }\n     *   ```\n     * @param args A `ModelFitDatasetArgs`, containing optional fields.\n     *\n     * @return A `History` instance. Its `history` attribute contains all\n     *   information collected during training.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}\n     */\n    async fitDataset(dataset, args) {\n        if (!this.built) {\n            throw new RuntimeError('The model needs to be compiled before ' +\n                'being used.');\n        }\n        return this.model.fitDataset(dataset, args);\n    }\n    /**\n     * Runs a single gradient update on a single batch of data.\n     *\n     * This method differs from `fit()` and `fitDataset()` in the following\n     * regards:\n     *   - It operates on exactly one batch of data.\n     *   - It returns only the loss and matric values, instead of\n     *     returning the batch-by-batch loss and metric values.\n     *   - It doesn't support fine-grained options such as verbosity and\n     *     callbacks.\n     *\n     * @param x Input data. It could be one of the following:\n     *   - A `tf.Tensor`, or an Array of `tf.Tensor`s (in case the model has\n     *     multiple inputs).\n     *   - An Object mapping input names to corresponding `tf.Tensor` (if the\n     *     model has named inputs).\n     * @param y Target darta. It could be either a `tf.Tensor` a multiple\n     *   `tf.Tensor`s. It should be consistent with `x`.\n     * @returns Training loss or losses (in case the model has\n     *   multiple outputs), along with metrics (if any), as numbers.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    async trainOnBatch(x, y) {\n        return this.model.trainOnBatch(x, y);\n    }\n    /* See parent class for JsDoc */\n    /** @nocollapse */\n    static fromConfig(cls, config, customObjects = {}, fastWeightInit = false) {\n        let configArray;\n        let extraModelConfig = {};\n        if (config instanceof Array) {\n            if (!(config[0].className != null) ||\n                config[0]['className'] === 'Merge') {\n                throw new ValueError('Legacy serialization format not supported yet.');\n            }\n            configArray = config;\n        }\n        else {\n            util.assert(config['layers'] != null, () => `When the config data for a Sequential model is not an Array, ` +\n                `it must be an Object that contains the 'layers' field.`);\n            configArray = config['layers'];\n            delete config['layers'];\n            extraModelConfig = config;\n        }\n        const model = new cls(extraModelConfig);\n        if (!(model instanceof Sequential)) {\n            throw new NotImplementedError(`Sequential.fromConfig called on non-Sequential input: ${model}`);\n        }\n        for (const conf of configArray) {\n            const customObjects = undefined;\n            const layer = deserialize(conf, customObjects, fastWeightInit);\n            if (fastWeightInit) {\n                layer.setFastWeightInitDuringBuild(true);\n            }\n            model.add(layer);\n        }\n        return model;\n    }\n    /**\n     * Setter used for force stopping of LayersModel.fit() (i.e., training).\n     *\n     * Example:\n     *\n     * ```js\n     * const model = tf.sequential();\n     * model.add(tf.layers.dense({units: 1, inputShape: [10]}));\n     * model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n     * const xs = tf.ones([8, 10]);\n     * const ys = tf.zeros([8, 1]);\n     *\n     * const history = await model.fit(xs, ys, {\n     *   epochs: 10,\n     *   callbacks: {\n     *     onEpochEnd: async (epoch, logs) => {\n     *       if (epoch === 2) {\n     *         model.stopTraining = true;\n     *       }\n     *     }\n     *   }\n     * });\n     *\n     * // There should be only 3 values in the loss array, instead of 10 values,\n     * // due to the stopping after 3 epochs.\n     * console.log(history.history.loss);\n     * ```\n     */\n    set stopTraining(stop) {\n        // TODO(cais): When refactoring to remove the composition pattern happens,\n        // remove this method overriding.\n        if (this.model == null) {\n            throw new ValueError('Cannot set the stopTraining property of a sequential model before ' +\n                'it is compiled.');\n        }\n        this.model.stopTraining = stop;\n    }\n    get stopTraining() {\n        if (this.model == null) {\n            throw new ValueError('Cannot get the stopTraining property of a sequential model before ' +\n                'it is compiled.');\n        }\n        return this.model.stopTraining;\n    }\n    // TODO(cais): Override get trainableWeights() here\n    // tslint:disable-next-line:no-any\n    getConfig() {\n        // NOTE(cais): We override the return type of getConfig() to `any` here,\n        //   because the `Sequential` class is a special case among `Container`\n        //   subtypes in that its getConfig() method returns an Array (not a\n        //   dict).\n        const layers = [];\n        for (const layer of this.layers) {\n            const dict = {};\n            dict['className'] = layer.getClassName();\n            dict['config'] = layer.getConfig();\n            layers.push(dict);\n        }\n        return { name: this.name, layers };\n    }\n}\n/** @nocollapse */\nSequential.className = 'Sequential';\nserialization.registerClass(Sequential);\n"]},"metadata":{},"sourceType":"module"}
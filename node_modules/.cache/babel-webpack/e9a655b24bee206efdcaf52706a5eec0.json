{"ast":null,"code":"import _asyncToGenerator from \"/Users/ryanliang/Downloads/main_movir_picker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport '../flags';\nimport { env } from '../environment';\nimport { getModelArtifactsInfoForJSON } from './io_utils';\nimport { IORouterRegistry } from './router_registry';\nconst DATABASE_NAME = 'tensorflowjs';\nconst DATABASE_VERSION = 1; // Model data and ModelArtifactsInfo (metadata) are stored in two separate\n// stores for efficient access of the list of stored models and their metadata.\n// 1. The object store for model data: topology, weights and weight manifests.\n\nconst MODEL_STORE_NAME = 'models_store'; // 2. The object store for ModelArtifactsInfo, including meta-information such\n//    as the type of topology (JSON vs binary), byte size of the topology, byte\n//    size of the weights, etc.\n\nconst INFO_STORE_NAME = 'model_info_store';\n/**\n * Delete the entire database for tensorflow.js, including the models store.\n */\n\nexport function deleteDatabase() {\n  return _deleteDatabase.apply(this, arguments);\n}\n\nfunction _deleteDatabase() {\n  _deleteDatabase = _asyncToGenerator(function* () {\n    const idbFactory = getIndexedDBFactory();\n    return new Promise((resolve, reject) => {\n      const deleteRequest = idbFactory.deleteDatabase(DATABASE_NAME);\n\n      deleteRequest.onsuccess = () => resolve();\n\n      deleteRequest.onerror = error => reject(error);\n    });\n  });\n  return _deleteDatabase.apply(this, arguments);\n}\n\nfunction getIndexedDBFactory() {\n  if (!env().getBool('IS_BROWSER')) {\n    // TODO(cais): Add more info about what IOHandler subtypes are available.\n    //   Maybe point to a doc page on the web and/or automatically determine\n    //   the available IOHandlers and print them in the error message.\n    throw new Error('Failed to obtain IndexedDB factory because the current environment' + 'is not a web browser.');\n  } // tslint:disable-next-line:no-any\n\n\n  const theWindow = typeof window === 'undefined' ? self : window;\n  const factory = theWindow.indexedDB || theWindow.mozIndexedDB || theWindow.webkitIndexedDB || theWindow.msIndexedDB || theWindow.shimIndexedDB;\n\n  if (factory == null) {\n    throw new Error('The current browser does not appear to support IndexedDB.');\n  }\n\n  return factory;\n}\n\nfunction setUpDatabase(openRequest) {\n  const db = openRequest.result;\n  db.createObjectStore(MODEL_STORE_NAME, {\n    keyPath: 'modelPath'\n  });\n  db.createObjectStore(INFO_STORE_NAME, {\n    keyPath: 'modelPath'\n  });\n}\n/**\n * IOHandler subclass: Browser IndexedDB.\n *\n * See the doc string of `browserIndexedDB` for more details.\n */\n\n\nexport class BrowserIndexedDB {\n  constructor(modelPath) {\n    this.indexedDB = getIndexedDBFactory();\n\n    if (modelPath == null || !modelPath) {\n      throw new Error('For IndexedDB, modelPath must not be null, undefined or empty.');\n    }\n\n    this.modelPath = modelPath;\n  }\n\n  save(modelArtifacts) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // TODO(cais): Support saving GraphDef models.\n      if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n        throw new Error('BrowserLocalStorage.save() does not support saving model topology ' + 'in binary formats yet.');\n      }\n\n      return _this.databaseAction(_this.modelPath, modelArtifacts);\n    })();\n  }\n\n  load() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this2.databaseAction(_this2.modelPath);\n    })();\n  }\n  /**\n   * Perform database action to put model artifacts into or read model artifacts\n   * from IndexedDB object store.\n   *\n   * Whether the action is put or get depends on whether `modelArtifacts` is\n   * specified. If it is specified, the action will be put; otherwise the action\n   * will be get.\n   *\n   * @param modelPath A unique string path for the model.\n   * @param modelArtifacts If specified, it will be the model artifacts to be\n   *   stored in IndexedDB.\n   * @returns A `Promise` of `SaveResult`, if the action is put, or a `Promise`\n   *   of `ModelArtifacts`, if the action is get.\n   */\n\n\n  databaseAction(modelPath, modelArtifacts) {\n    return new Promise((resolve, reject) => {\n      const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n\n      openRequest.onupgradeneeded = () => setUpDatabase(openRequest);\n\n      openRequest.onsuccess = () => {\n        const db = openRequest.result;\n\n        if (modelArtifacts == null) {\n          // Read model out from object store.\n          const modelTx = db.transaction(MODEL_STORE_NAME, 'readonly');\n          const modelStore = modelTx.objectStore(MODEL_STORE_NAME);\n          const getRequest = modelStore.get(this.modelPath);\n\n          getRequest.onsuccess = () => {\n            if (getRequest.result == null) {\n              db.close();\n              return reject(new Error(`Cannot find model with path '${this.modelPath}' ` + `in IndexedDB.`));\n            } else {\n              resolve(getRequest.result.modelArtifacts);\n            }\n          };\n\n          getRequest.onerror = error => {\n            db.close();\n            return reject(getRequest.error);\n          };\n\n          modelTx.oncomplete = () => db.close();\n        } else {\n          // Put model into object store.\n          const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts); // First, put ModelArtifactsInfo into info store.\n\n          const infoTx = db.transaction(INFO_STORE_NAME, 'readwrite');\n          let infoStore = infoTx.objectStore(INFO_STORE_NAME);\n          const putInfoRequest = infoStore.put({\n            modelPath: this.modelPath,\n            modelArtifactsInfo\n          });\n          let modelTx;\n\n          putInfoRequest.onsuccess = () => {\n            // Second, put model data into model store.\n            modelTx = db.transaction(MODEL_STORE_NAME, 'readwrite');\n            const modelStore = modelTx.objectStore(MODEL_STORE_NAME);\n            const putModelRequest = modelStore.put({\n              modelPath: this.modelPath,\n              modelArtifacts,\n              modelArtifactsInfo\n            });\n\n            putModelRequest.onsuccess = () => resolve({\n              modelArtifactsInfo\n            });\n\n            putModelRequest.onerror = error => {\n              // If the put-model request fails, roll back the info entry as\n              // well.\n              infoStore = infoTx.objectStore(INFO_STORE_NAME);\n              const deleteInfoRequest = infoStore.delete(this.modelPath);\n\n              deleteInfoRequest.onsuccess = () => {\n                db.close();\n                return reject(putModelRequest.error);\n              };\n\n              deleteInfoRequest.onerror = error => {\n                db.close();\n                return reject(putModelRequest.error);\n              };\n            };\n          };\n\n          putInfoRequest.onerror = error => {\n            db.close();\n            return reject(putInfoRequest.error);\n          };\n\n          infoTx.oncomplete = () => {\n            if (modelTx == null) {\n              db.close();\n            } else {\n              modelTx.oncomplete = () => db.close();\n            }\n          };\n        }\n      };\n\n      openRequest.onerror = error => reject(openRequest.error);\n    });\n  }\n\n}\nBrowserIndexedDB.URL_SCHEME = 'indexeddb://';\nexport const indexedDBRouter = url => {\n  if (!env().getBool('IS_BROWSER')) {\n    return null;\n  } else {\n    if (!Array.isArray(url) && url.startsWith(BrowserIndexedDB.URL_SCHEME)) {\n      return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length));\n    } else {\n      return null;\n    }\n  }\n};\nIORouterRegistry.registerSaveRouter(indexedDBRouter);\nIORouterRegistry.registerLoadRouter(indexedDBRouter);\n/**\n * Creates a browser IndexedDB IOHandler for saving and loading models.\n *\n * ```js\n * const model = tf.sequential();\n * model.add(\n *     tf.layers.dense({units: 1, inputShape: [100], activation: 'sigmoid'}));\n *\n * const saveResult = await model.save('indexeddb://MyModel'));\n * console.log(saveResult);\n * ```\n *\n * @param modelPath A unique identifier for the model to be saved. Must be a\n *   non-empty string.\n * @returns An instance of `BrowserIndexedDB` (sublcass of `IOHandler`),\n *   which can be used with, e.g., `tf.Model.save`.\n */\n\nexport function browserIndexedDB(modelPath) {\n  return new BrowserIndexedDB(modelPath);\n}\n\nfunction maybeStripScheme(key) {\n  return key.startsWith(BrowserIndexedDB.URL_SCHEME) ? key.slice(BrowserIndexedDB.URL_SCHEME.length) : key;\n}\n\nexport class BrowserIndexedDBManager {\n  constructor() {\n    this.indexedDB = getIndexedDBFactory();\n  }\n\n  listModels() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        const openRequest = _this3.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n\n        openRequest.onupgradeneeded = () => setUpDatabase(openRequest);\n\n        openRequest.onsuccess = () => {\n          const db = openRequest.result;\n          const tx = db.transaction(INFO_STORE_NAME, 'readonly');\n          const store = tx.objectStore(INFO_STORE_NAME); // tslint:disable:max-line-length\n          // Need to cast `store` as `any` here because TypeScript's DOM\n          // library does not have the `getAll()` method even though the\n          // method is supported in the latest version of most mainstream\n          // browsers:\n          // https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll\n          // tslint:enable:max-line-length\n          // tslint:disable-next-line:no-any\n\n          const getAllInfoRequest = store.getAll();\n\n          getAllInfoRequest.onsuccess = () => {\n            const out = {};\n\n            for (const item of getAllInfoRequest.result) {\n              out[item.modelPath] = item.modelArtifactsInfo;\n            }\n\n            resolve(out);\n          };\n\n          getAllInfoRequest.onerror = error => {\n            db.close();\n            return reject(getAllInfoRequest.error);\n          };\n\n          tx.oncomplete = () => db.close();\n        };\n\n        openRequest.onerror = error => reject(openRequest.error);\n      });\n    })();\n  }\n\n  removeModel(path) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      path = maybeStripScheme(path);\n      return new Promise((resolve, reject) => {\n        const openRequest = _this4.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n\n        openRequest.onupgradeneeded = () => setUpDatabase(openRequest);\n\n        openRequest.onsuccess = () => {\n          const db = openRequest.result;\n          const infoTx = db.transaction(INFO_STORE_NAME, 'readwrite');\n          const infoStore = infoTx.objectStore(INFO_STORE_NAME);\n          const getInfoRequest = infoStore.get(path);\n          let modelTx;\n\n          getInfoRequest.onsuccess = () => {\n            if (getInfoRequest.result == null) {\n              db.close();\n              return reject(new Error(`Cannot find model with path '${path}' ` + `in IndexedDB.`));\n            } else {\n              // First, delete the entry in the info store.\n              const deleteInfoRequest = infoStore.delete(path);\n\n              const deleteModelData = () => {\n                // Second, delete the entry in the model store.\n                modelTx = db.transaction(MODEL_STORE_NAME, 'readwrite');\n                const modelStore = modelTx.objectStore(MODEL_STORE_NAME);\n                const deleteModelRequest = modelStore.delete(path);\n\n                deleteModelRequest.onsuccess = () => resolve(getInfoRequest.result.modelArtifactsInfo);\n\n                deleteModelRequest.onerror = error => reject(getInfoRequest.error);\n              }; // Proceed with deleting model data regardless of whether deletion\n              // of info data succeeds or not.\n\n\n              deleteInfoRequest.onsuccess = deleteModelData;\n\n              deleteInfoRequest.onerror = error => {\n                deleteModelData();\n                db.close();\n                return reject(getInfoRequest.error);\n              };\n            }\n          };\n\n          getInfoRequest.onerror = error => {\n            db.close();\n            return reject(getInfoRequest.error);\n          };\n\n          infoTx.oncomplete = () => {\n            if (modelTx == null) {\n              db.close();\n            } else {\n              modelTx.oncomplete = () => db.close();\n            }\n          };\n        };\n\n        openRequest.onerror = error => reject(openRequest.error);\n      });\n    })();\n  }\n\n}","map":{"version":3,"sources":["/Users/ryanliang/Downloads/main_movir_picker/node_modules/@tensorflow/tfjs-core/dist/io/indexed_db.js"],"names":["env","getModelArtifactsInfoForJSON","IORouterRegistry","DATABASE_NAME","DATABASE_VERSION","MODEL_STORE_NAME","INFO_STORE_NAME","deleteDatabase","idbFactory","getIndexedDBFactory","Promise","resolve","reject","deleteRequest","onsuccess","onerror","error","getBool","Error","theWindow","window","self","factory","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","shimIndexedDB","setUpDatabase","openRequest","db","result","createObjectStore","keyPath","BrowserIndexedDB","constructor","modelPath","save","modelArtifacts","modelTopology","ArrayBuffer","databaseAction","load","open","onupgradeneeded","modelTx","transaction","modelStore","objectStore","getRequest","get","close","oncomplete","modelArtifactsInfo","infoTx","infoStore","putInfoRequest","put","putModelRequest","deleteInfoRequest","delete","URL_SCHEME","indexedDBRouter","url","Array","isArray","startsWith","browserIndexedDB","slice","length","registerSaveRouter","registerLoadRouter","maybeStripScheme","key","BrowserIndexedDBManager","listModels","tx","store","getAllInfoRequest","getAll","out","item","removeModel","path","getInfoRequest","deleteModelData","deleteModelRequest"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport '../flags';\nimport { env } from '../environment';\nimport { getModelArtifactsInfoForJSON } from './io_utils';\nimport { IORouterRegistry } from './router_registry';\nconst DATABASE_NAME = 'tensorflowjs';\nconst DATABASE_VERSION = 1;\n// Model data and ModelArtifactsInfo (metadata) are stored in two separate\n// stores for efficient access of the list of stored models and their metadata.\n// 1. The object store for model data: topology, weights and weight manifests.\nconst MODEL_STORE_NAME = 'models_store';\n// 2. The object store for ModelArtifactsInfo, including meta-information such\n//    as the type of topology (JSON vs binary), byte size of the topology, byte\n//    size of the weights, etc.\nconst INFO_STORE_NAME = 'model_info_store';\n/**\n * Delete the entire database for tensorflow.js, including the models store.\n */\nexport async function deleteDatabase() {\n    const idbFactory = getIndexedDBFactory();\n    return new Promise((resolve, reject) => {\n        const deleteRequest = idbFactory.deleteDatabase(DATABASE_NAME);\n        deleteRequest.onsuccess = () => resolve();\n        deleteRequest.onerror = error => reject(error);\n    });\n}\nfunction getIndexedDBFactory() {\n    if (!env().getBool('IS_BROWSER')) {\n        // TODO(cais): Add more info about what IOHandler subtypes are available.\n        //   Maybe point to a doc page on the web and/or automatically determine\n        //   the available IOHandlers and print them in the error message.\n        throw new Error('Failed to obtain IndexedDB factory because the current environment' +\n            'is not a web browser.');\n    }\n    // tslint:disable-next-line:no-any\n    const theWindow = typeof window === 'undefined' ? self : window;\n    const factory = theWindow.indexedDB || theWindow.mozIndexedDB ||\n        theWindow.webkitIndexedDB || theWindow.msIndexedDB ||\n        theWindow.shimIndexedDB;\n    if (factory == null) {\n        throw new Error('The current browser does not appear to support IndexedDB.');\n    }\n    return factory;\n}\nfunction setUpDatabase(openRequest) {\n    const db = openRequest.result;\n    db.createObjectStore(MODEL_STORE_NAME, { keyPath: 'modelPath' });\n    db.createObjectStore(INFO_STORE_NAME, { keyPath: 'modelPath' });\n}\n/**\n * IOHandler subclass: Browser IndexedDB.\n *\n * See the doc string of `browserIndexedDB` for more details.\n */\nexport class BrowserIndexedDB {\n    constructor(modelPath) {\n        this.indexedDB = getIndexedDBFactory();\n        if (modelPath == null || !modelPath) {\n            throw new Error('For IndexedDB, modelPath must not be null, undefined or empty.');\n        }\n        this.modelPath = modelPath;\n    }\n    async save(modelArtifacts) {\n        // TODO(cais): Support saving GraphDef models.\n        if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n            throw new Error('BrowserLocalStorage.save() does not support saving model topology ' +\n                'in binary formats yet.');\n        }\n        return this.databaseAction(this.modelPath, modelArtifacts);\n    }\n    async load() {\n        return this.databaseAction(this.modelPath);\n    }\n    /**\n     * Perform database action to put model artifacts into or read model artifacts\n     * from IndexedDB object store.\n     *\n     * Whether the action is put or get depends on whether `modelArtifacts` is\n     * specified. If it is specified, the action will be put; otherwise the action\n     * will be get.\n     *\n     * @param modelPath A unique string path for the model.\n     * @param modelArtifacts If specified, it will be the model artifacts to be\n     *   stored in IndexedDB.\n     * @returns A `Promise` of `SaveResult`, if the action is put, or a `Promise`\n     *   of `ModelArtifacts`, if the action is get.\n     */\n    databaseAction(modelPath, modelArtifacts) {\n        return new Promise((resolve, reject) => {\n            const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n            openRequest.onupgradeneeded = () => setUpDatabase(openRequest);\n            openRequest.onsuccess = () => {\n                const db = openRequest.result;\n                if (modelArtifacts == null) {\n                    // Read model out from object store.\n                    const modelTx = db.transaction(MODEL_STORE_NAME, 'readonly');\n                    const modelStore = modelTx.objectStore(MODEL_STORE_NAME);\n                    const getRequest = modelStore.get(this.modelPath);\n                    getRequest.onsuccess = () => {\n                        if (getRequest.result == null) {\n                            db.close();\n                            return reject(new Error(`Cannot find model with path '${this.modelPath}' ` +\n                                `in IndexedDB.`));\n                        }\n                        else {\n                            resolve(getRequest.result.modelArtifacts);\n                        }\n                    };\n                    getRequest.onerror = error => {\n                        db.close();\n                        return reject(getRequest.error);\n                    };\n                    modelTx.oncomplete = () => db.close();\n                }\n                else {\n                    // Put model into object store.\n                    const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);\n                    // First, put ModelArtifactsInfo into info store.\n                    const infoTx = db.transaction(INFO_STORE_NAME, 'readwrite');\n                    let infoStore = infoTx.objectStore(INFO_STORE_NAME);\n                    const putInfoRequest = infoStore.put({ modelPath: this.modelPath, modelArtifactsInfo });\n                    let modelTx;\n                    putInfoRequest.onsuccess = () => {\n                        // Second, put model data into model store.\n                        modelTx = db.transaction(MODEL_STORE_NAME, 'readwrite');\n                        const modelStore = modelTx.objectStore(MODEL_STORE_NAME);\n                        const putModelRequest = modelStore.put({\n                            modelPath: this.modelPath,\n                            modelArtifacts,\n                            modelArtifactsInfo\n                        });\n                        putModelRequest.onsuccess = () => resolve({ modelArtifactsInfo });\n                        putModelRequest.onerror = error => {\n                            // If the put-model request fails, roll back the info entry as\n                            // well.\n                            infoStore = infoTx.objectStore(INFO_STORE_NAME);\n                            const deleteInfoRequest = infoStore.delete(this.modelPath);\n                            deleteInfoRequest.onsuccess = () => {\n                                db.close();\n                                return reject(putModelRequest.error);\n                            };\n                            deleteInfoRequest.onerror = error => {\n                                db.close();\n                                return reject(putModelRequest.error);\n                            };\n                        };\n                    };\n                    putInfoRequest.onerror = error => {\n                        db.close();\n                        return reject(putInfoRequest.error);\n                    };\n                    infoTx.oncomplete = () => {\n                        if (modelTx == null) {\n                            db.close();\n                        }\n                        else {\n                            modelTx.oncomplete = () => db.close();\n                        }\n                    };\n                }\n            };\n            openRequest.onerror = error => reject(openRequest.error);\n        });\n    }\n}\nBrowserIndexedDB.URL_SCHEME = 'indexeddb://';\nexport const indexedDBRouter = (url) => {\n    if (!env().getBool('IS_BROWSER')) {\n        return null;\n    }\n    else {\n        if (!Array.isArray(url) && url.startsWith(BrowserIndexedDB.URL_SCHEME)) {\n            return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length));\n        }\n        else {\n            return null;\n        }\n    }\n};\nIORouterRegistry.registerSaveRouter(indexedDBRouter);\nIORouterRegistry.registerLoadRouter(indexedDBRouter);\n/**\n * Creates a browser IndexedDB IOHandler for saving and loading models.\n *\n * ```js\n * const model = tf.sequential();\n * model.add(\n *     tf.layers.dense({units: 1, inputShape: [100], activation: 'sigmoid'}));\n *\n * const saveResult = await model.save('indexeddb://MyModel'));\n * console.log(saveResult);\n * ```\n *\n * @param modelPath A unique identifier for the model to be saved. Must be a\n *   non-empty string.\n * @returns An instance of `BrowserIndexedDB` (sublcass of `IOHandler`),\n *   which can be used with, e.g., `tf.Model.save`.\n */\nexport function browserIndexedDB(modelPath) {\n    return new BrowserIndexedDB(modelPath);\n}\nfunction maybeStripScheme(key) {\n    return key.startsWith(BrowserIndexedDB.URL_SCHEME) ?\n        key.slice(BrowserIndexedDB.URL_SCHEME.length) :\n        key;\n}\nexport class BrowserIndexedDBManager {\n    constructor() {\n        this.indexedDB = getIndexedDBFactory();\n    }\n    async listModels() {\n        return new Promise((resolve, reject) => {\n            const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n            openRequest.onupgradeneeded = () => setUpDatabase(openRequest);\n            openRequest.onsuccess = () => {\n                const db = openRequest.result;\n                const tx = db.transaction(INFO_STORE_NAME, 'readonly');\n                const store = tx.objectStore(INFO_STORE_NAME);\n                // tslint:disable:max-line-length\n                // Need to cast `store` as `any` here because TypeScript's DOM\n                // library does not have the `getAll()` method even though the\n                // method is supported in the latest version of most mainstream\n                // browsers:\n                // https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll\n                // tslint:enable:max-line-length\n                // tslint:disable-next-line:no-any\n                const getAllInfoRequest = store.getAll();\n                getAllInfoRequest.onsuccess = () => {\n                    const out = {};\n                    for (const item of getAllInfoRequest.result) {\n                        out[item.modelPath] = item.modelArtifactsInfo;\n                    }\n                    resolve(out);\n                };\n                getAllInfoRequest.onerror = error => {\n                    db.close();\n                    return reject(getAllInfoRequest.error);\n                };\n                tx.oncomplete = () => db.close();\n            };\n            openRequest.onerror = error => reject(openRequest.error);\n        });\n    }\n    async removeModel(path) {\n        path = maybeStripScheme(path);\n        return new Promise((resolve, reject) => {\n            const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n            openRequest.onupgradeneeded = () => setUpDatabase(openRequest);\n            openRequest.onsuccess = () => {\n                const db = openRequest.result;\n                const infoTx = db.transaction(INFO_STORE_NAME, 'readwrite');\n                const infoStore = infoTx.objectStore(INFO_STORE_NAME);\n                const getInfoRequest = infoStore.get(path);\n                let modelTx;\n                getInfoRequest.onsuccess = () => {\n                    if (getInfoRequest.result == null) {\n                        db.close();\n                        return reject(new Error(`Cannot find model with path '${path}' ` +\n                            `in IndexedDB.`));\n                    }\n                    else {\n                        // First, delete the entry in the info store.\n                        const deleteInfoRequest = infoStore.delete(path);\n                        const deleteModelData = () => {\n                            // Second, delete the entry in the model store.\n                            modelTx = db.transaction(MODEL_STORE_NAME, 'readwrite');\n                            const modelStore = modelTx.objectStore(MODEL_STORE_NAME);\n                            const deleteModelRequest = modelStore.delete(path);\n                            deleteModelRequest.onsuccess = () => resolve(getInfoRequest.result.modelArtifactsInfo);\n                            deleteModelRequest.onerror = error => reject(getInfoRequest.error);\n                        };\n                        // Proceed with deleting model data regardless of whether deletion\n                        // of info data succeeds or not.\n                        deleteInfoRequest.onsuccess = deleteModelData;\n                        deleteInfoRequest.onerror = error => {\n                            deleteModelData();\n                            db.close();\n                            return reject(getInfoRequest.error);\n                        };\n                    }\n                };\n                getInfoRequest.onerror = error => {\n                    db.close();\n                    return reject(getInfoRequest.error);\n                };\n                infoTx.oncomplete = () => {\n                    if (modelTx == null) {\n                        db.close();\n                    }\n                    else {\n                        modelTx.oncomplete = () => db.close();\n                    }\n                };\n            };\n            openRequest.onerror = error => reject(openRequest.error);\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}
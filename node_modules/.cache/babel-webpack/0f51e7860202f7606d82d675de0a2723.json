{"ast":null,"code":"import _asyncToGenerator from \"/Users/ryanliang/Downloads/main_movir_picker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { Dataset } from '../dataset';\nimport { TextLineDataset } from './text_line_dataset';\nconst CODE_QUOTE = '\"';\nconst STATE_OUT = Symbol('out');\nconst STATE_FIELD = Symbol('field');\nconst STATE_QUOTE = Symbol('quote');\nconst STATE_QUOTE_AFTER_QUOTE = Symbol('quoteafterquote');\nconst STATE_WITHIN_QUOTE_IN_QUOTE = Symbol('quoteinquote');\n/**\n * Represents a potentially large collection of delimited text records.\n *\n * The produced `TensorContainer`s each contain one key-value pair for\n * every column of the table.  When a field is empty in the incoming data, the\n * resulting value is `undefined`, or throw error if it is required.  Values\n * that can be parsed as numbers are emitted as type `number`, other values\n * are parsed as `string`.\n *\n * The results are not batched.\n *\n * @doc {heading: 'Data', subheading: 'Classes', namespace: 'data'}\n */\n\nexport class CSVDataset extends Dataset {\n  /**\n   * Create a `CSVDataset`.\n   *\n   * @param input A `DataSource` providing a chunked, UTF8-encoded byte stream.\n   * @param csvConfig (Optional) A CSVConfig object that contains configurations\n   *     of reading and decoding from CSV file(s).\n   *\n   *     hasHeader: (Optional) A boolean value that indicates whether the first\n   *     row of provided CSV file is a header line with column names, and should\n   *     not be included in the data. Defaults to `true`.\n   *\n   *     columnNames: (Optional) A list of strings that corresponds to\n   *     the CSV column names, in order. If provided, it ignores the column\n   *     names inferred from the header row. If not provided, infers the column\n   *     names from the first row of the records. If hasHeader is false and\n   *     columnNames is not provided, this method throws an error.\n   *\n   *     columnConfigs: (Optional) A dictionary whose key is column names, value\n   *     is an object stating if this column is required, column's data type,\n   *     default value, and if this column is label. If provided, keys must\n   *     correspond to names provided in columnNames or inferred from the file\n   *     header lines. If isLabel is true any column, returns an array of two\n   *     items: the first item is a dict of features key/value pairs, the second\n   *     item is a dict of labels key/value pairs. If no feature is marked as\n   *     label, returns a dict of features only.\n   *\n   *     configuredColumnsOnly (Optional) If true, only columns provided in\n   *     columnConfigs will be parsed and provided during iteration.\n   *\n   *     delimiter (Optional) The string used to parse each line of the input\n   *     file. Defaults to `,`.\n   */\n  constructor(input, csvConfig) {\n    super();\n    this.input = input;\n    this.hasHeader = true;\n    this.fullColumnNames = null;\n    this.columnNamesValidated = false;\n    this.columnConfigs = null;\n    this.configuredColumnsOnly = false;\n    this.delimiter = ',';\n    this.delimWhitespace = false;\n    this.base = new TextLineDataset(input);\n\n    if (!csvConfig) {\n      csvConfig = {};\n    }\n\n    this.hasHeader = csvConfig.hasHeader === false ? false : true;\n    this.fullColumnNames = csvConfig.columnNames;\n    this.columnConfigs = csvConfig.columnConfigs;\n    this.configuredColumnsOnly = csvConfig.configuredColumnsOnly;\n\n    if (csvConfig.delimWhitespace) {\n      util.assert(csvConfig.delimiter == null, () => 'Delimiter should not be provided when delimWhitespace is true.');\n      this.delimWhitespace = true;\n      this.delimiter = ' ';\n    } else {\n      this.delimiter = csvConfig.delimiter ? csvConfig.delimiter : ',';\n    }\n  }\n  /**\n   * Returns column names of the csv dataset. If `configuredColumnsOnly` is\n   * true, return column names in `columnConfigs`. If `configuredColumnsOnly` is\n   * false and `columnNames` is provided, `columnNames`. If\n   * `configuredColumnsOnly` is false and `columnNames` is not provided, return\n   * all column names parsed from the csv file. For example usage please go to\n   * `tf.data.csv`.\n   *\n   * @doc {heading: 'Data', subheading: 'Classes'}\n   */\n\n\n  columnNames() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this.columnNamesValidated) {\n        yield _this.setColumnNames();\n      }\n\n      return _this.configuredColumnsOnly ? Object.keys(_this.columnConfigs) : _this.fullColumnNames;\n    })();\n  }\n  /* 1) If `columnNames` is provided as string[], use this string[] as output\n   * keys in corresponding order. The length must match the number of inferred\n   * columns if `hasHeader` is true .\n   * 2) If `columnNames` is not provided, parse header line as `columnNames` if\n   * hasHeader is true. If `hasHeader` is false, throw an error.\n   * 3) If `columnConfigs` is provided, all the keys in `columnConfigs` must\n   * exist in parsed `columnNames`.\n   */\n\n\n  setColumnNames() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const columnNamesFromFile = yield _this2.maybeReadHeaderLine();\n\n      if (!_this2.fullColumnNames && !columnNamesFromFile) {\n        // Throw an error if columnNames is not provided and no header line.\n        throw new Error('Column names must be provided if there is no header line.');\n      } else if (_this2.fullColumnNames && columnNamesFromFile) {\n        // Check provided columnNames match header line.\n        util.assert(columnNamesFromFile.length === _this2.fullColumnNames.length, () => 'The length of provided columnNames (' + _this2.fullColumnNames.length.toString() + ') does not match the length of the header line read from ' + 'file (' + columnNamesFromFile.length.toString() + ').');\n      }\n\n      if (!_this2.fullColumnNames) {\n        _this2.fullColumnNames = columnNamesFromFile;\n      } // Check if there are duplicate column names.\n\n\n      const counts = _this2.fullColumnNames.reduce((countAcc, name) => {\n        countAcc[name] = countAcc[name] + 1 || 1;\n        return countAcc;\n      }, {});\n\n      const duplicateNames = Object.keys(counts).filter(name => counts[name] > 1);\n      util.assert(duplicateNames.length === 0, () => 'Duplicate column names found: ' + duplicateNames.toString()); // Check if keys in columnConfigs match columnNames.\n\n      if (_this2.columnConfigs) {\n        for (const key of Object.keys(_this2.columnConfigs)) {\n          const index = _this2.fullColumnNames.indexOf(key);\n\n          if (index === -1) {\n            throw new Error('The key \"' + key + '\" provided in columnConfigs does not match any of the column ' + 'names (' + _this2.fullColumnNames.toString() + ').');\n          }\n        }\n      }\n\n      _this2.columnNamesValidated = true;\n    })();\n  }\n\n  maybeReadHeaderLine() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this3.hasHeader) {\n        const iter = yield _this3.base.iterator();\n        const firstElement = yield iter.next();\n\n        if (firstElement.done) {\n          throw new Error('No data was found for CSV parsing.');\n        }\n\n        const firstLine = firstElement.value;\n\n        const headers = _this3.parseRow(firstLine, false);\n\n        return headers;\n      } else {\n        return null;\n      }\n    })();\n  }\n\n  iterator() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this4.columnNamesValidated) {\n        yield _this4.setColumnNames();\n      }\n\n      let lines = yield _this4.base.iterator();\n\n      if (_this4.hasHeader) {\n        // We previously read the first line to get the columnNames.\n        // Now that we're providing data, skip it.\n        lines = lines.skip(1);\n      }\n\n      return lines.map(x => _this4.makeDataElement(x));\n    })();\n  }\n\n  makeDataElement(line) {\n    const values = this.parseRow(line);\n    const features = {};\n    const labels = {};\n\n    for (let i = 0; i < this.fullColumnNames.length; i++) {\n      const key = this.fullColumnNames[i];\n      const config = this.columnConfigs ? this.columnConfigs[key] : null;\n\n      if (this.configuredColumnsOnly && !config) {\n        // This column is not selected.\n        continue;\n      } else {\n        const value = values[i];\n        let parsedValue = null;\n\n        if (value === '') {\n          // If default value is provided, use it. If default value is not\n          // provided, set as undefined.\n          if (config && config.default !== undefined) {\n            parsedValue = config.default;\n          } else if (config && (config.required || config.isLabel)) {\n            throw new Error(`Required column ${key} is empty in this line: ${line}`);\n          } else {\n            parsedValue = undefined;\n          }\n        } else {\n          // A value is present, so parse it based on type\n          const valueAsNum = Number(value);\n\n          if (isNaN(valueAsNum)) {\n            // The value is a string and this column is declared as boolean\n            // in config, parse it as boolean.\n            if (config && config.dtype === 'bool') {\n              parsedValue = this.getBoolean(value);\n            } else {\n              // Set value as string\n              parsedValue = value;\n            }\n          } else if (!config || !config.dtype) {\n            // If this value is a number and no type config is provided, return\n            // it as number.\n            parsedValue = valueAsNum;\n          } else {\n            // If this value is a number and data type is provided, parse it\n            // according to provided data type.\n            switch (config.dtype) {\n              case 'float32':\n                parsedValue = valueAsNum;\n                break;\n\n              case 'int32':\n                parsedValue = Math.floor(valueAsNum);\n                break;\n\n              case 'bool':\n                parsedValue = this.getBoolean(value);\n                break;\n\n              default:\n                parsedValue = valueAsNum;\n            }\n          }\n        } // Check if this column is label.\n\n\n        config && config.isLabel ? labels[key] = parsedValue : features[key] = parsedValue;\n      }\n    } // If label exists, return an object of features and labels as {xs:features,\n    // ys:labels}, otherwise return features only.\n\n\n    if (Object.keys(labels).length === 0) {\n      return features;\n    } else {\n      return {\n        xs: features,\n        ys: labels\n      };\n    }\n  }\n\n  getBoolean(value) {\n    if (value === '1' || value.toLowerCase() === 'true') {\n      return 1;\n    } else {\n      return 0;\n    }\n  } // adapted from https://beta.observablehq.com/@mbostock/streaming-csv\n\n\n  parseRow(line, validateElementCount = true) {\n    const result = [];\n    let readOffset = 0;\n    const readLength = line.length;\n    let currentState = STATE_OUT; // Goes through the line to parse quote.\n\n    for (let i = 0; i < readLength; i++) {\n      switch (currentState) {\n        // Before enter a new field\n        case STATE_OUT:\n          switch (line.charAt(i)) {\n            // Enter a quoted field\n            case CODE_QUOTE:\n              readOffset = i + 1;\n              currentState = STATE_QUOTE;\n              break;\n            // Read an empty field\n\n            case this.delimiter:\n              readOffset = i + 1; // If delimiter is white space and configured to collapse\n              // multiple white spaces, ignore this white space.\n\n              if (this.delimiter === ' ' && this.delimWhitespace) {\n                break;\n              }\n\n              result.push('');\n              currentState = STATE_OUT;\n              break;\n            // Enter an unquoted field\n\n            default:\n              currentState = STATE_FIELD;\n              readOffset = i;\n              break;\n          }\n\n          break;\n        // In an unquoted field\n\n        case STATE_FIELD:\n          switch (line.charAt(i)) {\n            // Exit an unquoted field, add it to result\n            case this.delimiter:\n              result.push(line.substring(readOffset, i));\n              currentState = STATE_OUT;\n              readOffset = i + 1;\n              break;\n\n            default:\n          }\n\n          break;\n        // In a quoted field\n\n        case STATE_QUOTE:\n          switch (line.charAt(i)) {\n            // Read a quote after a quote\n            case CODE_QUOTE:\n              currentState = STATE_QUOTE_AFTER_QUOTE;\n              break;\n\n            default:\n          }\n\n          break;\n        // This state means it's right after a second quote in a field\n\n        case STATE_QUOTE_AFTER_QUOTE:\n          switch (line.charAt(i)) {\n            // Finished a quoted field\n            case this.delimiter:\n              result.push(line.substring(readOffset, i - 1));\n              currentState = STATE_OUT;\n              readOffset = i + 1;\n              break;\n            // Finished a quoted part in a quoted field\n\n            case CODE_QUOTE:\n              currentState = STATE_QUOTE;\n              break;\n            // In a quoted part in a quoted field\n\n            default:\n              currentState = STATE_WITHIN_QUOTE_IN_QUOTE;\n              break;\n          }\n\n          break;\n\n        case STATE_WITHIN_QUOTE_IN_QUOTE:\n          switch (line.charAt(i)) {\n            // Exit a quoted part in a quoted field\n            case CODE_QUOTE:\n              currentState = STATE_QUOTE;\n              break;\n\n            default:\n          }\n\n          break;\n\n        default:\n      }\n    } // Adds last item based on if it is quoted.\n\n\n    if (currentState === STATE_QUOTE_AFTER_QUOTE) {\n      result.push(line.substring(readOffset, readLength - 1));\n    } else {\n      result.push(line.substring(readOffset));\n    } // Check if each row has the same number of elements as column names.\n\n\n    if (validateElementCount && result.length !== this.fullColumnNames.length) {\n      throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${result}`);\n    }\n\n    return result;\n  }\n\n} // TODO(soergel): add more basic datasets for parity with tf.data\n// tf.data.FixedLengthRecordDataset()\n// tf.data.TFRecordDataset()","map":{"version":3,"sources":["/Users/ryanliang/Downloads/main_movir_picker/node_modules/@tensorflow/tfjs-data/dist/datasets/csv_dataset.js"],"names":["util","Dataset","TextLineDataset","CODE_QUOTE","STATE_OUT","Symbol","STATE_FIELD","STATE_QUOTE","STATE_QUOTE_AFTER_QUOTE","STATE_WITHIN_QUOTE_IN_QUOTE","CSVDataset","constructor","input","csvConfig","hasHeader","fullColumnNames","columnNamesValidated","columnConfigs","configuredColumnsOnly","delimiter","delimWhitespace","base","columnNames","assert","setColumnNames","Object","keys","columnNamesFromFile","maybeReadHeaderLine","Error","length","toString","counts","reduce","countAcc","name","duplicateNames","filter","key","index","indexOf","iter","iterator","firstElement","next","done","firstLine","value","headers","parseRow","lines","skip","map","x","makeDataElement","line","values","features","labels","i","config","parsedValue","default","undefined","required","isLabel","valueAsNum","Number","isNaN","dtype","getBoolean","Math","floor","xs","ys","toLowerCase","validateElementCount","result","readOffset","readLength","currentState","charAt","push","substring"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { Dataset } from '../dataset';\nimport { TextLineDataset } from './text_line_dataset';\nconst CODE_QUOTE = '\"';\nconst STATE_OUT = Symbol('out');\nconst STATE_FIELD = Symbol('field');\nconst STATE_QUOTE = Symbol('quote');\nconst STATE_QUOTE_AFTER_QUOTE = Symbol('quoteafterquote');\nconst STATE_WITHIN_QUOTE_IN_QUOTE = Symbol('quoteinquote');\n/**\n * Represents a potentially large collection of delimited text records.\n *\n * The produced `TensorContainer`s each contain one key-value pair for\n * every column of the table.  When a field is empty in the incoming data, the\n * resulting value is `undefined`, or throw error if it is required.  Values\n * that can be parsed as numbers are emitted as type `number`, other values\n * are parsed as `string`.\n *\n * The results are not batched.\n *\n * @doc {heading: 'Data', subheading: 'Classes', namespace: 'data'}\n */\nexport class CSVDataset extends Dataset {\n    /**\n     * Create a `CSVDataset`.\n     *\n     * @param input A `DataSource` providing a chunked, UTF8-encoded byte stream.\n     * @param csvConfig (Optional) A CSVConfig object that contains configurations\n     *     of reading and decoding from CSV file(s).\n     *\n     *     hasHeader: (Optional) A boolean value that indicates whether the first\n     *     row of provided CSV file is a header line with column names, and should\n     *     not be included in the data. Defaults to `true`.\n     *\n     *     columnNames: (Optional) A list of strings that corresponds to\n     *     the CSV column names, in order. If provided, it ignores the column\n     *     names inferred from the header row. If not provided, infers the column\n     *     names from the first row of the records. If hasHeader is false and\n     *     columnNames is not provided, this method throws an error.\n     *\n     *     columnConfigs: (Optional) A dictionary whose key is column names, value\n     *     is an object stating if this column is required, column's data type,\n     *     default value, and if this column is label. If provided, keys must\n     *     correspond to names provided in columnNames or inferred from the file\n     *     header lines. If isLabel is true any column, returns an array of two\n     *     items: the first item is a dict of features key/value pairs, the second\n     *     item is a dict of labels key/value pairs. If no feature is marked as\n     *     label, returns a dict of features only.\n     *\n     *     configuredColumnsOnly (Optional) If true, only columns provided in\n     *     columnConfigs will be parsed and provided during iteration.\n     *\n     *     delimiter (Optional) The string used to parse each line of the input\n     *     file. Defaults to `,`.\n     */\n    constructor(input, csvConfig) {\n        super();\n        this.input = input;\n        this.hasHeader = true;\n        this.fullColumnNames = null;\n        this.columnNamesValidated = false;\n        this.columnConfigs = null;\n        this.configuredColumnsOnly = false;\n        this.delimiter = ',';\n        this.delimWhitespace = false;\n        this.base = new TextLineDataset(input);\n        if (!csvConfig) {\n            csvConfig = {};\n        }\n        this.hasHeader = csvConfig.hasHeader === false ? false : true;\n        this.fullColumnNames = csvConfig.columnNames;\n        this.columnConfigs = csvConfig.columnConfigs;\n        this.configuredColumnsOnly = csvConfig.configuredColumnsOnly;\n        if (csvConfig.delimWhitespace) {\n            util.assert(csvConfig.delimiter == null, () => 'Delimiter should not be provided when delimWhitespace is true.');\n            this.delimWhitespace = true;\n            this.delimiter = ' ';\n        }\n        else {\n            this.delimiter = csvConfig.delimiter ? csvConfig.delimiter : ',';\n        }\n    }\n    /**\n     * Returns column names of the csv dataset. If `configuredColumnsOnly` is\n     * true, return column names in `columnConfigs`. If `configuredColumnsOnly` is\n     * false and `columnNames` is provided, `columnNames`. If\n     * `configuredColumnsOnly` is false and `columnNames` is not provided, return\n     * all column names parsed from the csv file. For example usage please go to\n     * `tf.data.csv`.\n     *\n     * @doc {heading: 'Data', subheading: 'Classes'}\n     */\n    async columnNames() {\n        if (!this.columnNamesValidated) {\n            await this.setColumnNames();\n        }\n        return this.configuredColumnsOnly ? Object.keys(this.columnConfigs) :\n            this.fullColumnNames;\n    }\n    /* 1) If `columnNames` is provided as string[], use this string[] as output\n     * keys in corresponding order. The length must match the number of inferred\n     * columns if `hasHeader` is true .\n     * 2) If `columnNames` is not provided, parse header line as `columnNames` if\n     * hasHeader is true. If `hasHeader` is false, throw an error.\n     * 3) If `columnConfigs` is provided, all the keys in `columnConfigs` must\n     * exist in parsed `columnNames`.\n     */\n    async setColumnNames() {\n        const columnNamesFromFile = await this.maybeReadHeaderLine();\n        if (!this.fullColumnNames && !columnNamesFromFile) {\n            // Throw an error if columnNames is not provided and no header line.\n            throw new Error('Column names must be provided if there is no header line.');\n        }\n        else if (this.fullColumnNames && columnNamesFromFile) {\n            // Check provided columnNames match header line.\n            util.assert(columnNamesFromFile.length === this.fullColumnNames.length, () => 'The length of provided columnNames (' +\n                this.fullColumnNames.length.toString() +\n                ') does not match the length of the header line read from ' +\n                'file (' + columnNamesFromFile.length.toString() + ').');\n        }\n        if (!this.fullColumnNames) {\n            this.fullColumnNames = columnNamesFromFile;\n        }\n        // Check if there are duplicate column names.\n        const counts = this.fullColumnNames.reduce((countAcc, name) => {\n            countAcc[name] = (countAcc[name] + 1) || 1;\n            return countAcc;\n        }, {});\n        const duplicateNames = Object.keys(counts).filter((name) => (counts[name] > 1));\n        util.assert(duplicateNames.length === 0, () => 'Duplicate column names found: ' + duplicateNames.toString());\n        // Check if keys in columnConfigs match columnNames.\n        if (this.columnConfigs) {\n            for (const key of Object.keys(this.columnConfigs)) {\n                const index = this.fullColumnNames.indexOf(key);\n                if (index === -1) {\n                    throw new Error('The key \"' + key +\n                        '\" provided in columnConfigs does not match any of the column ' +\n                        'names (' + this.fullColumnNames.toString() + ').');\n                }\n            }\n        }\n        this.columnNamesValidated = true;\n    }\n    async maybeReadHeaderLine() {\n        if (this.hasHeader) {\n            const iter = await this.base.iterator();\n            const firstElement = await iter.next();\n            if (firstElement.done) {\n                throw new Error('No data was found for CSV parsing.');\n            }\n            const firstLine = firstElement.value;\n            const headers = this.parseRow(firstLine, false);\n            return headers;\n        }\n        else {\n            return null;\n        }\n    }\n    async iterator() {\n        if (!this.columnNamesValidated) {\n            await this.setColumnNames();\n        }\n        let lines = await this.base.iterator();\n        if (this.hasHeader) {\n            // We previously read the first line to get the columnNames.\n            // Now that we're providing data, skip it.\n            lines = lines.skip(1);\n        }\n        return lines.map(x => this.makeDataElement(x));\n    }\n    makeDataElement(line) {\n        const values = this.parseRow(line);\n        const features = {};\n        const labels = {};\n        for (let i = 0; i < this.fullColumnNames.length; i++) {\n            const key = this.fullColumnNames[i];\n            const config = this.columnConfigs ? this.columnConfigs[key] : null;\n            if (this.configuredColumnsOnly && !config) {\n                // This column is not selected.\n                continue;\n            }\n            else {\n                const value = values[i];\n                let parsedValue = null;\n                if (value === '') {\n                    // If default value is provided, use it. If default value is not\n                    // provided, set as undefined.\n                    if (config && config.default !== undefined) {\n                        parsedValue = config.default;\n                    }\n                    else if (config && (config.required || config.isLabel)) {\n                        throw new Error(`Required column ${key} is empty in this line: ${line}`);\n                    }\n                    else {\n                        parsedValue = undefined;\n                    }\n                }\n                else {\n                    // A value is present, so parse it based on type\n                    const valueAsNum = Number(value);\n                    if (isNaN(valueAsNum)) {\n                        // The value is a string and this column is declared as boolean\n                        // in config, parse it as boolean.\n                        if (config && config.dtype === 'bool') {\n                            parsedValue = this.getBoolean(value);\n                        }\n                        else {\n                            // Set value as string\n                            parsedValue = value;\n                        }\n                    }\n                    else if (!config || !config.dtype) {\n                        // If this value is a number and no type config is provided, return\n                        // it as number.\n                        parsedValue = valueAsNum;\n                    }\n                    else {\n                        // If this value is a number and data type is provided, parse it\n                        // according to provided data type.\n                        switch (config.dtype) {\n                            case 'float32':\n                                parsedValue = valueAsNum;\n                                break;\n                            case 'int32':\n                                parsedValue = Math.floor(valueAsNum);\n                                break;\n                            case 'bool':\n                                parsedValue = this.getBoolean(value);\n                                break;\n                            default:\n                                parsedValue = valueAsNum;\n                        }\n                    }\n                }\n                // Check if this column is label.\n                (config && config.isLabel) ? labels[key] = parsedValue :\n                    features[key] = parsedValue;\n            }\n        }\n        // If label exists, return an object of features and labels as {xs:features,\n        // ys:labels}, otherwise return features only.\n        if (Object.keys(labels).length === 0) {\n            return features;\n        }\n        else {\n            return { xs: features, ys: labels };\n        }\n    }\n    getBoolean(value) {\n        if (value === '1' || value.toLowerCase() === 'true') {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    // adapted from https://beta.observablehq.com/@mbostock/streaming-csv\n    parseRow(line, validateElementCount = true) {\n        const result = [];\n        let readOffset = 0;\n        const readLength = line.length;\n        let currentState = STATE_OUT;\n        // Goes through the line to parse quote.\n        for (let i = 0; i < readLength; i++) {\n            switch (currentState) {\n                // Before enter a new field\n                case STATE_OUT:\n                    switch (line.charAt(i)) {\n                        // Enter a quoted field\n                        case CODE_QUOTE:\n                            readOffset = i + 1;\n                            currentState = STATE_QUOTE;\n                            break;\n                        // Read an empty field\n                        case this.delimiter:\n                            readOffset = i + 1;\n                            // If delimiter is white space and configured to collapse\n                            // multiple white spaces, ignore this white space.\n                            if (this.delimiter === ' ' && this.delimWhitespace) {\n                                break;\n                            }\n                            result.push('');\n                            currentState = STATE_OUT;\n                            break;\n                        // Enter an unquoted field\n                        default:\n                            currentState = STATE_FIELD;\n                            readOffset = i;\n                            break;\n                    }\n                    break;\n                // In an unquoted field\n                case STATE_FIELD:\n                    switch (line.charAt(i)) {\n                        // Exit an unquoted field, add it to result\n                        case this.delimiter:\n                            result.push(line.substring(readOffset, i));\n                            currentState = STATE_OUT;\n                            readOffset = i + 1;\n                            break;\n                        default:\n                    }\n                    break;\n                // In a quoted field\n                case STATE_QUOTE:\n                    switch (line.charAt(i)) {\n                        // Read a quote after a quote\n                        case CODE_QUOTE:\n                            currentState = STATE_QUOTE_AFTER_QUOTE;\n                            break;\n                        default:\n                    }\n                    break;\n                // This state means it's right after a second quote in a field\n                case STATE_QUOTE_AFTER_QUOTE:\n                    switch (line.charAt(i)) {\n                        // Finished a quoted field\n                        case this.delimiter:\n                            result.push(line.substring(readOffset, i - 1));\n                            currentState = STATE_OUT;\n                            readOffset = i + 1;\n                            break;\n                        // Finished a quoted part in a quoted field\n                        case CODE_QUOTE:\n                            currentState = STATE_QUOTE;\n                            break;\n                        // In a quoted part in a quoted field\n                        default:\n                            currentState = STATE_WITHIN_QUOTE_IN_QUOTE;\n                            break;\n                    }\n                    break;\n                case STATE_WITHIN_QUOTE_IN_QUOTE:\n                    switch (line.charAt(i)) {\n                        // Exit a quoted part in a quoted field\n                        case CODE_QUOTE:\n                            currentState = STATE_QUOTE;\n                            break;\n                        default:\n                    }\n                    break;\n                default:\n            }\n        }\n        // Adds last item based on if it is quoted.\n        if (currentState === STATE_QUOTE_AFTER_QUOTE) {\n            result.push(line.substring(readOffset, readLength - 1));\n        }\n        else {\n            result.push(line.substring(readOffset));\n        }\n        // Check if each row has the same number of elements as column names.\n        if (validateElementCount && result.length !== this.fullColumnNames.length) {\n            throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${result}`);\n        }\n        return result;\n    }\n}\n// TODO(soergel): add more basic datasets for parity with tf.data\n// tf.data.FixedLengthRecordDataset()\n// tf.data.TFRecordDataset()\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _asyncToGenerator from \"/Users/ryanliang/Downloads/main_movir_picker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport * as seedrandom from 'seedrandom';\nimport { deepClone } from '../util/deep_clone';\nimport { deepMapAndAwaitAll, deepZip, zipToList } from '../util/deep_map';\nimport { GrowingRingBuffer } from '../util/growing_ring_buffer';\nimport { RingBuffer } from '../util/ring_buffer'; // Here we implement a simple asynchronous iterator.\n// This lets us avoid using either third-party stream libraries or\n// recent TypeScript language support requiring polyfills.\n\n/**\n * Create a `LazyIterator` from an array of items.\n */\n\nexport function iteratorFromItems(items) {\n  return new ArrayIterator(items);\n}\n/**\n * Create a `LazyIterator` of incrementing integers.\n */\n\nexport function iteratorFromIncrementing(start) {\n  let i = start;\n  return iteratorFromFunction(() => ({\n    value: i++,\n    done: false\n  }));\n}\n/**\n * Create a `LazyIterator` from a function.\n *\n * ```js\n * let i = -1;\n * const func = () =>\n *    ++i < 5 ? {value: i, done: false} : {value: null, done: true};\n * const iter = tf.data.iteratorFromFunction(func);\n * await iter.forEachAsync(e => console.log(e));\n * ```\n *\n * @param func A function that produces data on each call.\n */\n\nexport function iteratorFromFunction(func) {\n  return new FunctionCallIterator(func);\n}\n/**\n * Create a `LazyIterator` by concatenating underlying streams, which are\n * themselves provided as a stream.\n *\n * This can also be thought of as a \"stream flatten\" operation.\n *\n * @param baseIterators A stream of streams to be concatenated.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\n\nexport function iteratorFromConcatenated(baseIterators, baseErrorHandler) {\n  return new ChainedIterator(baseIterators, baseErrorHandler);\n}\n/**\n * Create a `LazyIterator` by concatenating streams produced by calling a\n * stream-generating function a given number of times.\n *\n * Since a `LazyIterator` is read-once, it cannot be repeated, but this\n * function can be used to achieve a similar effect:\n *\n *   LazyIterator.ofConcatenatedFunction(() => new MyIterator(), 6);\n *\n * @param iteratorFunc: A function that produces a new stream on each call.\n * @param count: The number of times to call the function.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\n\nexport function iteratorFromConcatenatedFunction(iteratorFunc, count, baseErrorHandler) {\n  return iteratorFromConcatenated(iteratorFromFunction(iteratorFunc).take(count), baseErrorHandler);\n}\n/**\n * Create a `LazyIterator` by zipping together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\n\nexport function iteratorFromZipped(iterators, mismatchMode = ZipMismatchMode.FAIL) {\n  return new ZipIterator(iterators, mismatchMode);\n}\n/**\n * An asynchronous iterator, providing lazy access to a potentially\n * unbounded stream of elements.\n *\n * Iterator can be obtained from a dataset:\n * `const iter = await dataset.iterator();`\n */\n\nexport class LazyIterator {\n  /**\n   * Collect all remaining elements of a bounded stream into an array.\n   * Obviously this will succeed only for small streams that fit in memory.\n   * Useful for testing.\n   *\n   * @returns A Promise for an array of stream elements, which will resolve\n   *   when the stream is exhausted.\n   */\n  toArray() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const result = [];\n      let x = yield _this.next();\n\n      while (!x.done) {\n        result.push(x.value);\n        x = yield _this.next();\n      }\n\n      return result;\n    })();\n  }\n  /**\n   * Collect all elements of this dataset into an array with prefetching 100\n   * elements. This is useful for testing, because the prefetch changes the\n   * order in which the Promises are resolved along the processing pipeline.\n   * This may help expose bugs where results are dependent on the order of\n   * Promise resolution rather than on the logical order of the stream (i.e.,\n   * due to hidden mutable state).\n   *\n   * @returns A Promise for an array of stream elements, which will resolve\n   *   when the stream is exhausted.\n   */\n\n\n  toArrayForTest() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const stream = _this2.prefetch(100);\n\n      const result = [];\n      let x = yield stream.next();\n\n      while (!x.done) {\n        result.push(x.value);\n        x = yield stream.next();\n      }\n\n      return result;\n    })();\n  }\n  /**\n   * Draw items from the stream until it is exhausted.\n   *\n   * This can be useful when the stream has side effects but no output.  In\n   * that case, calling this function guarantees that the stream will be\n   * fully processed.\n   */\n\n\n  resolveFully() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      let x = yield _this3.next();\n\n      while (!x.done) {\n        x = yield _this3.next();\n      }\n    })();\n  }\n  /**\n   * Draw items from the stream until it is exhausted, or a predicate fails.\n   *\n   * This can be useful when the stream has side effects but no output.  In\n   * that case, calling this function guarantees that the stream will be\n   * fully processed.\n   */\n\n\n  resolveWhile(predicate) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      let x = yield _this4.next();\n      let shouldContinue = predicate(x.value);\n\n      while (!x.done && shouldContinue) {\n        x = yield _this4.next();\n        shouldContinue = predicate(x.value);\n      }\n    })();\n  }\n  /**\n   * Handles errors thrown on this stream using a provided handler function.\n   *\n   * @param handler A function that handles any `Error` thrown during a `next()`\n   *   call and returns true if the stream should continue (dropping the failed\n   *   call) or false if the stream should quietly terminate.  If the handler\n   *   itself throws (or rethrows) an `Error`, that will be propagated.\n   *\n   * @returns A `LazyIterator` of elements passed through from upstream,\n   *   possibly filtering or terminating on upstream `next()` calls that\n   *   throw an `Error`.\n   */\n\n\n  handleErrors(handler) {\n    return new ErrorHandlingLazyIterator(this, handler);\n  } // TODO(soergel): Implement reduce() etc.\n\n  /**\n   * Filters this stream according to `predicate`.\n   *\n   * @param predicate A function mapping a stream element to a boolean or a\n   * `Promise` for one.\n   *\n   * @returns A `LazyIterator` of elements for which the predicate was true.\n   */\n\n\n  filter(predicate) {\n    return new FilterIterator(this, predicate);\n  }\n  /**\n   * Maps this stream through a 1-to-1 transform.\n   *\n   * @param transform A function mapping a stream element to a transformed\n   *   element.\n   *\n   * @returns A `LazyIterator` of transformed elements.\n   */\n\n\n  map(transform) {\n    return new MapIterator(this, transform);\n  }\n  /**\n   * Maps this stream through an async 1-to-1 transform.\n   *\n   * @param transform A function mapping a stream element to a `Promise` for a\n   *   transformed stream element.\n   *\n   * @returns A `LazyIterator` of transformed elements.\n   */\n\n\n  mapAsync(transform) {\n    return new AsyncMapIterator(this, transform);\n  }\n  /**\n   * Maps this stream through a 1-to-1 transform, forcing serial execution.\n   *\n   * @param transform A function mapping a stream element to a transformed\n   *   element.\n   *\n   * @returns A `LazyIterator` of transformed elements.\n   */\n\n\n  serialMapAsync(transform) {\n    return new AsyncMapIterator(this, transform).serial();\n  }\n  /**\n   * Maps this stream through a 1-to-many transform.\n   *\n   * @param transform A function mapping a stream element to an array of\n   *   transformed elements.\n   *\n   * @returns A `DataStream` of transformed elements.\n   */\n\n\n  flatmap(transform) {\n    return new FlatmapIterator(this, transform);\n  }\n  /**\n   * Apply a function to every element of the stream.\n   *\n   * @param f A function to apply to each stream element.\n   */\n\n\n  forEachAsync(f) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this5.map(f).resolveFully();\n    })();\n  }\n  /**\n   * Apply a function to every element of the stream, forcing serial execution.\n   *\n   * @param f A function to apply to each stream element.  Should return 'true'\n   *   to indicate that the stream should continue, or 'false' to cause it to\n   *   terminate.\n   */\n\n\n  serialForEach(f) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this6.serialMapAsync(f).resolveWhile(x => x === true);\n    })();\n  }\n  /**\n   * Groups elements into batches, represented as arrays of elements.\n   *\n   * We can think of the elements of this iterator as 'rows' (even if they are\n   * nested structures).  By the same token, consecutive values for a given\n   * key within the elements form a 'column'.  This matches the usual sense of\n   * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n   *\n   * Thus, \"Row-major\" means that the resulting batch is simply a collection of\n   * rows: `[row1, row2, row3, ...]`.  This is contrast to the column-major\n   * form, which is needed for vectorized computation.\n   *\n   * @param batchSize The number of elements desired per batch.\n   * @param smallLastBatch Whether to emit the final batch when it has fewer\n   *   than batchSize elements. Default true.\n   * @returns A `LazyIterator` of batches of elements, represented as arrays\n   *   of the original element type.\n   */\n\n\n  rowMajorBatch(batchSize, smallLastBatch = true) {\n    return new RowMajorBatchIterator(this, batchSize, smallLastBatch);\n  }\n  /**\n   * Groups elements into batches, represented in column-major form.\n   *\n   * We can think of the elements of this iterator as 'rows' (even if they are\n   * nested structures).  By the same token, consecutive values for a given\n   * key within the elements form a 'column'.  This matches the usual sense of\n   * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n   *\n   * Thus, \"column-major\" means that the resulting batch is a (potentially\n   * nested) structure representing the columns.  Each column entry, then,\n   * contains a collection of the values found in that column for a range of\n   * input elements.  This representation allows for vectorized computation, in\n   * contrast to the row-major form.\n   *\n   * The inputs should all have the same nested structure (i.e., of arrays and\n   * dicts).  The result is a single object with the same nested structure,\n   * where the leaves are arrays collecting the values of the inputs at that\n   * location (or, optionally, the result of a custom function applied to those\n   * arrays).\n   *\n   * @param batchSize The number of elements desired per batch.\n   * @param smallLastBatch Whether to emit the final batch when it has fewer\n   *   than batchSize elements. Default true.\n   * @param zipFn: (optional) A function that expects an array of elements at a\n   *   single node of the object tree, and returns a `DeepMapResult`.  The\n   *   `DeepMapResult` either provides a result value for that node (i.e.,\n   *   representing the subtree), or indicates that the node should be processed\n   *   recursively.  The default zipFn recurses as far as possible and places\n   *   arrays at the leaves.\n   * @returns A `LazyIterator` of batches of elements, represented as an object\n   *   with collections at the leaves.\n   */\n\n\n  columnMajorBatch(batchSize, smallLastBatch = true, // tslint:disable-next-line:no-any\n  zipFn = zipToList) {\n    // First collect the desired number of input elements as a row-major batch.\n    const rowBatches = this.rowMajorBatch(batchSize, smallLastBatch); // Now 'rotate' or 'pivot' the data, collecting all values from each column\n    // in the batch (i.e., for each key within the elements) into an array.\n\n    return rowBatches.map(x => deepZip(x, zipFn));\n  }\n  /**\n   * Concatenate this `LazyIterator` with another.\n   *\n   * @param iterator A `LazyIterator` to be concatenated onto this one.\n   * @param baseErrorHandler An optional function that can intercept `Error`s\n   *   raised during a `next()` call on the base stream.  This function can\n   *   decide whether the error should be propagated, whether the error should\n   *   be ignored, or whether the base stream should be terminated.\n   * @returns A `LazyIterator`.\n   */\n\n\n  concatenate(iterator, baseErrorHandler) {\n    return new ChainedIterator(iteratorFromItems([this, iterator]), baseErrorHandler);\n  }\n  /**\n   * Limits this stream to return at most `count` items.\n   *\n   * @param count The maximum number of items to provide from the stream. If\n   * a negative or undefined value is given, the entire stream is returned\n   *   unaltered.\n   */\n\n\n  take(count) {\n    if (count < 0 || count == null) {\n      return this;\n    }\n\n    return new TakeIterator(this, count);\n  }\n  /**\n   * Skips the first `count` items in this stream.\n   *\n   * @param count The number of items to skip.  If a negative or undefined\n   * value is given, the entire stream is returned unaltered.\n   */\n\n\n  skip(count) {\n    if (count < 0 || count == null) {\n      return this;\n    }\n\n    return new SkipIterator(this, count);\n  }\n  /**\n   * Prefetch the first `bufferSize` items in this stream.\n   *\n   * Note this prefetches Promises, but makes no guarantees about when those\n   * Promises resolve.\n   *\n   * @param bufferSize: An integer specifying the number of elements to be\n   *   prefetched.\n   */\n\n\n  prefetch(bufferSize) {\n    return new PrefetchIterator(this, bufferSize);\n  } // TODO(soergel): deep sharded shuffle, where supported\n\n  /**\n   * Randomly shuffles the elements of this stream.\n   *\n   * @param bufferSize: An integer specifying the number of elements from\n   * this stream from which the new stream will sample.\n   * @param seed: (Optional.) An integer specifying the random seed that\n   * will be used to create the distribution.\n   */\n\n\n  shuffle(windowSize, seed) {\n    return new ShuffleIterator(this, windowSize, seed);\n  }\n  /**\n   * Force an iterator to execute serially: each next() call will await the\n   * prior one, so that they cannot execute concurrently.\n   */\n\n\n  serial() {\n    return new SerialIterator(this);\n  }\n\n} // ============================================================================\n// The following private classes serve to implement the chainable methods\n// on LazyIterator.  Unfortunately they can't be placed in separate files,\n// due to resulting trouble with circular imports.\n// ============================================================================\n// Iterators that just extend LazyIterator directly\n// ============================================================================\n\nclass ArrayIterator extends LazyIterator {\n  constructor(items) {\n    super();\n    this.items = items;\n    this.trav = 0;\n  }\n\n  summary() {\n    return `Array of ${this.items.length} items`;\n  }\n\n  next() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this7.trav >= _this7.items.length) {\n        return {\n          value: null,\n          done: true\n        };\n      }\n\n      const item = _this7.items[_this7.trav];\n      _this7.trav++;\n      return {\n        value: deepClone(item),\n        done: false\n      };\n    })();\n  }\n\n}\n\nclass FunctionCallIterator extends LazyIterator {\n  constructor(nextFn) {\n    super();\n    this.nextFn = nextFn;\n  }\n\n  summary() {\n    return `Function call`;\n  }\n\n  next() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        return _this8.nextFn();\n      } catch (e) {\n        // Modify the error message but leave the stack trace intact\n        e.message = `Error thrown while iterating through a dataset: ${e.message}`;\n        throw e;\n      }\n    })();\n  }\n\n}\n\nclass SerialIterator extends LazyIterator {\n  constructor(upstream) {\n    super();\n    this.upstream = upstream;\n    this.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Serial`;\n  }\n\n  next() {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      // This sets this.lastRead to a new Promise right away, as opposed to\n      // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n      // would not work because this.nextRead would be updated only after the\n      // promise resolves.\n      _this9.lastRead = _this9.lastRead.then(() => _this9.serialNext());\n      return _this9.lastRead;\n    })();\n  }\n\n  serialNext() {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this10.upstream.next();\n    })();\n  }\n\n}\n\nclass SkipIterator extends LazyIterator {\n  constructor(upstream, maxCount) {\n    super();\n    this.upstream = upstream;\n    this.maxCount = maxCount; // Local state that should not be clobbered by out-of-order execution.\n\n    this.count = 0;\n    this.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Skip`;\n  }\n\n  next() {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      // This sets this.lastRead to a new Promise right away, as opposed to\n      // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n      // would not work because this.nextRead would be updated only after the\n      // promise resolves.\n      _this11.lastRead = _this11.lastRead.then(() => _this11.serialNext());\n      return _this11.lastRead;\n    })();\n  }\n\n  serialNext() {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      // TODO(soergel): consider tradeoffs of reading in parallel, eg.\n      // collecting next() promises in an Array and then waiting for\n      // Promise.all() of those. Benefit: pseudo-parallel execution.  Drawback:\n      // maybe delayed GC.\n      while (_this12.count++ < _this12.maxCount) {\n        const skipped = yield _this12.upstream.next(); // short-circuit if upstream is already empty\n\n        if (skipped.done) {\n          return skipped;\n        }\n\n        tf.dispose(skipped.value);\n      }\n\n      return _this12.upstream.next();\n    })();\n  }\n\n}\n\nclass TakeIterator extends LazyIterator {\n  constructor(upstream, maxCount) {\n    super();\n    this.upstream = upstream;\n    this.maxCount = maxCount;\n    this.count = 0;\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Take`;\n  }\n\n  next() {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this13.count++ >= _this13.maxCount) {\n        return {\n          value: null,\n          done: true\n        };\n      }\n\n      return _this13.upstream.next();\n    })();\n  }\n\n} // Note this batch just groups items into row-wise element arrays.\n// Rotating these to a column-wise representation happens only at the dataset\n// level.\n\n\nclass RowMajorBatchIterator extends LazyIterator {\n  constructor(upstream, batchSize, enableSmallLastBatch = true) {\n    super();\n    this.upstream = upstream;\n    this.batchSize = batchSize;\n    this.enableSmallLastBatch = enableSmallLastBatch;\n    this.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> RowMajorBatch`;\n  }\n\n  next() {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      // This sets this.lastRead to a new Promise right away, as opposed to\n      // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n      // would not work because this.nextRead would be updated only after the\n      // promise resolves.\n      _this14.lastRead = _this14.lastRead.then(() => _this14.serialNext());\n      return _this14.lastRead;\n    })();\n  }\n\n  serialNext() {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      const batch = [];\n\n      while (batch.length < _this15.batchSize) {\n        const item = yield _this15.upstream.next();\n\n        if (item.done) {\n          if (_this15.enableSmallLastBatch && batch.length > 0) {\n            return {\n              value: batch,\n              done: false\n            };\n          }\n\n          return {\n            value: null,\n            done: true\n          };\n        }\n\n        batch.push(item.value);\n      }\n\n      return {\n        value: batch,\n        done: false\n      };\n    })();\n  }\n\n}\n\nclass FilterIterator extends LazyIterator {\n  constructor(upstream, predicate) {\n    super();\n    this.upstream = upstream;\n    this.predicate = predicate;\n    this.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Filter`;\n  }\n\n  next() {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      // This sets this.lastRead to a new Promise right away, as opposed to\n      // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n      // would not work because this.nextRead would be updated only after the\n      // promise resolves.\n      _this16.lastRead = _this16.lastRead.then(() => _this16.serialNext());\n      return _this16.lastRead;\n    })();\n  }\n\n  serialNext() {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      while (true) {\n        const item = yield _this17.upstream.next();\n\n        if (item.done || _this17.predicate(item.value)) {\n          return item;\n        }\n\n        tf.dispose(item.value);\n      }\n    })();\n  }\n\n}\n\nclass MapIterator extends LazyIterator {\n  constructor(upstream, transform) {\n    super();\n    this.upstream = upstream;\n    this.transform = transform;\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Map`;\n  }\n\n  next() {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      const item = yield _this18.upstream.next();\n\n      if (item.done) {\n        return {\n          value: null,\n          done: true\n        };\n      }\n\n      const inputTensors = tf.tensor_util.getTensorsInContainer(item.value); // Careful: the transform may mutate the item in place.\n      // That's why we have to remember the input Tensors above, and then\n      // below dispose only those that were not passed through to the output.\n      // Note too that the transform function is responsible for tidying\n      // any intermediate Tensors.  Here we are concerned only about the\n      // inputs.\n\n      const mapped = _this18.transform(item.value);\n\n      const outputTensors = tf.tensor_util.getTensorsInContainer(mapped); // TODO(soergel) faster intersection\n      // TODO(soergel) move to tf.disposeExcept(in, out)?\n\n      for (const t of inputTensors) {\n        if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n          t.dispose();\n        }\n      }\n\n      return {\n        value: mapped,\n        done: false\n      };\n    })();\n  }\n\n}\n\nclass ErrorHandlingLazyIterator extends LazyIterator {\n  constructor(upstream, handler) {\n    super();\n    this.upstream = upstream;\n    this.handler = handler;\n    this.count = 0;\n    this.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> handleErrors`;\n  }\n\n  next() {\n    var _this19 = this;\n\n    return _asyncToGenerator(function* () {\n      // This sets this.lastRead to a new Promise right away, as opposed to\n      // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n      // would not work because this.nextRead would be updated only after the\n      // promise resolves.\n      _this19.lastRead = _this19.lastRead.then(() => _this19.serialNext());\n      return _this19.lastRead;\n    })();\n  }\n\n  serialNext() {\n    var _this20 = this;\n\n    return _asyncToGenerator(function* () {\n      while (true) {\n        try {\n          return yield _this20.upstream.next();\n        } catch (e) {\n          if (!_this20.handler(e)) {\n            return {\n              value: null,\n              done: true\n            };\n          } // If the handler returns true, loop and fetch the next upstream item.\n          // If the upstream iterator throws an endless stream of errors, and if\n          // the handler says to ignore them, then we loop forever here.  That is\n          // the correct behavior-- it's up to the handler to decide when to stop.\n\n        }\n      }\n    })();\n  }\n\n}\n\nclass AsyncMapIterator extends LazyIterator {\n  constructor(upstream, transform) {\n    super();\n    this.upstream = upstream;\n    this.transform = transform;\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> AsyncMap`;\n  }\n\n  next() {\n    var _this21 = this;\n\n    return _asyncToGenerator(function* () {\n      const item = yield _this21.upstream.next();\n\n      if (item.done) {\n        return {\n          value: null,\n          done: true\n        };\n      }\n\n      const inputTensors = tf.tensor_util.getTensorsInContainer(item.value); // Careful: the transform may mutate the item in place.\n      // That's why we have to remember the input Tensors above, and then\n      // below dispose only those that were not passed through to the output.\n      // Note too that the transform function is responsible for tidying\n      // any intermediate Tensors.  Here we are concerned only about the\n      // inputs.\n\n      const mapped = yield _this21.transform(item.value);\n      const outputTensors = tf.tensor_util.getTensorsInContainer(mapped); // TODO(soergel) faster intersection\n      // TODO(soergel) move to tf.disposeExcept(in, out)?\n\n      for (const t of inputTensors) {\n        if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n          t.dispose();\n        }\n      }\n\n      return {\n        value: mapped,\n        done: false\n      };\n    })();\n  }\n\n} // Iterators that maintain a queue of pending items\n// ============================================================================\n\n/**\n * A base class for transforming streams that operate by maintaining an\n * output queue of elements that are ready to return via next().  This is\n * commonly required when the transformation is 1-to-many:  A call to next()\n * may trigger a call to the underlying stream, which will produce many\n * mapped elements of this stream-- of which we need to return only one, so\n * we have to queue the rest.\n */\n\n\nexport class OneToManyIterator extends LazyIterator {\n  constructor() {\n    super();\n    this.outputQueue = new GrowingRingBuffer();\n    this.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n  }\n\n  next() {\n    var _this22 = this;\n\n    return _asyncToGenerator(function* () {\n      // This sets this.lastRead to a new Promise right away, as opposed to\n      // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n      // would not work because this.nextRead would be updated only after the\n      // promise resolves.\n      _this22.lastRead = _this22.lastRead.then(() => _this22.serialNext());\n      return _this22.lastRead;\n    })();\n  }\n\n  serialNext() {\n    var _this23 = this;\n\n    return _asyncToGenerator(function* () {\n      // Fetch so that the queue contains at least one item if possible.\n      // If the upstream source is exhausted, AND there are no items left in\n      // the output queue, then this stream is also exhausted.\n      while (_this23.outputQueue.length() === 0) {\n        // TODO(soergel): consider parallel reads.\n        if (!(yield _this23.pump())) {\n          return {\n            value: null,\n            done: true\n          };\n        }\n      }\n\n      return {\n        value: _this23.outputQueue.shift(),\n        done: false\n      };\n    })();\n  }\n\n}\n\nclass FlatmapIterator extends OneToManyIterator {\n  constructor(upstream, transform) {\n    super();\n    this.upstream = upstream;\n    this.transform = transform;\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Flatmap`;\n  }\n\n  pump() {\n    var _this24 = this;\n\n    return _asyncToGenerator(function* () {\n      const item = yield _this24.upstream.next();\n\n      if (item.done) {\n        return false;\n      }\n\n      const inputTensors = tf.tensor_util.getTensorsInContainer(item.value); // Careful: the transform may mutate the item in place.\n      // that's why we have to remember the input Tensors above, and then\n      // below dispose only those that were not passed through to the output.\n      // Note too that the transform function is responsible for tidying any\n      // intermediate Tensors.  Here we are concerned only about the inputs.\n\n      const mappedArray = _this24.transform(item.value);\n\n      const outputTensors = tf.tensor_util.getTensorsInContainer(mappedArray);\n\n      _this24.outputQueue.pushAll(mappedArray); // TODO(soergel) faster intersection, and deduplicate outputTensors\n      // TODO(soergel) move to tf.disposeExcept(in, out)?\n\n\n      for (const t of inputTensors) {\n        if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n          t.dispose();\n        }\n      }\n\n      return true;\n    })();\n  }\n\n}\n/**\n * Provides a `LazyIterator` that concatenates a stream of underlying\n * streams.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n */\n\n\nexport class ChainedIterator extends LazyIterator {\n  constructor(iterators, baseErrorHandler) {\n    super();\n    this.baseErrorHandler = baseErrorHandler; // Strict Promise execution order:\n    // a next() call may not even begin until the previous one completes.\n\n    this.lastRead = null; // Local state that should not be clobbered by out-of-order execution.\n\n    this.iterator = null;\n    this.moreIterators = iterators;\n  }\n\n  summary() {\n    const upstreamSummaries = 'TODO: fill in upstream of chained summaries';\n    return `${upstreamSummaries} -> Chained`;\n  }\n\n  next() {\n    var _this25 = this;\n\n    return _asyncToGenerator(function* () {\n      _this25.lastRead = _this25.readFromChain(_this25.lastRead);\n      return _this25.lastRead;\n    })();\n  }\n\n  readFromChain(lastRead) {\n    var _this26 = this;\n\n    return _asyncToGenerator(function* () {\n      // Must await on the previous read since the previous read may have advanced\n      // the stream of streams, from which we need to read.\n      // This is unfortunate since we can't parallelize reads. Which means\n      // prefetching of chained streams is a no-op.\n      // One solution is to prefetch immediately upstream of this.\n      yield lastRead;\n\n      if (_this26.iterator == null) {\n        const iteratorResult = yield _this26.moreIterators.next();\n\n        if (iteratorResult.done) {\n          // No more streams to stream from.\n          return {\n            value: null,\n            done: true\n          };\n        }\n\n        _this26.iterator = iteratorResult.value;\n\n        if (_this26.baseErrorHandler != null) {\n          _this26.iterator = _this26.iterator.handleErrors(_this26.baseErrorHandler);\n        }\n      }\n\n      const itemResult = yield _this26.iterator.next();\n\n      if (itemResult.done) {\n        _this26.iterator = null;\n        return _this26.readFromChain(lastRead);\n      }\n\n      return itemResult;\n    })();\n  }\n\n}\nexport var ZipMismatchMode;\n\n(function (ZipMismatchMode) {\n  ZipMismatchMode[ZipMismatchMode[\"FAIL\"] = 0] = \"FAIL\";\n  ZipMismatchMode[ZipMismatchMode[\"SHORTEST\"] = 1] = \"SHORTEST\";\n  ZipMismatchMode[ZipMismatchMode[\"LONGEST\"] = 2] = \"LONGEST\"; // use nulls for exhausted streams; use up the longest stream.\n})(ZipMismatchMode || (ZipMismatchMode = {}));\n/**\n * Provides a `LazyIterator` that zips together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\n\n\nclass ZipIterator extends LazyIterator {\n  constructor(iterators, mismatchMode = ZipMismatchMode.FAIL) {\n    super();\n    this.iterators = iterators;\n    this.mismatchMode = mismatchMode;\n    this.count = 0;\n    this.currentPromise = null;\n  }\n\n  summary() {\n    const upstreamSummaries = 'TODO: fill in upstream of zip summaries';\n    return `{${upstreamSummaries}} -> Zip`;\n  }\n\n  nextState(afterState) {\n    var _this27 = this;\n\n    return _asyncToGenerator(function* () {\n      // This chaining ensures that the underlying next() are not even called\n      // before the previous ones have resolved.\n      yield afterState; // Collect underlying iterator \"done\" signals as a side effect in\n      // getNext()\n\n      let numIterators = 0;\n      let iteratorsDone = 0;\n\n      function getNext(container) {\n        if (container instanceof LazyIterator) {\n          const result = container.next();\n          return {\n            value: result.then(x => {\n              numIterators++;\n\n              if (x.done) {\n                iteratorsDone++;\n              }\n\n              return x.value;\n            }),\n            recurse: false\n          };\n        } else {\n          return {\n            value: null,\n            recurse: true\n          };\n        }\n      }\n\n      const mapped = yield deepMapAndAwaitAll(_this27.iterators, getNext);\n\n      if (numIterators === iteratorsDone) {\n        // The streams have all ended.\n        return {\n          value: null,\n          done: true\n        };\n      }\n\n      if (iteratorsDone > 0) {\n        switch (_this27.mismatchMode) {\n          case ZipMismatchMode.FAIL:\n            throw new Error('Zipped streams should have the same length. ' + `Mismatched at element ${_this27.count}.`);\n\n          case ZipMismatchMode.SHORTEST:\n            return {\n              value: null,\n              done: true\n            };\n\n          case ZipMismatchMode.LONGEST:\n          default: // Continue.  The exhausted streams already produced value: null.\n\n        }\n      }\n\n      _this27.count++;\n      return {\n        value: mapped,\n        done: false\n      };\n    })();\n  }\n\n  next() {\n    var _this28 = this;\n\n    return _asyncToGenerator(function* () {\n      _this28.currentPromise = _this28.nextState(_this28.currentPromise);\n      return _this28.currentPromise;\n    })();\n  }\n\n} // Iterators that maintain a ring buffer of pending promises\n// ============================================================================\n\n/**\n * A stream that prefetches a given number of items from an upstream source,\n * returning them in FIFO order.\n *\n * Note this prefetches Promises, but makes no guarantees about when those\n * Promises resolve.\n */\n\n\nexport class PrefetchIterator extends LazyIterator {\n  constructor(upstream, bufferSize) {\n    super();\n    this.upstream = upstream;\n    this.bufferSize = bufferSize;\n    this.buffer = new RingBuffer(bufferSize);\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Prefetch`;\n  }\n  /**\n   * Refill the prefetch buffer.  Returns only after the buffer is full, or\n   * the upstream source is exhausted.\n   */\n\n\n  refill() {\n    while (!this.buffer.isFull()) {\n      const v = this.upstream.next();\n      this.buffer.push(v);\n    }\n  }\n\n  next() {\n    this.refill(); // This shift will never throw an error because the buffer is always\n    // full after a refill. If the stream is exhausted, the buffer will be\n    // full of Promises that will resolve to the end-of-stream signal.\n\n    return this.buffer.shift();\n  }\n\n}\n/**\n * A stream that performs a sliding-window random shuffle on an upstream\n * source. This is like a `PrefetchIterator` except that the items are\n * returned in randomized order.  Mixing naturally improves as the buffer\n * size increases.\n */\n\nexport class ShuffleIterator extends PrefetchIterator {\n  constructor(upstream, windowSize, seed) {\n    super(upstream, windowSize);\n    this.upstream = upstream;\n    this.windowSize = windowSize; // Local state that should not be clobbered by out-of-order execution.\n\n    this.upstreamExhausted = false;\n    this.random = seedrandom.alea(seed || tf.util.now().toString());\n    this.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n  }\n\n  next() {\n    var _this29 = this;\n\n    return _asyncToGenerator(function* () {\n      // This sets this.lastRead to a new Promise right away, as opposed to\n      // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n      // would not work because this.nextRead would be updated only after the\n      // promise resolves.\n      _this29.lastRead = _this29.lastRead.then(() => _this29.serialNext());\n      return _this29.lastRead;\n    })();\n  }\n\n  randomInt(max) {\n    return Math.floor(this.random() * max);\n  }\n\n  chooseIndex() {\n    return this.randomInt(this.buffer.length());\n  }\n\n  serialNext() {\n    var _this30 = this;\n\n    return _asyncToGenerator(function* () {\n      // TODO(soergel): consider performance\n      if (!_this30.upstreamExhausted) {\n        _this30.refill();\n      }\n\n      while (!_this30.buffer.isEmpty()) {\n        const chosenIndex = _this30.chooseIndex();\n\n        const result = yield _this30.buffer.shuffleExcise(chosenIndex);\n\n        if (result.done) {\n          _this30.upstreamExhausted = true;\n        } else {\n          _this30.refill();\n\n          return result;\n        }\n      }\n\n      return {\n        value: null,\n        done: true\n      };\n    })();\n  }\n\n}","map":{"version":3,"sources":["/Users/ryanliang/Downloads/main_movir_picker/node_modules/@tensorflow/tfjs-data/dist/iterators/lazy_iterator.js"],"names":["tf","seedrandom","deepClone","deepMapAndAwaitAll","deepZip","zipToList","GrowingRingBuffer","RingBuffer","iteratorFromItems","items","ArrayIterator","iteratorFromIncrementing","start","i","iteratorFromFunction","value","done","func","FunctionCallIterator","iteratorFromConcatenated","baseIterators","baseErrorHandler","ChainedIterator","iteratorFromConcatenatedFunction","iteratorFunc","count","take","iteratorFromZipped","iterators","mismatchMode","ZipMismatchMode","FAIL","ZipIterator","LazyIterator","toArray","result","x","next","push","toArrayForTest","stream","prefetch","resolveFully","resolveWhile","predicate","shouldContinue","handleErrors","handler","ErrorHandlingLazyIterator","filter","FilterIterator","map","transform","MapIterator","mapAsync","AsyncMapIterator","serialMapAsync","serial","flatmap","FlatmapIterator","forEachAsync","f","serialForEach","rowMajorBatch","batchSize","smallLastBatch","RowMajorBatchIterator","columnMajorBatch","zipFn","rowBatches","concatenate","iterator","TakeIterator","skip","SkipIterator","bufferSize","PrefetchIterator","shuffle","windowSize","seed","ShuffleIterator","SerialIterator","constructor","trav","summary","length","item","nextFn","e","message","upstream","lastRead","Promise","resolve","then","serialNext","maxCount","skipped","dispose","enableSmallLastBatch","batch","inputTensors","tensor_util","getTensorsInContainer","mapped","outputTensors","t","isTensorInList","OneToManyIterator","outputQueue","pump","shift","mappedArray","pushAll","moreIterators","upstreamSummaries","readFromChain","iteratorResult","itemResult","currentPromise","nextState","afterState","numIterators","iteratorsDone","getNext","container","recurse","Error","SHORTEST","LONGEST","buffer","refill","isFull","v","upstreamExhausted","random","alea","util","now","toString","randomInt","max","Math","floor","chooseIndex","isEmpty","chosenIndex","shuffleExcise"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport * as seedrandom from 'seedrandom';\nimport { deepClone } from '../util/deep_clone';\nimport { deepMapAndAwaitAll, deepZip, zipToList } from '../util/deep_map';\nimport { GrowingRingBuffer } from '../util/growing_ring_buffer';\nimport { RingBuffer } from '../util/ring_buffer';\n// Here we implement a simple asynchronous iterator.\n// This lets us avoid using either third-party stream libraries or\n// recent TypeScript language support requiring polyfills.\n/**\n * Create a `LazyIterator` from an array of items.\n */\nexport function iteratorFromItems(items) {\n    return new ArrayIterator(items);\n}\n/**\n * Create a `LazyIterator` of incrementing integers.\n */\nexport function iteratorFromIncrementing(start) {\n    let i = start;\n    return iteratorFromFunction(() => ({ value: i++, done: false }));\n}\n/**\n * Create a `LazyIterator` from a function.\n *\n * ```js\n * let i = -1;\n * const func = () =>\n *    ++i < 5 ? {value: i, done: false} : {value: null, done: true};\n * const iter = tf.data.iteratorFromFunction(func);\n * await iter.forEachAsync(e => console.log(e));\n * ```\n *\n * @param func A function that produces data on each call.\n */\nexport function iteratorFromFunction(func) {\n    return new FunctionCallIterator(func);\n}\n/**\n * Create a `LazyIterator` by concatenating underlying streams, which are\n * themselves provided as a stream.\n *\n * This can also be thought of as a \"stream flatten\" operation.\n *\n * @param baseIterators A stream of streams to be concatenated.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\nexport function iteratorFromConcatenated(baseIterators, baseErrorHandler) {\n    return new ChainedIterator(baseIterators, baseErrorHandler);\n}\n/**\n * Create a `LazyIterator` by concatenating streams produced by calling a\n * stream-generating function a given number of times.\n *\n * Since a `LazyIterator` is read-once, it cannot be repeated, but this\n * function can be used to achieve a similar effect:\n *\n *   LazyIterator.ofConcatenatedFunction(() => new MyIterator(), 6);\n *\n * @param iteratorFunc: A function that produces a new stream on each call.\n * @param count: The number of times to call the function.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\nexport function iteratorFromConcatenatedFunction(iteratorFunc, count, baseErrorHandler) {\n    return iteratorFromConcatenated(iteratorFromFunction(iteratorFunc).take(count), baseErrorHandler);\n}\n/**\n * Create a `LazyIterator` by zipping together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\nexport function iteratorFromZipped(iterators, mismatchMode = ZipMismatchMode.FAIL) {\n    return new ZipIterator(iterators, mismatchMode);\n}\n/**\n * An asynchronous iterator, providing lazy access to a potentially\n * unbounded stream of elements.\n *\n * Iterator can be obtained from a dataset:\n * `const iter = await dataset.iterator();`\n */\nexport class LazyIterator {\n    /**\n     * Collect all remaining elements of a bounded stream into an array.\n     * Obviously this will succeed only for small streams that fit in memory.\n     * Useful for testing.\n     *\n     * @returns A Promise for an array of stream elements, which will resolve\n     *   when the stream is exhausted.\n     */\n    async toArray() {\n        const result = [];\n        let x = await this.next();\n        while (!x.done) {\n            result.push(x.value);\n            x = await this.next();\n        }\n        return result;\n    }\n    /**\n     * Collect all elements of this dataset into an array with prefetching 100\n     * elements. This is useful for testing, because the prefetch changes the\n     * order in which the Promises are resolved along the processing pipeline.\n     * This may help expose bugs where results are dependent on the order of\n     * Promise resolution rather than on the logical order of the stream (i.e.,\n     * due to hidden mutable state).\n     *\n     * @returns A Promise for an array of stream elements, which will resolve\n     *   when the stream is exhausted.\n     */\n    async toArrayForTest() {\n        const stream = this.prefetch(100);\n        const result = [];\n        let x = await stream.next();\n        while (!x.done) {\n            result.push(x.value);\n            x = await stream.next();\n        }\n        return result;\n    }\n    /**\n     * Draw items from the stream until it is exhausted.\n     *\n     * This can be useful when the stream has side effects but no output.  In\n     * that case, calling this function guarantees that the stream will be\n     * fully processed.\n     */\n    async resolveFully() {\n        let x = await this.next();\n        while (!x.done) {\n            x = await this.next();\n        }\n    }\n    /**\n     * Draw items from the stream until it is exhausted, or a predicate fails.\n     *\n     * This can be useful when the stream has side effects but no output.  In\n     * that case, calling this function guarantees that the stream will be\n     * fully processed.\n     */\n    async resolveWhile(predicate) {\n        let x = await this.next();\n        let shouldContinue = predicate(x.value);\n        while ((!x.done) && shouldContinue) {\n            x = await this.next();\n            shouldContinue = predicate(x.value);\n        }\n    }\n    /**\n     * Handles errors thrown on this stream using a provided handler function.\n     *\n     * @param handler A function that handles any `Error` thrown during a `next()`\n     *   call and returns true if the stream should continue (dropping the failed\n     *   call) or false if the stream should quietly terminate.  If the handler\n     *   itself throws (or rethrows) an `Error`, that will be propagated.\n     *\n     * @returns A `LazyIterator` of elements passed through from upstream,\n     *   possibly filtering or terminating on upstream `next()` calls that\n     *   throw an `Error`.\n     */\n    handleErrors(handler) {\n        return new ErrorHandlingLazyIterator(this, handler);\n    }\n    // TODO(soergel): Implement reduce() etc.\n    /**\n     * Filters this stream according to `predicate`.\n     *\n     * @param predicate A function mapping a stream element to a boolean or a\n     * `Promise` for one.\n     *\n     * @returns A `LazyIterator` of elements for which the predicate was true.\n     */\n    filter(predicate) {\n        return new FilterIterator(this, predicate);\n    }\n    /**\n     * Maps this stream through a 1-to-1 transform.\n     *\n     * @param transform A function mapping a stream element to a transformed\n     *   element.\n     *\n     * @returns A `LazyIterator` of transformed elements.\n     */\n    map(transform) {\n        return new MapIterator(this, transform);\n    }\n    /**\n     * Maps this stream through an async 1-to-1 transform.\n     *\n     * @param transform A function mapping a stream element to a `Promise` for a\n     *   transformed stream element.\n     *\n     * @returns A `LazyIterator` of transformed elements.\n     */\n    mapAsync(transform) {\n        return new AsyncMapIterator(this, transform);\n    }\n    /**\n     * Maps this stream through a 1-to-1 transform, forcing serial execution.\n     *\n     * @param transform A function mapping a stream element to a transformed\n     *   element.\n     *\n     * @returns A `LazyIterator` of transformed elements.\n     */\n    serialMapAsync(transform) {\n        return new AsyncMapIterator(this, transform).serial();\n    }\n    /**\n     * Maps this stream through a 1-to-many transform.\n     *\n     * @param transform A function mapping a stream element to an array of\n     *   transformed elements.\n     *\n     * @returns A `DataStream` of transformed elements.\n     */\n    flatmap(transform) {\n        return new FlatmapIterator(this, transform);\n    }\n    /**\n     * Apply a function to every element of the stream.\n     *\n     * @param f A function to apply to each stream element.\n     */\n    async forEachAsync(f) {\n        return this.map(f).resolveFully();\n    }\n    /**\n     * Apply a function to every element of the stream, forcing serial execution.\n     *\n     * @param f A function to apply to each stream element.  Should return 'true'\n     *   to indicate that the stream should continue, or 'false' to cause it to\n     *   terminate.\n     */\n    async serialForEach(f) {\n        return this.serialMapAsync(f).resolveWhile(x => (x === true));\n    }\n    /**\n     * Groups elements into batches, represented as arrays of elements.\n     *\n     * We can think of the elements of this iterator as 'rows' (even if they are\n     * nested structures).  By the same token, consecutive values for a given\n     * key within the elements form a 'column'.  This matches the usual sense of\n     * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n     *\n     * Thus, \"Row-major\" means that the resulting batch is simply a collection of\n     * rows: `[row1, row2, row3, ...]`.  This is contrast to the column-major\n     * form, which is needed for vectorized computation.\n     *\n     * @param batchSize The number of elements desired per batch.\n     * @param smallLastBatch Whether to emit the final batch when it has fewer\n     *   than batchSize elements. Default true.\n     * @returns A `LazyIterator` of batches of elements, represented as arrays\n     *   of the original element type.\n     */\n    rowMajorBatch(batchSize, smallLastBatch = true) {\n        return new RowMajorBatchIterator(this, batchSize, smallLastBatch);\n    }\n    /**\n     * Groups elements into batches, represented in column-major form.\n     *\n     * We can think of the elements of this iterator as 'rows' (even if they are\n     * nested structures).  By the same token, consecutive values for a given\n     * key within the elements form a 'column'.  This matches the usual sense of\n     * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n     *\n     * Thus, \"column-major\" means that the resulting batch is a (potentially\n     * nested) structure representing the columns.  Each column entry, then,\n     * contains a collection of the values found in that column for a range of\n     * input elements.  This representation allows for vectorized computation, in\n     * contrast to the row-major form.\n     *\n     * The inputs should all have the same nested structure (i.e., of arrays and\n     * dicts).  The result is a single object with the same nested structure,\n     * where the leaves are arrays collecting the values of the inputs at that\n     * location (or, optionally, the result of a custom function applied to those\n     * arrays).\n     *\n     * @param batchSize The number of elements desired per batch.\n     * @param smallLastBatch Whether to emit the final batch when it has fewer\n     *   than batchSize elements. Default true.\n     * @param zipFn: (optional) A function that expects an array of elements at a\n     *   single node of the object tree, and returns a `DeepMapResult`.  The\n     *   `DeepMapResult` either provides a result value for that node (i.e.,\n     *   representing the subtree), or indicates that the node should be processed\n     *   recursively.  The default zipFn recurses as far as possible and places\n     *   arrays at the leaves.\n     * @returns A `LazyIterator` of batches of elements, represented as an object\n     *   with collections at the leaves.\n     */\n    columnMajorBatch(batchSize, smallLastBatch = true, \n    // tslint:disable-next-line:no-any\n    zipFn = zipToList) {\n        // First collect the desired number of input elements as a row-major batch.\n        const rowBatches = this.rowMajorBatch(batchSize, smallLastBatch);\n        // Now 'rotate' or 'pivot' the data, collecting all values from each column\n        // in the batch (i.e., for each key within the elements) into an array.\n        return rowBatches.map(x => deepZip(x, zipFn));\n    }\n    /**\n     * Concatenate this `LazyIterator` with another.\n     *\n     * @param iterator A `LazyIterator` to be concatenated onto this one.\n     * @param baseErrorHandler An optional function that can intercept `Error`s\n     *   raised during a `next()` call on the base stream.  This function can\n     *   decide whether the error should be propagated, whether the error should\n     *   be ignored, or whether the base stream should be terminated.\n     * @returns A `LazyIterator`.\n     */\n    concatenate(iterator, baseErrorHandler) {\n        return new ChainedIterator(iteratorFromItems([this, iterator]), baseErrorHandler);\n    }\n    /**\n     * Limits this stream to return at most `count` items.\n     *\n     * @param count The maximum number of items to provide from the stream. If\n     * a negative or undefined value is given, the entire stream is returned\n     *   unaltered.\n     */\n    take(count) {\n        if (count < 0 || count == null) {\n            return this;\n        }\n        return new TakeIterator(this, count);\n    }\n    /**\n     * Skips the first `count` items in this stream.\n     *\n     * @param count The number of items to skip.  If a negative or undefined\n     * value is given, the entire stream is returned unaltered.\n     */\n    skip(count) {\n        if (count < 0 || count == null) {\n            return this;\n        }\n        return new SkipIterator(this, count);\n    }\n    /**\n     * Prefetch the first `bufferSize` items in this stream.\n     *\n     * Note this prefetches Promises, but makes no guarantees about when those\n     * Promises resolve.\n     *\n     * @param bufferSize: An integer specifying the number of elements to be\n     *   prefetched.\n     */\n    prefetch(bufferSize) {\n        return new PrefetchIterator(this, bufferSize);\n    }\n    // TODO(soergel): deep sharded shuffle, where supported\n    /**\n     * Randomly shuffles the elements of this stream.\n     *\n     * @param bufferSize: An integer specifying the number of elements from\n     * this stream from which the new stream will sample.\n     * @param seed: (Optional.) An integer specifying the random seed that\n     * will be used to create the distribution.\n     */\n    shuffle(windowSize, seed) {\n        return new ShuffleIterator(this, windowSize, seed);\n    }\n    /**\n     * Force an iterator to execute serially: each next() call will await the\n     * prior one, so that they cannot execute concurrently.\n     */\n    serial() {\n        return new SerialIterator(this);\n    }\n}\n// ============================================================================\n// The following private classes serve to implement the chainable methods\n// on LazyIterator.  Unfortunately they can't be placed in separate files,\n// due to resulting trouble with circular imports.\n// ============================================================================\n// Iterators that just extend LazyIterator directly\n// ============================================================================\nclass ArrayIterator extends LazyIterator {\n    constructor(items) {\n        super();\n        this.items = items;\n        this.trav = 0;\n    }\n    summary() {\n        return `Array of ${this.items.length} items`;\n    }\n    async next() {\n        if (this.trav >= this.items.length) {\n            return { value: null, done: true };\n        }\n        const item = this.items[this.trav];\n        this.trav++;\n        return { value: deepClone(item), done: false };\n    }\n}\nclass FunctionCallIterator extends LazyIterator {\n    constructor(nextFn) {\n        super();\n        this.nextFn = nextFn;\n    }\n    summary() {\n        return `Function call`;\n    }\n    async next() {\n        try {\n            return this.nextFn();\n        }\n        catch (e) {\n            // Modify the error message but leave the stack trace intact\n            e.message =\n                `Error thrown while iterating through a dataset: ${e.message}`;\n            throw e;\n        }\n    }\n}\nclass SerialIterator extends LazyIterator {\n    constructor(upstream) {\n        super();\n        this.upstream = upstream;\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Serial`;\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    async serialNext() {\n        return this.upstream.next();\n    }\n}\nclass SkipIterator extends LazyIterator {\n    constructor(upstream, maxCount) {\n        super();\n        this.upstream = upstream;\n        this.maxCount = maxCount;\n        // Local state that should not be clobbered by out-of-order execution.\n        this.count = 0;\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Skip`;\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    async serialNext() {\n        // TODO(soergel): consider tradeoffs of reading in parallel, eg.\n        // collecting next() promises in an Array and then waiting for\n        // Promise.all() of those. Benefit: pseudo-parallel execution.  Drawback:\n        // maybe delayed GC.\n        while (this.count++ < this.maxCount) {\n            const skipped = await this.upstream.next();\n            // short-circuit if upstream is already empty\n            if (skipped.done) {\n                return skipped;\n            }\n            tf.dispose(skipped.value);\n        }\n        return this.upstream.next();\n    }\n}\nclass TakeIterator extends LazyIterator {\n    constructor(upstream, maxCount) {\n        super();\n        this.upstream = upstream;\n        this.maxCount = maxCount;\n        this.count = 0;\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Take`;\n    }\n    async next() {\n        if (this.count++ >= this.maxCount) {\n            return { value: null, done: true };\n        }\n        return this.upstream.next();\n    }\n}\n// Note this batch just groups items into row-wise element arrays.\n// Rotating these to a column-wise representation happens only at the dataset\n// level.\nclass RowMajorBatchIterator extends LazyIterator {\n    constructor(upstream, batchSize, enableSmallLastBatch = true) {\n        super();\n        this.upstream = upstream;\n        this.batchSize = batchSize;\n        this.enableSmallLastBatch = enableSmallLastBatch;\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    summary() {\n        return `${this.upstream.summary()} -> RowMajorBatch`;\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    async serialNext() {\n        const batch = [];\n        while (batch.length < this.batchSize) {\n            const item = await this.upstream.next();\n            if (item.done) {\n                if (this.enableSmallLastBatch && batch.length > 0) {\n                    return { value: batch, done: false };\n                }\n                return { value: null, done: true };\n            }\n            batch.push(item.value);\n        }\n        return { value: batch, done: false };\n    }\n}\nclass FilterIterator extends LazyIterator {\n    constructor(upstream, predicate) {\n        super();\n        this.upstream = upstream;\n        this.predicate = predicate;\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Filter`;\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    async serialNext() {\n        while (true) {\n            const item = await this.upstream.next();\n            if (item.done || this.predicate(item.value)) {\n                return item;\n            }\n            tf.dispose(item.value);\n        }\n    }\n}\nclass MapIterator extends LazyIterator {\n    constructor(upstream, transform) {\n        super();\n        this.upstream = upstream;\n        this.transform = transform;\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Map`;\n    }\n    async next() {\n        const item = await this.upstream.next();\n        if (item.done) {\n            return { value: null, done: true };\n        }\n        const inputTensors = tf.tensor_util.getTensorsInContainer(item.value);\n        // Careful: the transform may mutate the item in place.\n        // That's why we have to remember the input Tensors above, and then\n        // below dispose only those that were not passed through to the output.\n        // Note too that the transform function is responsible for tidying\n        // any intermediate Tensors.  Here we are concerned only about the\n        // inputs.\n        const mapped = this.transform(item.value);\n        const outputTensors = tf.tensor_util.getTensorsInContainer(mapped);\n        // TODO(soergel) faster intersection\n        // TODO(soergel) move to tf.disposeExcept(in, out)?\n        for (const t of inputTensors) {\n            if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                t.dispose();\n            }\n        }\n        return { value: mapped, done: false };\n    }\n}\nclass ErrorHandlingLazyIterator extends LazyIterator {\n    constructor(upstream, handler) {\n        super();\n        this.upstream = upstream;\n        this.handler = handler;\n        this.count = 0;\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    summary() {\n        return `${this.upstream.summary()} -> handleErrors`;\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    async serialNext() {\n        while (true) {\n            try {\n                return await this.upstream.next();\n            }\n            catch (e) {\n                if (!this.handler(e)) {\n                    return { value: null, done: true };\n                }\n                // If the handler returns true, loop and fetch the next upstream item.\n                // If the upstream iterator throws an endless stream of errors, and if\n                // the handler says to ignore them, then we loop forever here.  That is\n                // the correct behavior-- it's up to the handler to decide when to stop.\n            }\n        }\n    }\n}\nclass AsyncMapIterator extends LazyIterator {\n    constructor(upstream, transform) {\n        super();\n        this.upstream = upstream;\n        this.transform = transform;\n    }\n    summary() {\n        return `${this.upstream.summary()} -> AsyncMap`;\n    }\n    async next() {\n        const item = await this.upstream.next();\n        if (item.done) {\n            return { value: null, done: true };\n        }\n        const inputTensors = tf.tensor_util.getTensorsInContainer(item.value);\n        // Careful: the transform may mutate the item in place.\n        // That's why we have to remember the input Tensors above, and then\n        // below dispose only those that were not passed through to the output.\n        // Note too that the transform function is responsible for tidying\n        // any intermediate Tensors.  Here we are concerned only about the\n        // inputs.\n        const mapped = await this.transform(item.value);\n        const outputTensors = tf.tensor_util.getTensorsInContainer(mapped);\n        // TODO(soergel) faster intersection\n        // TODO(soergel) move to tf.disposeExcept(in, out)?\n        for (const t of inputTensors) {\n            if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                t.dispose();\n            }\n        }\n        return { value: mapped, done: false };\n    }\n}\n// Iterators that maintain a queue of pending items\n// ============================================================================\n/**\n * A base class for transforming streams that operate by maintaining an\n * output queue of elements that are ready to return via next().  This is\n * commonly required when the transformation is 1-to-many:  A call to next()\n * may trigger a call to the underlying stream, which will produce many\n * mapped elements of this stream-- of which we need to return only one, so\n * we have to queue the rest.\n */\nexport class OneToManyIterator extends LazyIterator {\n    constructor() {\n        super();\n        this.outputQueue = new GrowingRingBuffer();\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    async serialNext() {\n        // Fetch so that the queue contains at least one item if possible.\n        // If the upstream source is exhausted, AND there are no items left in\n        // the output queue, then this stream is also exhausted.\n        while (this.outputQueue.length() === 0) {\n            // TODO(soergel): consider parallel reads.\n            if (!await this.pump()) {\n                return { value: null, done: true };\n            }\n        }\n        return { value: this.outputQueue.shift(), done: false };\n    }\n}\nclass FlatmapIterator extends OneToManyIterator {\n    constructor(upstream, transform) {\n        super();\n        this.upstream = upstream;\n        this.transform = transform;\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Flatmap`;\n    }\n    async pump() {\n        const item = await this.upstream.next();\n        if (item.done) {\n            return false;\n        }\n        const inputTensors = tf.tensor_util.getTensorsInContainer(item.value);\n        // Careful: the transform may mutate the item in place.\n        // that's why we have to remember the input Tensors above, and then\n        // below dispose only those that were not passed through to the output.\n        // Note too that the transform function is responsible for tidying any\n        // intermediate Tensors.  Here we are concerned only about the inputs.\n        const mappedArray = this.transform(item.value);\n        const outputTensors = tf.tensor_util.getTensorsInContainer(mappedArray);\n        this.outputQueue.pushAll(mappedArray);\n        // TODO(soergel) faster intersection, and deduplicate outputTensors\n        // TODO(soergel) move to tf.disposeExcept(in, out)?\n        for (const t of inputTensors) {\n            if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                t.dispose();\n            }\n        }\n        return true;\n    }\n}\n/**\n * Provides a `LazyIterator` that concatenates a stream of underlying\n * streams.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n */\nexport class ChainedIterator extends LazyIterator {\n    constructor(iterators, baseErrorHandler) {\n        super();\n        this.baseErrorHandler = baseErrorHandler;\n        // Strict Promise execution order:\n        // a next() call may not even begin until the previous one completes.\n        this.lastRead = null;\n        // Local state that should not be clobbered by out-of-order execution.\n        this.iterator = null;\n        this.moreIterators = iterators;\n    }\n    summary() {\n        const upstreamSummaries = 'TODO: fill in upstream of chained summaries';\n        return `${upstreamSummaries} -> Chained`;\n    }\n    async next() {\n        this.lastRead = this.readFromChain(this.lastRead);\n        return this.lastRead;\n    }\n    async readFromChain(lastRead) {\n        // Must await on the previous read since the previous read may have advanced\n        // the stream of streams, from which we need to read.\n        // This is unfortunate since we can't parallelize reads. Which means\n        // prefetching of chained streams is a no-op.\n        // One solution is to prefetch immediately upstream of this.\n        await lastRead;\n        if (this.iterator == null) {\n            const iteratorResult = await this.moreIterators.next();\n            if (iteratorResult.done) {\n                // No more streams to stream from.\n                return { value: null, done: true };\n            }\n            this.iterator = iteratorResult.value;\n            if (this.baseErrorHandler != null) {\n                this.iterator = this.iterator.handleErrors(this.baseErrorHandler);\n            }\n        }\n        const itemResult = await this.iterator.next();\n        if (itemResult.done) {\n            this.iterator = null;\n            return this.readFromChain(lastRead);\n        }\n        return itemResult;\n    }\n}\nexport var ZipMismatchMode;\n(function (ZipMismatchMode) {\n    ZipMismatchMode[ZipMismatchMode[\"FAIL\"] = 0] = \"FAIL\";\n    ZipMismatchMode[ZipMismatchMode[\"SHORTEST\"] = 1] = \"SHORTEST\";\n    ZipMismatchMode[ZipMismatchMode[\"LONGEST\"] = 2] = \"LONGEST\"; // use nulls for exhausted streams; use up the longest stream.\n})(ZipMismatchMode || (ZipMismatchMode = {}));\n/**\n * Provides a `LazyIterator` that zips together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\nclass ZipIterator extends LazyIterator {\n    constructor(iterators, mismatchMode = ZipMismatchMode.FAIL) {\n        super();\n        this.iterators = iterators;\n        this.mismatchMode = mismatchMode;\n        this.count = 0;\n        this.currentPromise = null;\n    }\n    summary() {\n        const upstreamSummaries = 'TODO: fill in upstream of zip summaries';\n        return `{${upstreamSummaries}} -> Zip`;\n    }\n    async nextState(afterState) {\n        // This chaining ensures that the underlying next() are not even called\n        // before the previous ones have resolved.\n        await afterState;\n        // Collect underlying iterator \"done\" signals as a side effect in\n        // getNext()\n        let numIterators = 0;\n        let iteratorsDone = 0;\n        function getNext(container) {\n            if (container instanceof LazyIterator) {\n                const result = container.next();\n                return {\n                    value: result.then(x => {\n                        numIterators++;\n                        if (x.done) {\n                            iteratorsDone++;\n                        }\n                        return x.value;\n                    }),\n                    recurse: false\n                };\n            }\n            else {\n                return { value: null, recurse: true };\n            }\n        }\n        const mapped = await deepMapAndAwaitAll(this.iterators, getNext);\n        if (numIterators === iteratorsDone) {\n            // The streams have all ended.\n            return { value: null, done: true };\n        }\n        if (iteratorsDone > 0) {\n            switch (this.mismatchMode) {\n                case ZipMismatchMode.FAIL:\n                    throw new Error('Zipped streams should have the same length. ' +\n                        `Mismatched at element ${this.count}.`);\n                case ZipMismatchMode.SHORTEST:\n                    return { value: null, done: true };\n                case ZipMismatchMode.LONGEST:\n                default:\n                // Continue.  The exhausted streams already produced value: null.\n            }\n        }\n        this.count++;\n        return { value: mapped, done: false };\n    }\n    async next() {\n        this.currentPromise = this.nextState(this.currentPromise);\n        return this.currentPromise;\n    }\n}\n// Iterators that maintain a ring buffer of pending promises\n// ============================================================================\n/**\n * A stream that prefetches a given number of items from an upstream source,\n * returning them in FIFO order.\n *\n * Note this prefetches Promises, but makes no guarantees about when those\n * Promises resolve.\n */\nexport class PrefetchIterator extends LazyIterator {\n    constructor(upstream, bufferSize) {\n        super();\n        this.upstream = upstream;\n        this.bufferSize = bufferSize;\n        this.buffer = new RingBuffer(bufferSize);\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Prefetch`;\n    }\n    /**\n     * Refill the prefetch buffer.  Returns only after the buffer is full, or\n     * the upstream source is exhausted.\n     */\n    refill() {\n        while (!this.buffer.isFull()) {\n            const v = this.upstream.next();\n            this.buffer.push(v);\n        }\n    }\n    next() {\n        this.refill();\n        // This shift will never throw an error because the buffer is always\n        // full after a refill. If the stream is exhausted, the buffer will be\n        // full of Promises that will resolve to the end-of-stream signal.\n        return this.buffer.shift();\n    }\n}\n/**\n * A stream that performs a sliding-window random shuffle on an upstream\n * source. This is like a `PrefetchIterator` except that the items are\n * returned in randomized order.  Mixing naturally improves as the buffer\n * size increases.\n */\nexport class ShuffleIterator extends PrefetchIterator {\n    constructor(upstream, windowSize, seed) {\n        super(upstream, windowSize);\n        this.upstream = upstream;\n        this.windowSize = windowSize;\n        // Local state that should not be clobbered by out-of-order execution.\n        this.upstreamExhausted = false;\n        this.random = seedrandom.alea(seed || tf.util.now().toString());\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    randomInt(max) {\n        return Math.floor(this.random() * max);\n    }\n    chooseIndex() {\n        return this.randomInt(this.buffer.length());\n    }\n    async serialNext() {\n        // TODO(soergel): consider performance\n        if (!this.upstreamExhausted) {\n            this.refill();\n        }\n        while (!this.buffer.isEmpty()) {\n            const chosenIndex = this.chooseIndex();\n            const result = await this.buffer.shuffleExcise(chosenIndex);\n            if (result.done) {\n                this.upstreamExhausted = true;\n            }\n            else {\n                this.refill();\n                return result;\n            }\n        }\n        return { value: null, done: true };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}